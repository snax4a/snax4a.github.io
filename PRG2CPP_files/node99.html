<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
<TITLE>15.3 Konstruktory - dalsze szczegóły</TITLE>
<META NAME="description" CONTENT="15.3 Konstruktory - dalsze szczegóły">
<META NAME="keywords" CONTENT="PRG2CPP">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="LaTeX2HTML v2016">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="PRG2CPP.css">

<LINK REL="next" HREF="node100.html">
<LINK REL="previous" HREF="node98.html">
<LINK REL="up" HREF="node96.html">
<LINK REL="next" HREF="node100.html">
</HEAD>

<BODY >

<DIV CLASS="navigation">
<A NAME="tex2html2144"
  HREF="node98.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="ikonypng/prev.png"></A>
<A NAME="tex2html2150"
  HREF="node96.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="ikonypng/up.png"></A>
<A NAME="tex2html2156"
  HREF="node100.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="ikonypng/next.png"></A>
<A NAME="tex2html2152"
  HREF="node1.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="ikonypng/contents.png"></A>
<A NAME="tex2html2154"
  HREF="node150.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="index"
 SRC="ikonypng/index.png"></A> <BR>
<B>Wstecz:</B> <A NAME="tex2html2145"
  HREF="node98.html">15.2 Metody ulotne</A>
<B>W g&#243;r&#281;:</B> <A NAME="tex2html2151"
  HREF="node96.html">15. Klasy (II)</A>
<B>Dalej:</B> <A NAME="tex2html2157"
  HREF="node100.html">15.4 Funkcje zaprzyjaźnione</A>
<BR> <HR> <P>
</DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Podrozdzia&#322;y</STRONG></A>

<UL CLASS="ChildLinks">
<LI><A NAME="tex2html2158"
  HREF="node99.html#SECTION001631000000000000000"><SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Konstruktory kopiujące</A>
<LI><A NAME="tex2html2159"
  HREF="node99.html#SECTION001632000000000000000"><SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Listy inicjalizacyjne</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION001630000000000000000"></A>
  <A NAME="klasyd:kon"></A>
<BR>
<SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">3</SPAN> Konstruktory - dalsze szczegóły
</H1>

<P>
O konstruktorach mówiliśmy już
    w&nbsp;jednym z&nbsp;poprzednich <A HREF="node91.html#klasy:kon">rozdziałów</A> .
Nie wyczerpaliśmy jednak tego tematu. Bardzo ważną rolę w&nbsp;C++
pełnią konstruktory kopiujące. Omówimy je w&nbsp;następnym
podrozdziale. Innym ważnym mechanizmem jest mechanizm inicjowania
tworzonych obiektów za pomocą list inicjalizacyjnych. Często
jest on tylko wygodnym skrótem, czasem jednak jest konieczny
do prawidłowego skonstruowania obiektu. Definiowanie konstruktorów
kopiujących jest zazwyczaj konieczne w&nbsp;klasach zawierających pola
wskaźnikowe; wtedy też niezbędne jest zdefiniowanie samemu
<FONT COLOR="#7b003e"><I>destruktora</I></FONT> i&nbsp;przedefiniowanie operatora przypisania.

<P>

<H2><A NAME="SECTION001631000000000000000"></A><A NAME="klasyd:konkop"></A>
<BR>
<SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Konstruktory kopiujące
</H2>

<P>
Zadaniem <FONT COLOR="#7b003e"><B>konstruktora kopiującego</B></FONT>
<A NAME="17697"></A> jest utworzenie obiektu identycznego
jak inny, istniejący wcześniej, obiekt tej samej klasy, pełniący wobec
tego rolę wzorca. Obiekt ma być identyczny, ale z&nbsp;oryginałem całkowicie
rozłączny; późniejsza modyfikacja jednego z&nbsp;nich nie powinna mieć wpływu
na drugi.

<P>
Dla klasy
<!--O--><span class='klasa'>A<!--C--></span>
 jest to konstruktor o&nbsp;sygnaturze
'
<FONT COLOR="#000000"><TT>A(const A&amp;)</TT></FONT>'. Modyfikator
<!--O--><span class='klucz'>const<!--C--></span>
 nie jest tu
obowiązkowy, co za chwilę wyjaśnimy. Oczywiście rolę konstruktora
kopiującego może też pełnić konstruktor, w&nbsp;którym pierwszy
parametr jest typu
<!--O--><span class='typ'>const A&amp;<!--C--></span>
 (lub
<!--O--><span class='typ'>A&amp;<!--C--></span>), a&nbsp;pozostałe mają
zdefiniowane wartości domyślne. W&nbsp;każdym razie pierwszym
(i&nbsp;najczęściej jedynym) argumentem wywołania takiego konstruktora
będzie zawsze istniejący wcześniej obiekt klasy&nbsp;
<!--O--><span class='klasa'>A<!--C--></span>, który
zostanie do konstruktora kopiującego przesłany przez referencję.

<P>
Mogłoby się wydawać, że tego rodzaju konstruktor często w&nbsp;ogóle
nie będzie potrzebny. Tak jednak nie jest: jest on potrzebny
bardzo często, choć nie zawsze sami musimy go definiować.
Zauważmy bowiem, że kopiowanie obiektów zachodzi zawsze, gdy
obiekt pełni rolę argumentu wywołania funkcji, jeśli tylko
przekazywany jest do funkcji przez wartość, a&nbsp;nie przez wskaźnik
lub referencję; na stosie musi zostać położona <FONT COLOR="#7b003e"><I>kopia</I></FONT>
obiektu. Podobnie rzecz się ma przy zwracaniu przez wartość obiektu
jako rezultatu funkcji: tu również jest wykonywana kopia obiektu.
Za każdym razem w&nbsp;takim przypadku używany jest konstruktor
kopiujący. Widzimy zatem, że trudno byłoby napisać
program, w&nbsp;którym konstruktory kopiujące nie byłyby używane.
Rozpatrzmy przykład programu, który nic nie robi prócz
pisania informacji o&nbsp;wywołaniach konstruktorów.
<BR><A NAME="kopiow.cpp"></A>
<BR CLEAR='ALL'>
<div class='kodpro'><HR>
      <SPAN  CLASS="textbf">P<SPAN CLASS="arabic">114</SPAN>:</SPAN>
      <A NAME="tex2html121"
  HREF="source-files/kopiow.cpp">
<!--O--><span class='downl'>kopiow.cpp<!--C--></span></A>
<A NAME="18189"></A>
      &nbsp;&nbsp;&nbsp;&nbsp;<SMALL CLASS="SMALL">Konstruktor kopiujący</SMALL>
      <BR CLEAR="ALL">
<HR>
<pre><tt> <font SIZE="-2" color="black">     1.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;iostream&gt;</font>
 <font SIZE="-2" color="black">     2.  </font><b><font color="#0000FF">using</font></b> <b><font color="#0000FF">namespace</font></b> std<font color="#990000">;</font>
 <font SIZE="-2" color="black">     3.  </font>
 <font SIZE="-2" color="black">     4.  </font><b><font color="#0000FF">class</font></b> <font color="#008080">A</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">     5.  </font>    <font color="#009900">double</font> x<font color="#990000">;</font>
 <font SIZE="-2" color="black">     6.  </font><b><font color="#0000FF">public</font></b><font color="#990000">:</font>
 <font SIZE="-2" color="black">     7.  </font>    <b><font color="#000000">A</font></b><font color="#990000">(</font><font color="#009900">double</font> x <font color="#990000">=</font> <font color="#993399">1</font><font color="#990000">)</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">     8.  </font>        <b><font color="#0000FF">this</font></b><font color="#990000">-&gt;</font>x <font color="#990000">=</font> x<font color="#990000">;</font>
 <font SIZE="-2" color="black">     9.  </font>        cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"W konstruktorze domyslnym"</font>  <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    10.  </font>    <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    11.  </font>
 <font SIZE="-2" color="black">    12.  </font>    <b><font color="#000000">A</font></b><font color="#990000">(</font><b><font color="#0000FF">const</font></b> A<font color="#990000">&amp;</font> a<font color="#990000">)</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    13.  </font>        x <font color="#990000">=</font> a<font color="#990000">.</font>x<font color="#990000">;</font>
 <font SIZE="-2" color="black">    14.  </font>        cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"W konstruktorze kopiujacym"</font> <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    15.  </font>    <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    16.  </font><font color="#FF0000">}</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    17.  </font>
 <font SIZE="-2" color="black">    18.  </font><font color="#008080">A</font> <b><font color="#000000">fun</font></b><font color="#990000">(</font><font color="#008080">A</font> a<font color="#990000">)</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    19.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"W funkcji fun"</font> <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    20.  </font>    <b><font color="#0000FF">return</font></b> a<font color="#990000">;</font>
 <font SIZE="-2" color="black">    21.  </font><font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    22.  </font>
 <font SIZE="-2" color="black">    23.  </font><font color="#009900">int</font> <b><font color="#000000">main</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    24.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"**1**"</font> <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    25.  </font>    <font color="#008080">A</font> a<font color="#990000">;</font>
 <font SIZE="-2" color="black">    26.  </font>
 <font SIZE="-2" color="black">    27.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"**2**"</font> <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    28.  </font>    <font color="#008080">A</font> b <font color="#990000">=</font> a<font color="#990000">;</font>                   <span class="ding">&#x278A;</span>
 <font SIZE="-2" color="black">    29.  </font>
 <font SIZE="-2" color="black">    30.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"**3**"</font> <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    31.  </font>    <font color="#008080">A</font> <b><font color="#000000">c</font></b><font color="#990000">(</font>b<font color="#990000">);</font>                    <span class="ding">&#x278B;</span>
 <font SIZE="-2" color="black">    32.  </font>
 <font SIZE="-2" color="black">    33.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"**4**"</font> <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>   <span class="ding">&#x278C;</span>
 <font SIZE="-2" color="black">    34.  </font>    c <font color="#990000">=</font> <b><font color="#000000">fun</font></b><font color="#990000">(</font>a<font color="#990000">);</font>                <span class="ding">&#x278D;</span>
 <font SIZE="-2" color="black">    35.  </font><font color="#FF0000">}</font>
</tt></pre>
<hr>

</div>

<P>
Program ten demonstruje przy okazji dwa sposoby tworzenia obiektów,
których jeszcze nie omawialiśmy w
     rozdziale o&nbsp;tworzeniu <A HREF="node93.html#klasy:tworzob">obiektów</A> .
W linii&nbsp;<span class="ding">&#x278A;</span> instrukcja '
<FONT COLOR="#000000"><TT>A b = a;</TT></FONT>' tworzy na stosie (a&nbsp;więc
jako zmienną lokalną) obiekt&nbsp;
<!--O--><span class='zmienna'>b<!--C--></span>
 będący <FONT COLOR="#7b003e"><I>kopią</I></FONT>
wcześniej istniejącego obiektu&nbsp;
<!--O--><span class='zmienna'>a<!--C--></span>. A zatem wywołany będzie
konstruktor kopiujący! Zauważmy, że taki zapis nie ma
nic wspólnego z&nbsp;przypisaniem: przypisywać można tylko do
istniejących obiektów. Jest to prawie to samo co jawnie
robimy w&nbsp;linii&nbsp;<span class="ding">&#x278B;</span> za pomocą nieco różnej składni
('
<FONT COLOR="#000000"><TT>A c(b);</TT></FONT>'). Tu jawnie wywołujemy konstruktor klasy&nbsp;
<!--O--><span class='klasa'>A<!--C--></span>

posyłając istniejący już teraz obiekt&nbsp;
<!--O--><span class='zmienna'>b<!--C--></span>
 jako wzór.
Jest drobna różnica między tymi przypadkami &mdash;&nbsp;za pierwszym razem
wywołanie konstruktora kopiującego jest traktowane jako <FONT COLOR="#7b003e"><I>niejawne</I></FONT>
(ang.&nbsp;<FONT COLOR="#7b003e"><I>implicit</I></FONT>) a&nbsp;w&nbsp;drugim jako <FONT COLOR="#7b003e"><I>jawne</I></FONT> (ang.&nbsp;<FONT COLOR="#7b003e"><I>explicit</I></FONT>).
Jak się przekonamy, konstruktory mogą być zadeklarowane jako tylko jawne
i&nbsp;w&nbsp;takim przypadku pierwsza forma nie zadziałałaby.

<P>
Przyglądając się wydrukowi z&nbsp;tego programu
<PRE>
    **1**
    W konstruktorze domyslnym
    **2**
    W konstruktorze kopiujacym
    **3**
    W konstruktorze kopiujacym
    **4**
    W konstruktorze kopiujacym
    W funkcji fun
    W konstruktorze kopiujacym
</PRE>
zauważamy, że gdy wydrukowany już został napis
'
<FONT COLOR="#000000"><TT>**4**</TT></FONT>',
a&nbsp;więc po wykonaniu instrukcji z&nbsp;linii&nbsp;<span class="ding">&#x278C;</span> programu, konstruktor
kopiujący został jeszcze wywołany dwukrotnie, mimo że,
jak się wydaje, żadnych nowych obiektów już nie kreujemy.
Dlaczego zatem zadziałał? Konstruktor ten został wywołany dwa
razy podczas obsługi wywołania funkcji
<!--O--><span class='funkcja'>fun<!--C--></span>
 w&nbsp;linii&nbsp;<span class="ding">&#x278D;</span>:

<UL>
<LI>aby skopiować argument, czyli obiekt
<!--O--><span class='zmienna'>a<!--C--></span>,&nbsp;w&nbsp;celu
          położenia tej kopii na stosie, gdzie będzie utożsamiona
          z&nbsp;lokalną dla funkcji zmienną&nbsp;
<!--O--><span class='zmienna'>x<!--C--></span>,
</LI>
<LI>po wykonaniu treści funkcji do skopiowania zmiennej
          lokalnej
<!--O--><span class='zmienna'>x<!--C--></span>&nbsp;przed zwróceniem jej wartości jako
          rezultatu funkcji.
</LI>
</UL>
Co by było, gdybyśmy w&nbsp;naszej klasie
<!--O--><span class='klasa'>A<!--C--></span>
 konstruktora
kopiującego nie napisali? Akurat w&nbsp;tym przypadku nic złego by się
<FONT COLOR="#7b003e"><I>nie</I></FONT> stało. Jeśli programista
takiego konstruktora nie napisał, to zostanie on wygenerowany przez
kompilator niezależnie od tego, czy w&nbsp;ogóle jakieś inne konstruktory
dostarczyliśmy, czy nie (a zatem <FONT COLOR="#7b003e"><I>inaczej</I></FONT> niż dla konstruktorów
domyślnych). Wygenerowany automatycznie konstruktor kopiujący jest zawsze
konstruktorem o&nbsp;dostępności typu
<!--O--><span class='klucz'>public<!--C--></span>, tak jak
automatycznie generowany konstruktor domyślny.
Kopiuje on po prostu
składowe obiektu-wzorca do odpowiednich składowych kreowanego
obiektu. W przypadku tak prostej klasy jak klasa
<!--O--><span class='klasa'>A<!--C--></span>
 z&nbsp;naszego
przykładu, będzie to akurat to, o&nbsp;co nam chodzi: obiekt tej klasy
zawiera tylko jedną składową (typu
<!--O--><span class='typ'>double<!--C--></span>). A zatem konstruktor
kopiujący wygenerowany automatycznie wykonałby dokładnie to samo,
co ten napisany przez nas (z&nbsp;wyjątkiem drukowania informacji o&nbsp;swoim
działaniu).

<P>
Z tego, co powiedzieliśmy wynika, że w&nbsp;naszej klasie&nbsp;
<!--O--><span class='klasa'>A<!--C--></span>

konstruktora kopiującego w&nbsp;ogóle nie musieliśmy pisać;
służył w&nbsp;niej jedynie celom dydaktycznym. Jak się
jednak przekonamy, nie zawsze tak jest.

<P>
Wyjaśnijmy jeszcze, dlaczego argument musi być referencją, a&nbsp;nie
obiektem przekazywanym przez wartość.
Gdyby był obiektem, to ponieważ argumenty
przekazywane przez wartość są podczas wywołania kopiowane
i&nbsp;kładzione na stosie, musiałaby najpierw zostać wykonana kopia tego
obiektu. Ale do tego potrzebne byłoby ...wywołanie konstruktora
kopiującego i&nbsp;przesłanie do niego przez wartość argumentu, a&nbsp;do tego
znowu trzeba by wykonać kopię, a&nbsp;więc wywołać konstruktor
kopiujący, i&nbsp;tak dalej, <SPAN  CLASS="textit">ad infinitum</SPAN>. Konstruktor
kopiujący byłby zatem wywoływany rekursywnie w&nbsp;nieskończoność.

<P>
Z drugiej strony, przekazując do konstruktora obiekt-wzorzec przez
referencję, dajemy mu możliwość zmiany tego obiektu-wzorca,
dostaje on bowiem wtedy oryginał obiektu, a&nbsp;nie jego kopię.
Najczęściej taka zmiana byłaby niepożądana. Dlatego właśnie,
aby się przed możliwością takiej zmiany zabezpieczyć,
parametr konstruktora kopiującego deklarujemy z&nbsp;modyfikatorem

<!--O--><span class='klucz'>const<!--C--></span>. Sam kompilator zadba wtedy o&nbsp;to, abyśmy nawet
nieświadomie czy przypadkowo nie zmodyfikowali obiektu-wzorca,
a&nbsp;prócz tego będzie możliwe przekazywanie jako argumentu referencji do
obiektu stałego (<!--O--><span class='klucz'>const<!--C--></span>).

<P>
Wewnątrz konstruktora kopiującego, jak i&nbsp;każdego innego, można
odwoływać się do składowych tworzonego obiektu (które już
istnieją). Można również wywoływać inne metody.

<P>
Jak wspomnieliśmy, automatycznie wygenerowany konstruktor kopiujący
kopiuje obiekt-wzorzec na nowo tworzony obiekt &bdquo;pole po polu&rdquo;.
Znaczy to, że kopiowanie takie jest płytkie: jeśli
istnieją pola wskaźnikowe &mdash;&nbsp;np.&nbsp;dynamicznie
tworzone tablice &mdash;&nbsp;elementem obiektu jest wtedy tylko wskaźnik,
a nie cała tablica, a&nbsp;więc kopiowane są te wskaźniki, a&nbsp;nie obiekty
przez nie wskazywane. W takich przypadkach programista
musi dostarczyć właściwy konstruktor kopiujący zapewniający
kopiowanie głębokie.

<P>
Zobaczmy o&nbsp;co tu chodzi na przykładzie. Rozważmy klasę

<!--O--><span class='klasa'>Osoba<!--C--></span>, której składowymi ma być np.&nbsp;wiek i&nbsp;imię
danej osoby:
<pre><tt>   <b><font color="#0000FF">class</font></b> <font color="#008080">Osoba</font> <font color="#FF0000">{</font>
       <font color="#009900">int</font>   wiek<font color="#990000">;</font>
       <font color="#009900">char</font><font color="#990000">*</font> imie<font color="#990000">;</font>
       <i><font color="#9A1900">// ...</font></i>
   <font color="#FF0000">}</font><font color="#990000">;</font>
</tt></pre>
Pole
<!--O--><span class='zmienna'>wiek<!--C--></span>
 jest typu całkowitego i&nbsp;nie sprawia kłopotu.
Gorzej jest z&nbsp;polem
<!--O--><span class='zmienna'>imie<!--C--></span>, które ma być napisem,
czyli tablicą znaków. Zadeklarowaliśmy je jako typu

<!--O--><span class='typ'>char*<!--C--></span>. Dlaczego? Zastanówmy się, jaki wymiar ma mieć ta
tablica? Tego nie wiemy: jedne imiona są krótkie, inne długie.
Moglibyśmy ustalić maksymalną długość raz na zawsze pisząc
<pre><tt>   <b><font color="#0000FF">class</font></b> <font color="#008080">Osoba</font> <font color="#FF0000">{</font>
       <font color="#009900">int</font>  wiek<font color="#990000">;</font>
       <font color="#009900">char</font> imie<font color="#990000">[</font><font color="#993399">20</font><font color="#990000">];</font>
       <i><font color="#9A1900">// ...</font></i>
   <font color="#FF0000">}</font><font color="#990000">;</font>
</tt></pre>
W każdym obiekcie klasy zawarta wtedy będzie tablica dwudziestu
znaków. Zazwyczaj imiona są znacznie krótsze, więc większość
pamięci przydzielonej w&nbsp;ten sposób na imiona będzie się marnować.
Z&nbsp;drugiej strony, nie możemy za bardzo zmniejszyć tego wymiaru, bo
jednak od czasu do czasu zdarzyć się mogą imiona rzeczywiście
długie. Zatem decydujemy się na inne rozwiązanie: w&nbsp;obiekcie
będziemy przechowywać tylko wskaźnik do tablicy znaków, a&nbsp;zatem
wielkość typu
<!--O--><span class='typ'>char*<!--C--></span>, a&nbsp;samą tablicę będziemy alokować
dynamicznie w&nbsp;konstruktorze dokładnie takiej wielkości,
jaka będzie potrzebna: małą tablicę dla imion krótkich,
większą dla długich. Do konstruktora będziemy zatem przesyłać
tablicę znaków (czyli wskaźnik do istniejącej tablicy znaków
zakończonej znakiem pustym '<!-- MATH
 $\backslash$
 -->
<SPAN CLASS="MATH">&#92;</SPAN>0').

<P>
Dlaczego w&nbsp;ogóle alokować tablicę w&nbsp;konstruktorze? Dlaczego nie
napisać:
<pre><tt>   <b><font color="#0000FF">class</font></b> <font color="#008080">Osoba</font> <font color="#FF0000">{</font>
       <font color="#009900">int</font>   wiek<font color="#990000">;</font>
       <font color="#009900">char</font><font color="#990000">*</font> imie<font color="#990000">;</font>
   <b><font color="#0000FF">public</font></b><font color="#990000">:</font>
       <b><font color="#000000">Osoba</font></b><font color="#990000">(</font><font color="#009900">char</font><font color="#990000">*</font> im<font color="#990000">)</font> <font color="#FF0000">{</font>
           imie <font color="#990000">=</font> im<font color="#990000">;</font>
       <font color="#FF0000">}</font>
       <i><font color="#9A1900">// ...</font></i>
   <font color="#FF0000">}</font><font color="#990000">;</font>
</tt></pre>
Tak zrobić zazwyczaj nie można. Błędu formalnie tu nie ma,
ale zauważmy, że w&nbsp;ten sposób w&nbsp;obiekcie zapamiętaliśmy adres
pewnego napisu utworzonego gdzie indziej. Nie wiemy, czy jest on
modyfikowalny czy nie, nie wiemy co się z&nbsp;tym napisem będzie dalej
działo: może zaraz zostanie zmieniony albo usunięty, a&nbsp;obiekt
zostanie z&nbsp;adresem czegoś, czego już w&nbsp;ogóle nie ma!

<P>
Zatem lepiej zrobimy, jeśli w&nbsp;konstruktorze zaalokujemy odpowiednią
ilość miejsca w&nbsp;pamięci wolnej (na stercie) i&nbsp;tam ten napis
przekopiujemy:
<BR><A NAME="osoba1.cpp"></A>
<BR CLEAR='ALL'>
<div class='kodpro'><HR>
      <SPAN  CLASS="textbf">P<SPAN CLASS="arabic">115</SPAN>:</SPAN>
      <A NAME="tex2html122"
  HREF="source-files/osoba1.cpp">
<!--O--><span class='downl'>osoba1.cpp<!--C--></span></A>
<A NAME="18243"></A>
      &nbsp;&nbsp;&nbsp;&nbsp;<SMALL CLASS="SMALL">Alokowanie pamięci w&nbsp;konstruktorze</SMALL>
      <BR CLEAR="ALL">
<HR>
<pre><tt> <font SIZE="-2" color="black">     1.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;iostream&gt;</font>
 <font SIZE="-2" color="black">     2.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;cstring&gt;</font>
 <font SIZE="-2" color="black">     3.  </font><b><font color="#0000FF">using</font></b> <b><font color="#0000FF">namespace</font></b> std<font color="#990000">;</font>
 <font SIZE="-2" color="black">     4.  </font>
 <font SIZE="-2" color="black">     5.  </font><b><font color="#0000FF">class</font></b> <font color="#008080">Osoba1</font> <font color="#FF0000">{</font> <i><font color="#9A1900">// niezupełnie dobra klasa...</font></i>
 <font SIZE="-2" color="black">     6.  </font><b><font color="#0000FF">public</font></b><font color="#990000">:</font>
 <font SIZE="-2" color="black">     7.  </font>    <font color="#009900">int</font>   wiek<font color="#990000">;</font>
 <font SIZE="-2" color="black">     8.  </font>    <font color="#009900">char</font><font color="#990000">*</font> imie<font color="#990000">;</font>
 <font SIZE="-2" color="black">     9.  </font>    <b><font color="#000000">Osoba1</font></b><font color="#990000">(</font><font color="#009900">int</font> w<font color="#990000">,</font> <b><font color="#0000FF">const</font></b> <font color="#009900">char</font><font color="#990000">*</font> im<font color="#990000">)</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    10.  </font>        wiek <font color="#990000">=</font> w<font color="#990000">;</font>
 <font SIZE="-2" color="black">    11.  </font>        imie <font color="#990000">=</font> <b><font color="#0000FF">new</font></b> <font color="#009900">char</font><font color="#990000">[</font><b><font color="#000000">strlen</font></b><font color="#990000">(</font>im<font color="#990000">)+</font><font color="#993399">1</font><font color="#990000">];</font> <span class="ding">&#x278A;</span>
 <font SIZE="-2" color="black">    12.  </font>        <b><font color="#000000">strcpy</font></b><font color="#990000">(</font>imie<font color="#990000">,</font>im<font color="#990000">);</font>               <span class="ding">&#x278B;</span>
 <font SIZE="-2" color="black">    13.  </font>    <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    14.  </font><font color="#FF0000">}</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    15.  </font>
 <font SIZE="-2" color="black">    16.  </font><font color="#009900">int</font> <b><font color="#000000">main</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    17.  </font>    <font color="#009900">char</font> imie<font color="#990000">[]</font> <font color="#990000">=</font> <font color="#FF0000">"Basia"</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    18.  </font>
 <font SIZE="-2" color="black">    19.  </font>    <font color="#008080">Osoba1</font> <b><font color="#000000">basia</font></b><font color="#990000">(</font><font color="#993399">29</font><font color="#990000">,</font> imie<font color="#990000">);</font>
 <font SIZE="-2" color="black">    20.  </font>
 <font SIZE="-2" color="black">    21.  </font>    imie<font color="#990000">[</font><font color="#993399">0</font><font color="#990000">]</font> <font color="#990000">=</font> <font color="#FF0000">'K'</font><font color="#990000">;</font>                     <span class="ding">&#x278C;</span>
 <font SIZE="-2" color="black">    22.  </font>
 <font SIZE="-2" color="black">    23.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"Oryginal:  "</font> <font color="#990000">&lt;&lt;</font> imie       <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    24.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"Z obiektu: "</font> <font color="#990000">&lt;&lt;</font> basia<font color="#990000">.</font>imie <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    25.  </font><font color="#FF0000">}</font>
</tt></pre>
<hr>

</div>

<P>
Użyliśmy tu funkcji z&nbsp;nagłówka
<!--O--><span class='plik'>cstring<!--C--></span>

<UL>
<LI>
<!--O--><span class='funkcja'>strlen<!--C--></span>
 &mdash;&nbsp;zwraca długość napisu
          wskazywanego przez argument typu
<!--O--><span class='typ'>char*<!--C--></span>, nie
          licząc kończącego znaku '<!-- MATH
 $\backslash$
 -->
<SPAN CLASS="MATH">&#92;</SPAN>0';
</LI>
<LI>
<!--O--><span class='funkcja'>strcpy<!--C--></span>
 &mdash;&nbsp;kopiuje napis wskazywany przez
          drugi argument do napisu wskazywanego przez pierwszy
          argument, lącznie z&nbsp;kończącym znakiem '<!-- MATH
 $\backslash$
 -->
<SPAN CLASS="MATH">&#92;</SPAN>0'.
          Zwraca wskaźnik będący pierwszym argumentem.
</LI>
</UL>
Zauważmy, że w&nbsp;konstruktorze przydzieliliśmy sobie (linia&nbsp;<span class="ding">&#x278A;</span>)
o&nbsp;jeden bajt więcej niż wynosi długość napisu przesłanego do
tego konstruktora; jest to konieczne, gdyż przekopiować trzeba cały napis,
łącznie ze znakiem '<!-- MATH
 $\backslash$
 -->
<SPAN CLASS="MATH">&#92;</SPAN>0' (co robimy w&nbsp;linii&nbsp;<span class="ding">&#x278B;</span>). Program drukuje
<PRE>
    Oryginal:  Kasia
    Z obiektu: Basia
</PRE>
co przekonuje nas, że obiekt zawiera adres swojej &bdquo;prywatnej&rdquo; kopii
napisu przesłanego do konstruktora. Oryginał tego napisu
zmieniliśmy w&nbsp;linii&nbsp;<span class="ding">&#x278C;</span> z&nbsp;<TT>Basia</TT> na <TT>Kasia</TT>, ale
składowa
<!--O--><span class='zmienna'>imie<!--C--></span>
 obiektu wskazuje na tę &bdquo;prywatną&rdquo; kopię,
która zmianie nie uległa.

<P>
Mamy tu zatem do czynienia z&nbsp;sytuacją, gdy obiekt fizycznie nie zawiera
pełnej informacji o&nbsp;reprezentowanej przez siebie osobie (w tym
przypadku nie zawiera imienia tej osoby), a&nbsp;tylko adres
obszaru pamięci na stercie, gdzie ta informacja została zapisana.
W&nbsp;ten sposób sam obiekt jest niewielki: zawiera tylko liczbę
całkowitą (składowa
<!--O--><span class='zmienna'>wiek<!--C--></span>) i&nbsp;wskaźnik typu
<!--O--><span class='typ'>char*<!--C--></span>

(składowa
<!--O--><span class='zmienna'>imie<!--C--></span>). Związana z&nbsp;nim informacja (tablica znaków
zawierająca imię) jest zaalokowana poza obiektem, na stercie i&nbsp;zajmuje
tylko tyle miejsca, ile jest to niezbędne.

<P>
Co teraz będzie, jeśli zechcemy użyć konstruktora kopiującego
wygenerowanego przez system?
<BR><A NAME="osoba2.cpp"></A>
<BR CLEAR='ALL'>
<div class='kodpro'><HR>
      <SPAN  CLASS="textbf">P<SPAN CLASS="arabic">116</SPAN>:</SPAN>
      <A NAME="tex2html123"
  HREF="source-files/osoba2.cpp">
<!--O--><span class='downl'>osoba2.cpp<!--C--></span></A>
<A NAME="18260"></A>
      &nbsp;&nbsp;&nbsp;&nbsp;<SMALL CLASS="SMALL">Pola wskaźnikowe i&nbsp;automatyczny
                     konstruktor kopiujący</SMALL>
      <BR CLEAR="ALL">
<HR>
<pre><tt> <font SIZE="-2" color="black">     1.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;iostream&gt;</font>
 <font SIZE="-2" color="black">     2.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;cstring&gt;</font>
 <font SIZE="-2" color="black">     3.  </font><b><font color="#0000FF">using</font></b> <b><font color="#0000FF">namespace</font></b> std<font color="#990000">;</font>
 <font SIZE="-2" color="black">     4.  </font>
 <font SIZE="-2" color="black">     5.  </font><b><font color="#0000FF">class</font></b> <font color="#008080">Osoba2</font> <font color="#FF0000">{</font> <i><font color="#9A1900">// niezupełnie dobra klasa...</font></i>
 <font SIZE="-2" color="black">     6.  </font><b><font color="#0000FF">public</font></b><font color="#990000">:</font>
 <font SIZE="-2" color="black">     7.  </font>    <font color="#009900">int</font>   wiek<font color="#990000">;</font>
 <font SIZE="-2" color="black">     8.  </font>    <font color="#009900">char</font><font color="#990000">*</font> imie<font color="#990000">;</font>
 <font SIZE="-2" color="black">     9.  </font>    <b><font color="#000000">Osoba2</font></b><font color="#990000">(</font><font color="#009900">int</font> w<font color="#990000">,</font> <b><font color="#0000FF">const</font></b> <font color="#009900">char</font><font color="#990000">*</font> im<font color="#990000">)</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    10.  </font>        wiek <font color="#990000">=</font> w<font color="#990000">;</font>
 <font SIZE="-2" color="black">    11.  </font>        imie <font color="#990000">=</font> <b><font color="#0000FF">new</font></b> <font color="#009900">char</font><font color="#990000">[</font><b><font color="#000000">strlen</font></b><font color="#990000">(</font>im<font color="#990000">)+</font><font color="#993399">1</font><font color="#990000">];</font>
 <font SIZE="-2" color="black">    12.  </font>        <b><font color="#000000">strcpy</font></b><font color="#990000">(</font>imie<font color="#990000">,</font>im<font color="#990000">);</font>
 <font SIZE="-2" color="black">    13.  </font>    <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    14.  </font><font color="#FF0000">}</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    15.  </font>
 <font SIZE="-2" color="black">    16.  </font><font color="#009900">int</font> <b><font color="#000000">main</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    17.  </font>    <font color="#009900">char</font> imie<font color="#990000">[]</font> <font color="#990000">=</font> <font color="#FF0000">"Basia"</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    18.  </font>
 <font SIZE="-2" color="black">    19.  </font>    <font color="#008080">Osoba2</font> <b><font color="#000000">basia</font></b><font color="#990000">(</font><font color="#993399">29</font><font color="#990000">,</font> imie<font color="#990000">);</font>
 <font SIZE="-2" color="black">    20.  </font>    <font color="#008080">Osoba2</font> <b><font color="#000000">kasia</font></b><font color="#990000">(</font>basia<font color="#990000">);</font>      <i><font color="#9A1900">// użycie konstr. kopiującego</font></i>
 <font SIZE="-2" color="black">    21.  </font>
 <font SIZE="-2" color="black">    22.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"Po utworzeniu:   basia "</font> <font color="#990000">&lt;&lt;</font> basia<font color="#990000">.</font>imie <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    23.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"                 kasia "</font> <font color="#990000">&lt;&lt;</font> kasia<font color="#990000">.</font>imie <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    24.  </font>
 <font SIZE="-2" color="black">    25.  </font>    kasia<font color="#990000">.</font>imie<font color="#990000">[</font><font color="#993399">0</font><font color="#990000">]</font> <font color="#990000">=</font> <font color="#FF0000">'K'</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    26.  </font>
 <font SIZE="-2" color="black">    27.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"Po zmianie Kasi: basia "</font> <font color="#990000">&lt;&lt;</font> basia<font color="#990000">.</font>imie <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    28.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"                 kasia "</font> <font color="#990000">&lt;&lt;</font> kasia<font color="#990000">.</font>imie <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    29.  </font><font color="#FF0000">}</font>
</tt></pre>
<hr>

</div>

<P>
Na początku tworzymy obiekt
<!--O--><span class='zmienna'>basia<!--C--></span>
 o&nbsp;imieniu 'Basia'.
W&nbsp;linii następnej tworzymy, poprzez konstruktor kopiujący,
obiekt
<!--O--><span class='zmienna'>kasia<!--C--></span>. W obu obiektach imię jest 'Basia',
o&nbsp;czym świadczą dwie pierwsze linie wydruku:
<PRE>
    Po utworzeniu:   basia Basia
                     kasia Basia
    Po zmianie Kasi: basia Kasia
                     kasia Kasia
</PRE>
Następnie (linia&nbsp;25) zmieniamy imię w&nbsp;obiekcie
<!--O--><span class='zmienna'>kasia<!--C--></span>

na Kasia. Jak widać z&nbsp;wydruku, spowodowało to również zmianę
imienia Basi! Oczywiście, wiemy dlaczego tak się stało.
Konstruktor kopiujący, tworząc obiekt
<!--O--><span class='zmienna'>kasia<!--C--></span>, przekopiował
składową wskaźnikową
<!--O--><span class='zmienna'>imie<!--C--></span>, zawierającą adres, a&nbsp;nie sam
napis, tak więc po utworzeniu obiektu
<!--O--><span class='zmienna'>kasia<!--C--></span>
 w&nbsp;obu obiektach
składowa ta ma tę samą wartość: adres napisu zaalokowanego przez
zwykły konstruktor podczas tworzenia obiektu
<!--O--><span class='zmienna'>basia<!--C--></span>. Obiekty
są dwa, ale napis z&nbsp;imieniem jest tylko jeden, wskazywany przez
składowe wskaźnikowe
<!--O--><span class='zmienna'>imie<!--C--></span>
 obu obiektów.

<P>
Tak oczywiście być nie powinno i&nbsp;to właśnie jest sytuacja, gdy
automatyczny konstruktor kopiujący nie wykonuje tego, o&nbsp;co nam chodzi.
Zatem sami musimy zadbać o&nbsp;to, by podczas tworzenia obiektu za pomocą
konstruktora kopiującego każdy tworzony obiekt zaopatrzyć we własną
kopię imienia:
<BR><A NAME="osoba3.cpp"></A>
<BR CLEAR='ALL'>
<div class='kodpro'><HR>
      <SPAN  CLASS="textbf">P<SPAN CLASS="arabic">117</SPAN>:</SPAN>
      <A NAME="tex2html124"
  HREF="source-files/osoba3.cpp">
<!--O--><span class='downl'>osoba3.cpp<!--C--></span></A>
<A NAME="18268"></A>
      &nbsp;&nbsp;&nbsp;&nbsp;<SMALL CLASS="SMALL">Własny konstruktor kopiujący</SMALL>
      <BR CLEAR="ALL">
<HR>
<pre><tt> <font SIZE="-2" color="black">     1.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;iostream&gt;</font>
 <font SIZE="-2" color="black">     2.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;cstring&gt;</font>
 <font SIZE="-2" color="black">     3.  </font><b><font color="#0000FF">using</font></b> <b><font color="#0000FF">namespace</font></b> std<font color="#990000">;</font>
 <font SIZE="-2" color="black">     4.  </font>
 <font SIZE="-2" color="black">     5.  </font><b><font color="#0000FF">class</font></b> <font color="#008080">Osoba</font> <font color="#FF0000">{</font>   <i><font color="#9A1900">// trochę lepsza klasa</font></i>
 <font SIZE="-2" color="black">     6.  </font><b><font color="#0000FF">public</font></b><font color="#990000">:</font>
 <font SIZE="-2" color="black">     7.  </font>    <font color="#009900">int</font>   wiek<font color="#990000">;</font>
 <font SIZE="-2" color="black">     8.  </font>    <font color="#009900">char</font><font color="#990000">*</font> imie<font color="#990000">;</font>
 <font SIZE="-2" color="black">     9.  </font>    <b><font color="#000000">Osoba</font></b><font color="#990000">(</font><font color="#009900">int</font> w<font color="#990000">,</font> <b><font color="#0000FF">const</font></b> <font color="#009900">char</font><font color="#990000">*</font> im<font color="#990000">)</font> <font color="#FF0000">{</font> <i><font color="#9A1900">// zwykły konstruktor</font></i>
 <font SIZE="-2" color="black">    10.  </font>        wiek <font color="#990000">=</font> w<font color="#990000">;</font>
 <font SIZE="-2" color="black">    11.  </font>        imie <font color="#990000">=</font> <b><font color="#0000FF">new</font></b> <font color="#009900">char</font><font color="#990000">[</font><b><font color="#000000">strlen</font></b><font color="#990000">(</font>im<font color="#990000">)+</font><font color="#993399">1</font><font color="#990000">];</font>
 <font SIZE="-2" color="black">    12.  </font>        <b><font color="#000000">strcpy</font></b><font color="#990000">(</font>imie<font color="#990000">,</font>im<font color="#990000">);</font>
 <font SIZE="-2" color="black">    13.  </font>    <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    14.  </font>    <b><font color="#000000">Osoba</font></b><font color="#990000">(</font><b><font color="#0000FF">const</font></b> Osoba<font color="#990000">&amp;</font> os<font color="#990000">)</font> <font color="#FF0000">{</font>      <i><font color="#9A1900">// konstruktor kopiujący</font></i>
 <font SIZE="-2" color="black">    15.  </font>        wiek <font color="#990000">=</font> os<font color="#990000">.</font>wiek<font color="#990000">;</font>
 <font SIZE="-2" color="black">    16.  </font>        imie <font color="#990000">=</font> <b><font color="#0000FF">new</font></b> <font color="#009900">char</font><font color="#990000">[</font><b><font color="#000000">strlen</font></b><font color="#990000">(</font>os<font color="#990000">.</font>imie<font color="#990000">)+</font><font color="#993399">1</font><font color="#990000">];</font>
 <font SIZE="-2" color="black">    17.  </font>        <b><font color="#000000">strcpy</font></b><font color="#990000">(</font>imie<font color="#990000">,</font>os<font color="#990000">.</font>imie<font color="#990000">);</font>
 <font SIZE="-2" color="black">    18.  </font>    <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    19.  </font>    <font color="#990000">~</font><b><font color="#000000">Osoba</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>                    <i><font color="#9A1900">// destruktor</font></i>
 <font SIZE="-2" color="black">    20.  </font>        <b><font color="#0000FF">delete</font></b> <font color="#990000">[]</font> imie<font color="#990000">;</font>
 <font SIZE="-2" color="black">    21.  </font>    <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    22.  </font><font color="#FF0000">}</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    23.  </font>
 <font SIZE="-2" color="black">    24.  </font><font color="#009900">int</font> <b><font color="#000000">main</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    25.  </font>    <font color="#009900">char</font> imie<font color="#990000">[]</font> <font color="#990000">=</font> <font color="#FF0000">"Basia"</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    26.  </font>
 <font SIZE="-2" color="black">    27.  </font>    <font color="#008080">Osoba</font> <b><font color="#000000">basia</font></b><font color="#990000">(</font><font color="#993399">29</font><font color="#990000">,</font> imie<font color="#990000">);</font>
 <font SIZE="-2" color="black">    28.  </font>    <font color="#008080">Osoba</font> <b><font color="#000000">kasia</font></b><font color="#990000">(</font>basia<font color="#990000">);</font>
 <font SIZE="-2" color="black">    29.  </font>
 <font SIZE="-2" color="black">    30.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"Po utworzeniu:   basia "</font> <font color="#990000">&lt;&lt;</font> basia<font color="#990000">.</font>imie <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    31.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"                 kasia "</font> <font color="#990000">&lt;&lt;</font> kasia<font color="#990000">.</font>imie <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    32.  </font>
 <font SIZE="-2" color="black">    33.  </font>    kasia<font color="#990000">.</font>imie<font color="#990000">[</font><font color="#993399">0</font><font color="#990000">]</font> <font color="#990000">=</font> <font color="#FF0000">'K'</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    34.  </font>
 <font SIZE="-2" color="black">    35.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"Po zmianie Kasi: basia "</font> <font color="#990000">&lt;&lt;</font> basia<font color="#990000">.</font>imie <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    36.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"                 kasia "</font> <font color="#990000">&lt;&lt;</font> kasia<font color="#990000">.</font>imie <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    37.  </font><font color="#FF0000">}</font>
</tt></pre>
<hr>

</div>

<P>
W tym programie definiujemy &bdquo;normalny&rdquo; konstruktor, ale również
konstruktor kopiujący, który kopiuje pole
<!--O--><span class='zmienna'>wiek<!--C--></span>, mierzy długość
imienia w&nbsp;obiekcie-wzorcu i&nbsp;przydziela odpowiednią ilość miejsca na
stercie, po czym kopiuje napis z&nbsp;imieniem wskazywany przez
składową
<!--O--><span class='zmienna'>imie<!--C--></span>
 obiektu-wzorca do zaalokowanej pamięci.
Wydruk
<PRE>
    Po utworzeniu:   basia Basia
                     kasia Basia
    Po zmianie Kasi: basia Basia
                     kasia Kasia
</PRE>
wskazuje, że tym razem napisy wskazywane przez składowe

<!--O--><span class='zmienna'>imie<!--C--></span>
 obu obiektów są inne: zmiana jednego z&nbsp;nich
nie wpłynęła na drugi.

<P>
Dodaliśmy też do naszej klasy destruktor. W&nbsp;tej klasie jest on potrzebny.
Tworząc obiekt, niezależnie od tego, który konstruktor został użyty,
zaalokowaliśmy pewien obszar pamięci na stercie za pomocą operatora

<!--O--><span class='klucz'>new<!--C--></span>. Nawet gdy obiekt jest lokalny (na stosie) i&nbsp;zostanie usunięty
po wyjściu sterowania z&nbsp;bloku, w&nbsp;którym był zdefiniowany, pamięć,
która do niego &bdquo;należała&rdquo; na stercie <FONT COLOR="#7b003e"><I>nie</I></FONT> zostanie zwolniona.
Ponieważ jednak wiemy, że gdy obiekt będzie usuwany, wywołany
będzie automatycznie na jego rzecz destruktor, właśnie w&nbsp;nim
umieszczamy kod zwalniający tę pamięć.

<P>
Tak skonstruowana klasa wciąż nie jest jeszcze prawidłowa.
Jak się przekonamy, brakuje tu przeciążenia operatora przypisania
(patrz rozdział o <A HREF="node114.html#chap:przec">przeciążeniach</A> ).

<P>

<H2><A NAME="SECTION001632000000000000000"></A><A NAME="klasyd:listin"></A>
<BR>
<SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Listy inicjalizacyjne
</H2>

<P>
Jak podkreślaliśmy, w momencie, gdy zaczyna działać konstruktor, obiekt
już istnieje. W szczególności istnieją wszystkie jego składowe &mdash;&nbsp;
konstruktor może tylko zmienić ich wartość poprzez przypisania.

<P>
Pojawia się tu problem. Jak na przykład zainicjować składową
odpowiadającą polu stałemu (z modyfikatorem
<!--O--><span class='klucz'>const<!--C--></span>) albo
referencyjnemu? W obu przypadkach składnia wymaga zainicjowania
już w&nbsp;trakcie tworzenia, zatem nie można tego zrobić w&nbsp;konstruktorze
&mdash;&nbsp;wtedy składowa już powinna istnieć! Co zrobić, gdy składową
jest obiekt klasy, która nie ma konstruktora domyślnego?

<P>
We wszystkich tych przypadkach kompilacja nie uda się, jeśli sprawę
inicjowania takich składowych pozostawimy dla konstruktora: wtedy
jest już za późno.

<P>
Jednym ze sposobów zdefiniowania stałej jako składowej klasy
jest użycie wyliczenia, które może być wtedy anonimowe:
<pre><tt>   <b><font color="#0000FF">class</font></b> <font color="#008080">A</font> <font color="#FF0000">{</font>
       <b><font color="#0000FF">enum</font></b> <font color="#FF0000">{</font> dim <font color="#990000">=</font> <font color="#993399">10</font> <font color="#FF0000">}</font><font color="#990000">;</font>
       <font color="#009900">int</font> tab<font color="#990000">[</font>dim<font color="#990000">];</font>
   <b><font color="#0000FF">public</font></b><font color="#990000">:</font>
       <font color="#990000">...</font>
       <font color="#009900">void</font> <b><font color="#000000">fun</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
           <font color="#990000">...</font>
           <b><font color="#0000FF">for</font></b> <font color="#990000">(</font><font color="#009900">int</font> i <font color="#990000">=</font> <font color="#993399">0</font><font color="#990000">;</font> i <font color="#990000">&lt;</font> dim<font color="#990000">;</font> <font color="#990000">++</font>i<font color="#990000">)</font> <font color="#FF0000">{</font> <font color="#990000">...</font> <font color="#FF0000">}</font>
           <font color="#990000">...</font>
       <font color="#FF0000">}</font>
   <font color="#FF0000">}</font><font color="#990000">;</font>
</tt></pre>
Stała taka jednak musi mieć nadaną wartość bezpośrednio w&nbsp;kodzie
programu i&nbsp;będzie taka sama dla wszystkich obiektów.
W&nbsp;innych przypadkach inicjalizacja tego rodzaju składowych może
odbywać się tylko na podstawie <FONT COLOR="#7b003e"><B>listy inicjalizacyjnej</B></FONT>
<A NAME="17811"></A>
konstruktora (ang.&nbsp;<FONT COLOR="#7b003e"><I>initialization list</I></FONT>).

<P>
Lista inicjalizacyjna to lista oddzielonych przecinkami identyfikatorów
pól (składowych) z&nbsp;podanymi w&nbsp;nawiasach okrągłych argumentami
dla konstruktorów obiektów będących składowymi tworzonego
obiektu.
Zwykle są to jednocześnie argumenty formalne definiowanego
konstruktora, choć nie musi tak być.
Jeśli argumentem przesyłanym do konstruktora obiektu składowego
na liście inicjalizacyjnej
jest obiekt tego samego typu, co ta składowa, to traktowane to będzie
jako wywołanie konstruktora kopiującego. Taka składnia działa
również dla składowych, które są typu wbudowanego &mdash;&nbsp;jak
wielokrotnie podkreślaliśmy, twórcy języka starali się, aby
reguły składniowe dla typów obiektowych i&nbsp;wbudowanych były do siebie
tak podobne, jak to tylko możliwe.

<P>
Listę inicjalizacyjną, poprzedzoną dwukropkiem, umieszcza
się bezpośrednio po nawiasie zamykającym listę parametrów
konstruktora, a&nbsp;przed nawiasem klamrowym otwierającym <FONT COLOR="#7b003e"><I>definicję</I></FONT>
tego konstruktora.

<P>

<P>

<div class='wazne'>
Jeśli w&nbsp;klasie tylko deklarujemy konstruktor,
    a&nbsp;jego definicję podajemy poza klasą, to w&nbsp;deklaracji listy
    inicjalizacyjnej <FONT COLOR="#7b003e"><I>nie</I></FONT> umieszczamy.


</div>

<P>
To jest logiczne: lista inicjalizacyjna należy logicznie do
implementacji, a&nbsp;nie do interfejsu (kontraktu).
Jak pamiętamy, odwrotnie było z&nbsp;argumentami domniemanymi
(domyślnymi) &mdash;&nbsp;nie tylko konstruktorów, ale
w&nbsp;ogóle funkcji; jeśli deklaracja występuje, to
argumenty domniemane muszą być zdefiniowane właśnie w&nbsp;deklaracji,
ale nie w&nbsp;definicji, bowiem ich wartość, i&nbsp;sama ich obecność,
należy jak najbardziej do kontraktu z&nbsp;użytkownikiem (interfejsu).

<P>
Niezależnie od kolejności na liście inicjalizacyjnej,

<P>

<div class='wazne'>
składowe obiektu są inicjowane <FONT COLOR="#7b003e"><I>zawsze</I></FONT> w&nbsp;kolejności
    ich deklaracji w&nbsp;ciele klasy.


</div>

<P>
Niektóre kompilatory wysyłają ostrzeżenia, jeśli
kolejność deklaracji w&nbsp;definicji klasy i&nbsp;kolejność na liście
inicjalizacyjnej nie są zgodne.

<P>
Na liście inicjalizacyjnej <FONT COLOR="#7b003e"><I>nie</I></FONT> musimy wymieniać wszystkich
składowych klasy. Te składowe, które nie zostały wymienione
na liście, zainicjowane będą (przed rozpoczęciem wykonania
ciała konstruktora!) przez:

<UL>
<LI>użycie konstruktorów domyślnych dla składowych obiektowych.
          Takie konstruktory muszą zatem istnieć;
</LI>
<LI>standardową inicjalizację dla składowych typów wbudowanych.
          Polega ona zwykle na tym, że żadna szczególna wartość w&nbsp;ogóle
          nie jest do zmiennej wpisywana, zatem zmienna ta, z&nbsp;naszego
          punktu widzenia, ma przypadkowy układ bitów.
</LI>
</UL>

<P>
Rozpatrzmy przykład: załóżmy, że mamy klasę&nbsp;
<!--O--><span class='klasa'>A<!--C--></span>
 ze
zdefiniowanym jednym konstruktorem, który jednak nie może pełnić
roli konstruktora domyślnego, bo zawsze wymaga argumentów. Drugi
konstruktor dostarczy wtedy kompilator: będzie to konstruktor
kopiujący.
<pre><tt>       <b><font color="#0000FF">class</font></b> <font color="#008080">A</font> <font color="#FF0000">{</font>
           <i><font color="#9A1900">//...</font></i>
           <b><font color="#000000">A</font></b><font color="#990000">(</font><font color="#009900">int</font> x<font color="#990000">,</font> <font color="#009900">int</font> y<font color="#990000">)</font> <font color="#FF0000">{</font> <font color="#990000">...</font> <font color="#FF0000">}</font>
           <i><font color="#9A1900">//...</font></i>
       <font color="#FF0000">}</font><font color="#990000">;</font>
</tt></pre>
Załóżmy dalej, że obiekty klasy&nbsp;
<!--O--><span class='klasa'>A<!--C--></span>
 są składowymi
klasy&nbsp;
<!--O--><span class='klasa'>B<!--C--></span>. Ponieważ obiekty te muszą istnieć przed
rozpoczęciem konstruktora, a&nbsp;do ich utworzenia potrzebne
są argumenty, ich inicjalizacja <FONT COLOR="#7b003e"><I>musi</I></FONT> nastąpić poprzez
listę inicjalizacyjną:
<pre><tt> <font SIZE="-2" color="black">     1.  </font>    <b><font color="#0000FF">class</font></b> <font color="#008080">B</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">     2.  </font>        <font color="#008080">A</font> pole1<font color="#990000">,</font> pole2<font color="#990000">;</font>
 <font SIZE="-2" color="black">     3.  </font>        <i><font color="#9A1900">//...</font></i>
 <font SIZE="-2" color="black">     4.  </font>        <b><font color="#000000">B</font></b><font color="#990000">(</font><font color="#008080">A</font> a<font color="#990000">,</font> <font color="#009900">int</font> x<font color="#990000">,</font> <font color="#009900">int</font> y<font color="#990000">)</font>
 <font SIZE="-2" color="black">     5.  </font>            <font color="#990000">:</font> <b><font color="#000000">pole1</font></b><font color="#990000">(</font>a<font color="#990000">),</font> <b><font color="#000000">pole2</font></b><font color="#990000">(</font>x<font color="#990000">,</font>y<font color="#990000">)</font>
 <font SIZE="-2" color="black">     6.  </font>        <font color="#FF0000">{</font>  <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">     7.  </font>        <i><font color="#9A1900">//  ...</font></i>
 <font SIZE="-2" color="black">     8.  </font>    <font color="#FF0000">}</font><font color="#990000">;</font>
</tt></pre>
Konstruktor
<!--O--><span class='klasa'>B<!--C--></span>
 jest zdefiniowany w&nbsp;liniach&nbsp;4-6 &mdash;&nbsp;jego
ciało jest puste, bo wszystko co jest do zrobienia jest robione
poprzez listę inicjalizacyjną.
Składowa
<!--O--><span class='zmienna'>pole1<!--C--></span>
 będzie zainicjowana za pomocą
konstruktora kopiującego klasy
<!--O--><span class='klasa'>A<!--C--></span>, bo argumentem jest obiekt
tej klasy, natomiast składowa
<!--O--><span class='zmienna'>pole2<!--C--></span>
 za pomocą konstruktora
dwuargumentowego, zdefiniowanego w&nbsp;klasie
<!--O--><span class='klasa'>A<!--C--></span>. Konstruktora
kopiującego, co prawda, nie zdefiniowaliśmy, ale dostarczy go
system.

<P>
Podobna sytuacja zajdzie, gdy pole klasy jest zadeklarowane jako stałe.
Stałe muszą być inicjowane już w&nbsp;momencie tworzenia, a&nbsp;zatem
nadawanie im wartości dopiero w&nbsp;konstruktorze nie wchodzi w&nbsp;rachubę.
Trzeba to zrobić już na liście inicjalizacyjnej. To samo dotyczy
pól odnośnikowych (referencyjnych); jak pamiętamy,
            patrz rozdział o <A HREF="node21.html#typydan:odnosniki">referencjach</A> ,
referencje, jak stałe, muszą być inicjowane już w&nbsp;momencie
tworzenia.

<P>
Pola stałe stosuje się rzadko. Zazwyczaj wystarczy mechanizm
ochrony danych poprzez umieszczenie składowej w&nbsp;sekcji prywatnej
klasy. Również pola referencyjne nie występują często:
składowa referencyjna jest inną nazwą czegoś spoza klasy, co stwarza
niepotrzebną zwykle więź między obiektem a&nbsp;danymi spoza obiektu.
Natomiast pola obiektowe, jak w&nbsp;powyższym przykładzie, występują
często i&nbsp;w takich przypadkach stosowanie listy inicjalizacyjnej może
być konieczne.

<P>

<P>
<BR>

<P>
W poniższym przykładzie klasa
<!--O--><span class='klasa'>Punkt<!--C--></span>
 nie ma konstruktora
domyślnego. Istnieje tylko konstruktor zdefiniowany przez nas,
pobierający dwie liczby typu
<!--O--><span class='typ'>double<!--C--></span>, oraz dostarczony przez
system konstruktor kopiujący, który w&nbsp;tym przypadku jest odpowiedni
i&nbsp;nie wymaga przedefiniowywania, gdyż klasa nie ma pól wskaźnikowych.
Również destruktor nie jest potrzebny, gdyż z&nbsp;obiektem nie są
związane żadne dane alokowane na stercie.
<BR><A NAME="trian.cpp"></A>
<BR CLEAR='ALL'>
<div class='kodpro'><HR>
      <SPAN  CLASS="textbf">P<SPAN CLASS="arabic">118</SPAN>:</SPAN>
      <A NAME="tex2html125"
  HREF="source-files/trian.cpp">
<!--O--><span class='downl'>trian.cpp<!--C--></span></A>
<A NAME="18319"></A>
      &nbsp;&nbsp;&nbsp;&nbsp;<SMALL CLASS="SMALL">Lista inicjalizacyjna</SMALL>
      <BR CLEAR="ALL">
<HR>
<pre><tt> <font SIZE="-2" color="black">     1.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;iostream&gt;</font>
 <font SIZE="-2" color="black">     2.  </font><b><font color="#0000FF">using</font></b> <b><font color="#0000FF">namespace</font></b> std<font color="#990000">;</font>
 <font SIZE="-2" color="black">     3.  </font>
 <font SIZE="-2" color="black">     4.  </font><b><font color="#0000FF">struct</font></b> <font color="#008080">Punkt</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">     5.  </font>    <font color="#009900">double</font> x<font color="#990000">,</font> y<font color="#990000">;</font>
 <font SIZE="-2" color="black">     6.  </font>
 <font SIZE="-2" color="black">     7.  </font>    <b><font color="#000000">Punkt</font></b><font color="#990000">(</font><font color="#009900">double</font> x<font color="#990000">,</font> <font color="#009900">double</font> y<font color="#990000">)</font>
 <font SIZE="-2" color="black">     8.  </font>        <font color="#990000">:</font> <b><font color="#000000">x</font></b><font color="#990000">(</font>x<font color="#990000">),</font> <b><font color="#000000">y</font></b><font color="#990000">(</font>y<font color="#990000">)</font>
 <font SIZE="-2" color="black">     9.  </font>    <font color="#FF0000">{</font> <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    10.  </font>
 <font SIZE="-2" color="black">    11.  </font>    <font color="#009900">void</font> <b><font color="#000000">show</font></b><font color="#990000">()</font> <b><font color="#0000FF">const</font></b> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    12.  </font>        cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"("</font> <font color="#990000">&lt;&lt;</font>  x <font color="#990000">&lt;&lt;</font> <font color="#FF0000">","</font> <font color="#990000">&lt;&lt;</font> y <font color="#990000">&lt;&lt;</font> <font color="#FF0000">")"</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    13.  </font>    <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    14.  </font><font color="#FF0000">}</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    15.  </font>
 <font SIZE="-2" color="black">    16.  </font><b><font color="#0000FF">struct</font></b> <font color="#008080">Trojkat</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    17.  </font>    <font color="#008080">Punkt</font> a<font color="#990000">,</font> b<font color="#990000">,</font> c<font color="#990000">;</font>
 <font SIZE="-2" color="black">    18.  </font>
 <font SIZE="-2" color="black">    19.  </font>    <b><font color="#000000">Trojkat</font></b><font color="#990000">(</font><b><font color="#0000FF">const</font></b> Punkt<font color="#990000">&amp;,</font><b><font color="#0000FF">const</font></b> Punkt<font color="#990000">&amp;,</font><b><font color="#0000FF">const</font></b> Punkt<font color="#990000">&amp;);</font>   <span class="ding">&#x278A;</span>
 <font SIZE="-2" color="black">    20.  </font>    <b><font color="#000000">Trojkat</font></b><font color="#990000">(</font><font color="#009900">double</font><font color="#990000">,</font><font color="#009900">double</font><font color="#990000">,</font><font color="#009900">double</font><font color="#990000">,</font><font color="#009900">double</font><font color="#990000">,</font><font color="#009900">double</font><font color="#990000">,</font><font color="#009900">double</font><font color="#990000">);</font><span class="ding">&#x278B;</span>
 <font SIZE="-2" color="black">    21.  </font>
 <font SIZE="-2" color="black">    22.  </font>    <font color="#009900">void</font> <b><font color="#000000">show</font></b><font color="#990000">()</font> <b><font color="#0000FF">const</font></b> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    23.  </font>        cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"Trojkat "</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    24.  </font>        a<font color="#990000">.</font><b><font color="#000000">show</font></b><font color="#990000">();</font> cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"-"</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    25.  </font>        b<font color="#990000">.</font><b><font color="#000000">show</font></b><font color="#990000">();</font> cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"-"</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    26.  </font>        c<font color="#990000">.</font><b><font color="#000000">show</font></b><font color="#990000">();</font> cout <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    27.  </font>    <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    28.  </font><font color="#FF0000">}</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    29.  </font>
 <font SIZE="-2" color="black">    30.  </font>Trojkat<font color="#990000">::</font><b><font color="#000000">Trojkat</font></b><font color="#990000">(</font><b><font color="#0000FF">const</font></b> <font color="#008080">Punkt</font> <font color="#990000">&amp;</font>a<font color="#990000">,</font> <b><font color="#0000FF">const</font></b> <font color="#008080">Punkt</font> <font color="#990000">&amp;</font>b<font color="#990000">,</font>
 <font SIZE="-2" color="black">    31.  </font>                                 <b><font color="#0000FF">const</font></b> <font color="#008080">Punkt</font> <font color="#990000">&amp;</font>c<font color="#990000">)</font>
 <font SIZE="-2" color="black">    32.  </font>    <font color="#990000">:</font> <b><font color="#000000">a</font></b><font color="#990000">(</font>a<font color="#990000">),</font> <b><font color="#000000">b</font></b><font color="#990000">(</font>b<font color="#990000">),</font> <b><font color="#000000">c</font></b><font color="#990000">(</font>c<font color="#990000">)</font>                                 <span class="ding">&#x278C;</span>
 <font SIZE="-2" color="black">    33.  </font><font color="#FF0000">{</font> <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    34.  </font>
 <font SIZE="-2" color="black">    35.  </font>Trojkat<font color="#990000">::</font><b><font color="#000000">Trojkat</font></b><font color="#990000">(</font><font color="#009900">double</font> x1<font color="#990000">,</font> <font color="#009900">double</font> y1<font color="#990000">,</font> <font color="#009900">double</font> x2<font color="#990000">,</font>
 <font SIZE="-2" color="black">    36.  </font>                 <font color="#009900">double</font> y2<font color="#990000">,</font> <font color="#009900">double</font> x3<font color="#990000">,</font> <font color="#009900">double</font> y3<font color="#990000">)</font>
 <font SIZE="-2" color="black">    37.  </font>    <font color="#990000">:</font> <b><font color="#000000">a</font></b><font color="#990000">(</font>x1<font color="#990000">,</font>y1<font color="#990000">),</font> <b><font color="#000000">b</font></b><font color="#990000">(</font>x2<font color="#990000">,</font>y2<font color="#990000">),</font> <b><font color="#000000">c</font></b><font color="#990000">(</font>x3<font color="#990000">,</font>y3<font color="#990000">)</font>                     <span class="ding">&#x278D;</span>
 <font SIZE="-2" color="black">    38.  </font><font color="#FF0000">{</font> <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    39.  </font>
 <font SIZE="-2" color="black">    40.  </font><font color="#009900">int</font> <b><font color="#000000">main</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    41.  </font>    <font color="#008080">Punkt</font> <b><font color="#000000">a1</font></b><font color="#990000">(</font><font color="#993399">1</font><font color="#990000">,</font><font color="#993399">1</font><font color="#990000">),</font> <b><font color="#000000">b1</font></b><font color="#990000">(</font><font color="#993399">2</font><font color="#990000">,</font><font color="#993399">2</font><font color="#990000">),</font> <b><font color="#000000">c1</font></b><font color="#990000">(</font><font color="#993399">3</font><font color="#990000">,</font><font color="#993399">3</font><font color="#990000">);</font>
 <font SIZE="-2" color="black">    42.  </font>
 <font SIZE="-2" color="black">    43.  </font>    <font color="#008080">Trojkat</font> <b><font color="#000000">T1</font></b><font color="#990000">(</font>a1<font color="#990000">,</font>b1<font color="#990000">,</font>c1<font color="#990000">);</font>
 <font SIZE="-2" color="black">    44.  </font>
 <font SIZE="-2" color="black">    45.  </font>    <font color="#008080">Trojkat</font> <b><font color="#000000">T2</font></b><font color="#990000">(</font><font color="#993399">11</font><font color="#990000">,</font><font color="#993399">22</font><font color="#990000">,</font><font color="#993399">22</font><font color="#990000">,</font><font color="#993399">33</font><font color="#990000">,</font><font color="#993399">33</font><font color="#990000">,</font><font color="#993399">44</font><font color="#990000">);</font>
 <font SIZE="-2" color="black">    46.  </font>
 <font SIZE="-2" color="black">    47.  </font>    T1<font color="#990000">.</font><b><font color="#000000">show</font></b><font color="#990000">();</font>
 <font SIZE="-2" color="black">    48.  </font>    T2<font color="#990000">.</font><b><font color="#000000">show</font></b><font color="#990000">();</font>
 <font SIZE="-2" color="black">    49.  </font><font color="#FF0000">}</font>
</tt></pre>
<hr>

</div>

<P>
Konstruktor klasy
<!--O--><span class='klasa'>Punkt<!--C--></span>
 ma, jak widać, puste ciało; cała
jego praca zostaje wykonana poprzez użycie listy inicjalizacyjnej.
Zapis
<FONT COLOR="#000000"><TT>x(x)</TT></FONT> znaczy &bdquo;zainicjuj
składową&nbsp;
<!--O--><span class='zmienna'>x<!--C--></span>
 (to jest&nbsp;
<!--O--><span class='zmienna'>x<!--C--></span>
 zewnętrzne, poza nawiasem)
posyłając do konstruktora wartość (lokalnej) zmiennej&nbsp;
<!--O--><span class='zmienna'>x<!--C--></span>
 &mdash;&nbsp;
czyli tej związanej z&nbsp;parametrem konstruktora&rdquo;. Oczywiście w&nbsp;naszym
przypadku składowa jest typu wbudowanego; klasy
<!--O--><span class='typ'>double<!--C--></span>
 tak naprawdę
nie ma, ale składnia wywołania konstruktora kopiującego, jak wspominaliśmy,
może być użyta i&nbsp;w odniesieniu do typów wbudowanych.

<P>
Zauważmy, że w&nbsp;klasie
<!--O--><span class='klasa'>Punkt<!--C--></span>
 lista inicjalizacyjna nie jest
konieczna: składowe typów wbudowanych i&nbsp;tak byłyby utworzone
bez kłopotów, a&nbsp;nadaniem im wartości moglibyśmy zająć się
w&nbsp;ciele konstruktora.

<P>
Inaczej jest z&nbsp;klasą/strukturą
<!--O--><span class='klasa'>Trojkat<!--C--></span>.
Jej trzy pola są typu
<!--O--><span class='klasa'>Punkt<!--C--></span>. A zatem podczas tworzenia
obiektów klasy
<!--O--><span class='klasa'>Trojkat<!--C--></span>
 muszą być utworzone, jeszcze
przed wywołaniem konstruktora klasy
<!--O--><span class='klasa'>Trojkat<!--C--></span>, trzy obiekty
klasy
<!--O--><span class='klasa'>Punkt<!--C--></span>, które są składowymi tego obiektu. Klasa

<!--O--><span class='klasa'>Punkt<!--C--></span>
 nie ma
jednak konstruktora domyślnego, zatem jedyną możliwością jest tu
użycie listy inicjalizacyjnej. Odpowiednie konstruktory są tu
zadeklarowane w&nbsp;liniach&nbsp;<span class="ding">&#x278A;</span> i&nbsp;<span class="ding">&#x278B;</span>, a&nbsp;zdefiniowane poza klasą.
Zauważmy, że lista inicjalizacyjna pojawia się
wyłącznie w&nbsp;definicjach konstruktorów, ale nie w&nbsp;ich deklaracjach.
Pierwszy z&nbsp;konstruktorów pobiera poprzez argumenty trzy punkty
i&nbsp;przekazuje je poprzez listę inicjalizacyjną (linia&nbsp;<span class="ding">&#x278C;</span>) do
automatycznie wygenerowanego konstruktora kopiującego klasy
<!--O--><span class='klasa'>Punkt<!--C--></span>.
Drugi pobiera sześć liczb typu
<!--O--><span class='typ'>double<!--C--></span>
 i&nbsp;przekazuje
je, parami, do konstruktora klasy
<!--O--><span class='klasa'>Punkt<!--C--></span>
 pobierającego dwie
liczby (linia&nbsp;<span class="ding">&#x278D;</span>). Wynik tego programu
<PRE>
    Trojkat (1,1)-(2,2)-(3,3)
    Trojkat (11,22)-(22,33)-(33,44)
</PRE>
został uzyskany za pomocą metod
<!--O--><span class='funkcja'>show<!--C--></span>
 w&nbsp;obu klasach.
Zauważmy, że metoda ta w&nbsp;klasie
<!--O--><span class='klasa'>Trojkat<!--C--></span>

korzysta jawnie z&nbsp;tak samo nazwanej metody z&nbsp;klasy

<!--O--><span class='klasa'>Punkt<!--C--></span>. Obie te metody zostały zdefiniowane jako
stałe, gdyż ich rolą jest wydrukowanie informacji
o&nbsp;obiektach, a&nbsp;nie jakakolwiek modyfikacja tych obiektów.

<P>
Przykład klasy z&nbsp;polami ustalonymi i&nbsp;referencyjnymi podamy
w&nbsp;następnym podrozdziale.

<P>
W nowym standardzie C++11,<A NAME="17865"></A> z&nbsp;listy inicjalizacyjnej
jednego konstruktora można też wywołać inny konstruktor tej samej
klasy, czyli jeden konstruktor &bdquo;deleguje&rdquo; pracę do drugiego (dlatego
nazywamy go konstruktorem delegującym,<A NAME="17866"></A>
<A NAME="17867"></A><FONT COLOR="#7b003e"><I>delegating constructor</I></FONT>).
W&nbsp;takim przypadku na liście inicjalizacyjnej jednego konstruktora
umieszczamy wyłącznie jeden element: nazwę danej klasy wraz z&nbsp;argumentami
dla innego konstruktora. Ten inny konstruktor zostanie wtedy wykonany
najpierw (zarówno to, co jest umieszczone na jego liście inicjalizacyjnej,
jak i&nbsp;jego ciało), po czym sterowanie wraca do pierwotnie wywołanego
konstruktora. Na przykład w&nbsp;programie
<BR><A NAME="delegconstr.cpp"></A>
<BR CLEAR='ALL'>
<div class='kodpro'><HR>
      <SPAN  CLASS="textbf">P<SPAN CLASS="arabic">119</SPAN>:</SPAN>
      <A NAME="tex2html126"
  HREF="source-files/delegconstr.cpp">
<!--O--><span class='downl'>delegconstr.cpp<!--C--></span></A>
<A NAME="18339"></A>
      &nbsp;&nbsp;&nbsp;&nbsp;<SMALL CLASS="SMALL">Konstruktory delegujące</SMALL>
      <BR CLEAR="ALL">
<HR>
<pre><tt> <font SIZE="-2" color="black">     1.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;iostream&gt;</font>
 <font SIZE="-2" color="black">     2.  </font>
 <font SIZE="-2" color="black">     3.  </font><b><font color="#0000FF">class</font></b> <font color="#008080">Point</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">     4.  </font>    <font color="#009900">double</font> x<font color="#990000">,</font> y<font color="#990000">;</font>
 <font SIZE="-2" color="black">     5.  </font><b><font color="#0000FF">public</font></b><font color="#990000">:</font>
 <font SIZE="-2" color="black">     6.  </font>    <b><font color="#000000">Point</font></b><font color="#990000">(</font><font color="#009900">double</font> x<font color="#990000">,</font> <font color="#009900">double</font> y<font color="#990000">)</font> <font color="#990000">:</font> <b><font color="#000000">x</font></b><font color="#990000">(</font>x<font color="#990000">),</font> <b><font color="#000000">y</font></b><font color="#990000">(</font>y<font color="#990000">)</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">     7.  </font>        std<font color="#990000">::</font>cerr <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"CTOR 1: (double,double)</font><font color="#CC33CC">\n</font><font color="#FF0000">"</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">     8.  </font>    <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">     9.  </font>
 <font SIZE="-2" color="black">    10.  </font>    <b><font color="#000000">Point</font></b><font color="#990000">(</font><font color="#009900">double</font> x<font color="#990000">)</font> <font color="#990000">:</font> <b><font color="#000000">Point</font></b><font color="#990000">(</font>x<font color="#990000">,</font><font color="#993399">0</font><font color="#990000">)</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    11.  </font>        std<font color="#990000">::</font>cerr <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"CTOR 2: (double)</font><font color="#CC33CC">\n</font><font color="#FF0000">"</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    12.  </font>    <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    13.  </font>    <b><font color="#000000">Point</font></b><font color="#990000">()</font> <font color="#990000">:</font> <b><font color="#000000">Point</font></b><font color="#990000">(</font><font color="#993399">0</font><font color="#990000">)</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    14.  </font>        std<font color="#990000">::</font>cerr <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"CTOR 3: ()</font><font color="#CC33CC">\n</font><font color="#FF0000">"</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    15.  </font>    <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    16.  </font><font color="#FF0000">}</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    17.  </font>
 <font SIZE="-2" color="black">    18.  </font><font color="#009900">int</font> <b><font color="#000000">main</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    19.  </font>    std<font color="#990000">::</font>cerr <font color="#990000">&lt;&lt;</font>   <font color="#FF0000">"Point p1(1,1)</font><font color="#CC33CC">\n</font><font color="#FF0000">"</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    20.  </font>    <font color="#008080">Point</font> <b><font color="#000000">p1</font></b><font color="#990000">(</font><font color="#993399">1</font><font color="#990000">,</font><font color="#993399">1</font><font color="#990000">);</font>
 <font SIZE="-2" color="black">    21.  </font>    std<font color="#990000">::</font>cerr <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"</font><font color="#CC33CC">\n</font><font color="#FF0000">Point p2(2)</font><font color="#CC33CC">\n</font><font color="#FF0000">"</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    22.  </font>    <font color="#008080">Point</font> <b><font color="#000000">p2</font></b><font color="#990000">(</font><font color="#993399">2</font><font color="#990000">);</font>
 <font SIZE="-2" color="black">    23.  </font>    std<font color="#990000">::</font>cerr <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"</font><font color="#CC33CC">\n</font><font color="#FF0000">Point p3</font><font color="#CC33CC">\n</font><font color="#FF0000">"</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    24.  </font>    <font color="#008080">Point</font> p3<font color="#990000">;</font>
 <font SIZE="-2" color="black">    25.  </font><font color="#FF0000">}</font>
</tt></pre>
<hr>

</div>

<P>
jak przekonuje jego wydruk
<PRE>
    Point p1(1,1)
    CTOR 1: (double,double)

    Point p2(2)
    CTOR 1: (double,double)
    CTOR 2: (double)

    Point p3
    CTOR 1: (double,double)
    CTOR 2: (double)
    CTOR 3: ()
</PRE>
podczas tworzenia obiektu
<!--O--><span class='zmienna'>p3<!--C--></span>
 konstruktor domyślny deleguje do
konstruktora drugiego, a&nbsp;ten z&nbsp;kolei do konstruktora pierwszego: wykonanie
wraca potem do konstruktora drugiego i&nbsp;następnie znów do trzeciego.

<P>

<DIV CLASS="navigation"><HR>
<A NAME="tex2html2144"
  HREF="node98.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="ikonypng/prev.png"></A>
<A NAME="tex2html2150"
  HREF="node96.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="ikonypng/up.png"></A>
<A NAME="tex2html2156"
  HREF="node100.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="ikonypng/next.png"></A>
<A NAME="tex2html2152"
  HREF="node1.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="ikonypng/contents.png"></A>
<A NAME="tex2html2154"
  HREF="node150.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="index"
 SRC="ikonypng/index.png"></A> <BR>
<B>Wstecz:</B> <A NAME="tex2html2145"
  HREF="node98.html">15.2 Metody ulotne</A>
<B>W g&#243;r&#281;:</B> <A NAME="tex2html2151"
  HREF="node96.html">15. Klasy (II)</A>
<B>Dalej:</B> <A NAME="tex2html2157"
  HREF="node100.html">15.4 Funkcje zaprzyjaźnione</A>
</DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<p style="text-align:right;"><I><font size=-2>T.R. Werner, 28 września 2018; 23:31</font></I></p>
</ADDRESS>
</BODY>
</HTML>
