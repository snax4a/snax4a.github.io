<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
<TITLE>19.2 Konwersje jawne</TITLE>
<META NAME="description" CONTENT="19.2 Konwersje jawne">
<META NAME="keywords" CONTENT="PRG2CPP">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="LaTeX2HTML v2016">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="PRG2CPP.css">

<LINK REL="previous" HREF="node120.html">
<LINK REL="up" HREF="node119.html">
<LINK REL="next" HREF="node122.html">
</HEAD>

<BODY >

<DIV CLASS="navigation">
<A NAME="tex2html2513"
  HREF="node120.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="ikonypng/prev.png"></A>
<A NAME="tex2html2517"
  HREF="node119.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="ikonypng/up.png"></A>
<A NAME="tex2html2523"
  HREF="node122.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="ikonypng/next.png"></A>
<A NAME="tex2html2519"
  HREF="node1.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="ikonypng/contents.png"></A>
<A NAME="tex2html2521"
  HREF="node150.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="index"
 SRC="ikonypng/index.png"></A> <BR>
<B>Wstecz:</B> <A NAME="tex2html2514"
  HREF="node120.html">19.1 Konwersje od i&nbsp;do</A>
<B>W g&#243;r&#281;:</B> <A NAME="tex2html2518"
  HREF="node119.html">19. Jeszcze o&nbsp;konwersjach</A>
<B>Dalej:</B> <A NAME="tex2html2524"
  HREF="node122.html">20. Dziedziczenie i polimorfizm</A>
<BR> <HR> <P>
</DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Podrozdzia&#322;y</STRONG></A>

<UL CLASS="ChildLinks">
<LI><A NAME="tex2html2525"
  HREF="node121.html#SECTION002021000000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Konwersje uzmienniające</A>
<LI><A NAME="tex2html2526"
  HREF="node121.html#SECTION002022000000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Konwersje statyczne</A>
<LI><A NAME="tex2html2527"
  HREF="node121.html#SECTION002023000000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Konwersje dynamiczne</A>
<LI><A NAME="tex2html2528"
  HREF="node121.html#SECTION002024000000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> Konwersje wymuszane</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION002020000000000000000"></A><A NAME="konw:jaw"></A>
<BR>
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN> Konwersje jawne
</H1>

<P>
W czystym C, tak jak w&nbsp;Javie,<A NAME="25196"></A>
możemy zażądać jawnie konwersji
od wartości jednego typu do wartości innego typu za pomocą
<FONT COLOR="#7b003e"><B>rzutowania</B></FONT>.<A NAME="25198"></A>
Ma ono postać
<pre><tt>       <font color="#990000">(</font>Typ<font color="#990000">)</font> wyrazenie
</tt></pre>
gdzie
<!--O--><span class='typ'>Typ<!--C--></span>
 jest nazwą typu, a&nbsp;
<!--O--><span class='zmienna'>wyrazenie<!--C--></span>
 jest wyrażeniem
o&nbsp;p-wartości innego typu. Wynikiem jest p-wartość typu
<!--O--><span class='typ'>Typ<!--C--></span>,
reprezentująca wartość wyrażenia
<!--O--><span class='zmienna'>wyrazenie<!--C--></span>.
W&nbsp;Javie tego typu rzutowania są bezpieczne: albo na etapie
kompilacji, albo, jeśli to niemożliwe, na etapie wykonania
zostanie sprawdzone, czy takie rzutowanie ma sens. W C&nbsp;taka forma
rzutowania jest mniej bezpieczna; będzie ono wykonane &bdquo;siłowo&rdquo;,
czasem zupełnie bezsensownie. Dlatego lepiej jest używać nowych
operatorów, wprowadzonych w&nbsp;C++, które wykonują te konwersje
w&nbsp;sposób bardziej kontrolowany. Wszystkie one mają postać
<pre><tt>       rodzaj_cast<font color="#990000">&lt;</font>Typ<font color="#990000">&gt;(</font>wyrazenie<font color="#990000">)</font>
</tt></pre>
gdzie zamiast '
<FONT COLOR="#000000"><TT>rodzaj</TT></FONT>' należy wstawić
<!--O--><span class='zmienna'>static<!--C--></span>,

<!--O--><span class='zmienna'>dynamic<!--C--></span>,
<!--O--><span class='zmienna'>const<!--C--></span>
 lub
<!--O--><span class='zmienna'>reinterpret<!--C--></span>. Wynikiem
będzie p-wartość typu
<!--O--><span class='typ'>Typ<!--C--></span>
 utworzona na podstawie wartości
wyrażenia
<!--O--><span class='zmienna'>wyrazenie<!--C--></span>.

<P>

<H2><A NAME="SECTION002021000000000000000"></A><A NAME="konw:uzmien"></A>
<BR>
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Konwersje uzmienniające
</H2>

<P>
<FONT COLOR="#7b003e"><B>Konwersja uzmienniająca</B></FONT>
<A NAME="25218"></A>
<A NAME="25219"></A>
<A NAME="25220"></A>
ma postać
<pre><tt>       <b><font color="#0000FF">const_cast</font></b><font color="#990000">&lt;</font>Typ<font color="#990000">&gt;(</font>wyrazenie<font color="#990000">)</font>
</tt></pre>
Wyrażenie
<!--O--><span class='zmienna'>wyrazenie<!--C--></span>
 musi tu być tego samego typu
co
<!--O--><span class='typ'>Typ<!--C--></span>, tylko z&nbsp;modyfikatorem
<!--O--><span class='klucz'>const<!--C--></span>
 lub
<!--O--><span class='klucz'>volatile<!--C--></span>.
A&nbsp;zatem tego rodzaju konwersja usuwa &bdquo;ustaloność&rdquo; (lub
&bdquo;ulotność&rdquo;) i&nbsp;może służyć <FONT COLOR="#7b003e"><I>tylko</I></FONT> do tego celu. Z&nbsp;drugiej
strony, tego samego efektu <FONT COLOR="#7b003e"><I>nie</I></FONT> można uzyskać za pomocą
konwersji przy użyciu
<!--O--><span class='klucz'>static_cast<!--C--></span>,
<!--O--><span class='klucz'>dynamic_cast<!--C--></span>
 lub

<!--O--><span class='klucz'>reinterpret_cast<!--C--></span>: kompilator uznałby taką konwersję

<!--O--><span class='typ'>const Typ<!--C--></span>
 <!-- MATH
 $\rightarrow$
 -->
<SPAN CLASS="MATH">&#8594;</SPAN>
<!--O--><span class='typ'>Typ<!--C--></span>
 za nielegalną.
Rozpatrzmy przykład:
<BR><A NAME="concast.cpp"></A>
<BR CLEAR='ALL'>
<div class='kodpro'><HR>
      <SPAN  CLASS="textbf">P<SPAN CLASS="arabic">157</SPAN>:</SPAN>
      <A NAME="tex2html165"
  HREF="source-files/concast.cpp">
<!--O--><span class='downl'>concast.cpp<!--C--></span></A>
<A NAME="25448"></A>
      &nbsp;&nbsp;&nbsp;&nbsp;<SMALL CLASS="SMALL">Usuwanie stałości</SMALL>
      <BR CLEAR="ALL">
<HR>
<pre><tt> <font SIZE="-2" color="black">     1.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;iostream&gt;</font>
 <font SIZE="-2" color="black">     2.  </font><b><font color="#0000FF">using</font></b> <b><font color="#0000FF">namespace</font></b> std<font color="#990000">;</font>
 <font SIZE="-2" color="black">     3.  </font>
 <font SIZE="-2" color="black">     4.  </font><font color="#009900">void</font> <b><font color="#000000">changeFirst</font></b><font color="#990000">(</font><font color="#009900">char</font><font color="#990000">*</font> str<font color="#990000">,</font> <font color="#009900">char</font> c<font color="#990000">)</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">     5.  </font>    str<font color="#990000">[</font><font color="#993399">0</font><font color="#990000">]=</font>c<font color="#990000">;</font>
 <font SIZE="-2" color="black">     6.  </font><font color="#FF0000">}</font>
 <font SIZE="-2" color="black">     7.  </font>
 <font SIZE="-2" color="black">     8.  </font><font color="#009900">int</font> <b><font color="#000000">main</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">     9.  </font>    <b><font color="#0000FF">const</font></b> <font color="#009900">char</font> name<font color="#990000">[]</font> <font color="#990000">=</font> <font color="#FF0000">"Jenny"</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    10.  </font>    cout <font color="#990000">&lt;&lt;</font> name <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    11.  </font>
 <font SIZE="-2" color="black">    12.  </font>    <i><font color="#9A1900">// name[0]='K';</font></i>
 <font SIZE="-2" color="black">    13.  </font>
 <font SIZE="-2" color="black">    14.  </font>    <b><font color="#000000">changeFirst</font></b><font color="#990000">(</font><b><font color="#0000FF">const_cast</font></b><font color="#990000">&lt;</font><font color="#009900">char</font><font color="#990000">*&gt;(</font>name<font color="#990000">),</font><font color="#FF0000">'K'</font><font color="#990000">);</font>
 <font SIZE="-2" color="black">    15.  </font>
 <font SIZE="-2" color="black">    16.  </font>    <i><font color="#9A1900">// changeFirst(name,'K');</font></i>
 <font SIZE="-2" color="black">    17.  </font>
 <font SIZE="-2" color="black">    18.  </font>    cout <font color="#990000">&lt;&lt;</font> name <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    19.  </font><font color="#FF0000">}</font>
</tt></pre>
<hr>

</div>

<P>
Funkcja
<!--O--><span class='funkcja'>changeFirst<!--C--></span>
 zmienia pierwszą literę przekazanego
jej C-napisu. W programie głównym tworzymy <FONT COLOR="#7b003e"><I>ustalony</I></FONT> napis

<!--O--><span class='zmienna'>name<!--C--></span>
 o&nbsp;zawartości &#34;Jenny&#34;  (linia&nbsp;9).
Próba jego zmiany w&nbsp;wykomentowanej linii&nbsp;12 skończyłaby się
przerwaniem kompilacji. W linii&nbsp;14 wysyłamy ten napis do funkcji

<!--O--><span class='funkcja'>changeFirst<!--C--></span>, konwertując argument tak, aby usunąć atrybut
stałości. Jak widać z&nbsp;wydruku
<PRE>
    Jenny
    Kenny
</PRE>
po tej operacji zmiana ustalonego napisu powiodła się. Zauważmy
też, że bez konwersji, a&nbsp;więc tak jak w&nbsp;wykomentowanej linii&nbsp;16,
wywołać tej funkcji nie byłoby można, bo
<!--O--><span class='zmienna'>name<!--C--></span>
 jest
C-napisem ustalonym, a&nbsp;funkcja
<!--O--><span class='funkcja'>changeFirst<!--C--></span>
 nie &bdquo;obiecuje&rdquo;,
poprzez deklarację typu parametru jako
<!--O--><span class='klucz'>const<!--C--></span>, że napisu
przekazanego jako argument nie zmieni (czego zresztą obiecać nie
może, bo właśnie ten napis zmienia).

<P>
Jeśli deklarujemy zmienne ustalone, to robimy to właśnie po to, aby
ich nie można było zmieniać. Zatem użycie konwersji uzmienniającej
świadczy o&nbsp;jakiejś niekonsekwencji w programie. Powinno być zatem
stosowane tylko w&nbsp;wyjątkowych wypadkach.

<P>

<H2><A NAME="SECTION002022000000000000000"></A><A NAME="konw:stat"></A>
<BR>
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Konwersje statyczne
</H2>

<P>
<FONT COLOR="#7b003e"><B>Konwersja statyczna</B></FONT>
<A NAME="25249"></A>
<A NAME="25250"></A>
<A NAME="25251"></A>
ma postać
<pre><tt>       <b><font color="#0000FF">static_cast</font></b><font color="#990000">&lt;</font>Typ<font color="#990000">&gt;(</font>wyrazenie<font color="#990000">)</font>
</tt></pre>
i&nbsp;dokonuje jawnego przekształcenia typu, sprawdzając, czy jest
to przekształcenie dopuszczalne. Sprawdzenie odbywa się podczas
kompilacji. Często użycie tego operatora jest właściwie zbędne,
bo konwersja i&nbsp;tak zostanie dokonana. Jeśli jest to jednak konwersja,
w&nbsp;której może wystąpić utrata informacji, to kompilator zwykle
ostrzega nas przed jej użyciem. Stosując jawną konwersję statyczną,
unikamy tego rodzaju ostrzeżeń kompilatora. Na przykład kompilacja
prawidłowego fragmentu kodu
<pre><tt>       <font color="#009900">double</font> x <font color="#990000">=</font> <font color="#993399">4</font><font color="#990000">;</font>
       <font color="#009900">int</font> i <font color="#990000">=</font> x<font color="#990000">;</font>
</tt></pre>
spowoduje wysłanie ostrzeżeń kompilatora
<PRE>
    d.cpp:6: warning: initialization to `int' from `double'
    d.cpp:6: warning: argument to `int' from `double'
</PRE>
których możemy uniknąć jawnie dokonując konwersji:
<pre><tt>       <font color="#009900">double</font> x <font color="#990000">=</font> <font color="#993399">4</font><font color="#990000">;</font>
       <font color="#009900">int</font> i <font color="#990000">=</font> <b><font color="#0000FF">static_cast</font></b><font color="#990000">&lt;</font><font color="#009900">int</font><font color="#990000">&gt;(</font>x<font color="#990000">);</font>
</tt></pre>
Częstym zastosowaniem rzutowania statycznego jest rzutowanie
od typu
<!--O--><span class='typ'>void*<!--C--></span>
 do typu
<!--O--><span class='typ'>Typ*<!--C--></span>
 (konwersja w&nbsp;drugą
stronę jest zawsze bezpieczną konwersją standardową, która
nie wymaga sprawdzania, więc nie musi być jawna).
Takie konwersje stosuje się także do rzutowaia w&nbsp;dół wskaźników
typu &bdquo;wskaźnik do obiektu klasy bazowej&rdquo; do typu
&bdquo;wskaźnik do obiektu klasy pochodnej&rdquo; (dla typów niepolimorficznych,
o&nbsp;czym powiemy w&nbsp;dalszej części).

<P>

<H2><A NAME="SECTION002023000000000000000"></A><A NAME="konw:dyn"></A>
<BR>
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Konwersje dynamiczne
</H2>

<P>
<FONT COLOR="#7b003e"><B>Konwersja dynamiczna</B></FONT>
<A NAME="25265"></A>
<A NAME="25266"></A>
<A NAME="25267"></A>
ma postać
<pre><tt>       <b><font color="#0000FF">dynamic_cast</font></b><font color="#990000">&lt;</font>Typ<font color="#990000">&gt;(</font>wyrazenie<font color="#990000">)</font>
</tt></pre>
Konwersje dynamiczne stosuje się, gdy prawidłowość przekształcenia
nie może być sprawdzona na etapie kompilacji, bo zależy od typu
obiektu klasy polimorficznej. Typ ten jest znany dopiero w&nbsp;czasie
wykonania i&nbsp;wtedy ma miejsce sprawdzenie poprawności. Tego rodzaju
konwersje używane są wyłącznie w&nbsp;odniesieniu do klas polimorficznych
i&nbsp;tylko dla typów wskaźnikowych i&nbsp;referencyjnych.
Ponieważ o&nbsp;polimorfizmie jeszcze nie mówiliśmy, pozostawimy dalsze
szczegóły do
rozdziału o <A HREF="node149.html#rtti:dyncast">dynamicznym rzutowaniu</A> .

<P>

<H2><A NAME="SECTION002024000000000000000"></A><A NAME="konw:wymusz"></A>
<BR>
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> Konwersje wymuszane
</H2>

<P>
&bdquo;Najsilniejszą&rdquo; formą
<A NAME="25278"></A>
<A NAME="25279"></A>
<A NAME="25280"></A>
konwersji jest
<FONT COLOR="#7b003e"><B>konwersja wymuszana</B></FONT>.
Ma ona postać
<pre><tt>       <b><font color="#0000FF">reinterpret_cast</font></b><font color="#990000">&lt;</font>Typ<font color="#990000">&gt;(</font>wyrazenie<font color="#990000">)</font>
</tt></pre>
Użycie takiej konwersji oznacza, że rezygnujemy ze sprawdzania
jej poprawności w&nbsp;czasie kompilacji i&nbsp;wykonania i, co za tym idzie,
ponosimy pełną odpowiedzialność za jej skutki. Stosuje się ją,
gdy wiemy z&nbsp;góry, że ani w&nbsp;czasie kompilacji, ani w&nbsp;czasie wykonania
nie będzie możliwe określenie jej sensowności. W ten sposób
można, na przykład, dokonać konwersji
<!--O--><span class='typ'>char*<!--C--></span>
 <!-- MATH
 $\rightarrow$
 -->
<SPAN CLASS="MATH">&#8594;</SPAN>

<!--O--><span class='typ'>int*<!--C--></span>
 lub
<!--O--><span class='typ'>klasaA*<!--C--></span>
 <!-- MATH
 $\rightarrow$
 -->
<SPAN CLASS="MATH">&#8594;</SPAN>
<!--O--><span class='typ'>klasaB*<!--C--></span>, gdzie klasy

<!--O--><span class='klasa'>klasaA<!--C--></span>
 i&nbsp;
<!--O--><span class='typ'>klasaB<!--C--></span>
 są zupełnie niezależne. Takie
konwersje nie są bezpieczne, a ich reaultat może zależeć od
używanej platformy czy kompilatora.

<P>
Przyjrzyjmy się na przykład poniższemu programowi:
<BR><A NAME="dyncast.cpp"></A>
<BR CLEAR='ALL'>
<div class='kodpro'><HR>
      <SPAN  CLASS="textbf">P<SPAN CLASS="arabic">158</SPAN>:</SPAN>
      <A NAME="tex2html166"
  HREF="source-files/dyncast.cpp">
<!--O--><span class='downl'>dyncast.cpp<!--C--></span></A>
<A NAME="25474"></A>
      &nbsp;&nbsp;&nbsp;&nbsp;<SMALL CLASS="SMALL">Jawne konwersje wymuszane w&nbsp;C++</SMALL>
      <BR CLEAR="ALL">
<HR>
<pre><tt> <font SIZE="-2" color="black">     1.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;iostream&gt;</font>
 <font SIZE="-2" color="black">     2.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;cstring&gt;</font>
 <font SIZE="-2" color="black">     3.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;fstream&gt;</font>
 <font SIZE="-2" color="black">     4.  </font><b><font color="#0000FF">using</font></b> <b><font color="#0000FF">namespace</font></b> std<font color="#990000">;</font>
 <font SIZE="-2" color="black">     5.  </font>
 <font SIZE="-2" color="black">     6.  </font><b><font color="#0000FF">class</font></b> <font color="#008080">Person</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">     7.  </font>    <font color="#009900">char</font> nam<font color="#990000">[</font><font color="#993399">30</font><font color="#990000">];</font>
 <font SIZE="-2" color="black">     8.  </font>    <font color="#009900">int</font>  age<font color="#990000">;</font>
 <font SIZE="-2" color="black">     9.  </font><b><font color="#0000FF">public</font></b><font color="#990000">:</font>
 <font SIZE="-2" color="black">    10.  </font>    <b><font color="#000000">Person</font></b><font color="#990000">(</font><b><font color="#0000FF">const</font></b> <font color="#009900">char</font><font color="#990000">*</font> n<font color="#990000">,</font> <font color="#009900">int</font> a<font color="#990000">)</font> <font color="#990000">:</font> <b><font color="#000000">age</font></b><font color="#990000">(</font>a<font color="#990000">)</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    11.  </font>        <b><font color="#000000">strcpy</font></b><font color="#990000">(</font>nam<font color="#990000">,</font>n<font color="#990000">);</font>
 <font SIZE="-2" color="black">    12.  </font>    <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    13.  </font>
 <font SIZE="-2" color="black">    14.  </font>    <font color="#009900">void</font> <b><font color="#000000">info</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    15.  </font>        cout <font color="#990000">&lt;&lt;</font> nam <font color="#990000">&lt;&lt;</font> <font color="#FF0000">" ("</font> <font color="#990000">&lt;&lt;</font> age <font color="#990000">&lt;&lt;</font> <font color="#FF0000">")"</font> <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    16.  </font>    <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    17.  </font><font color="#FF0000">}</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    18.  </font>
 <font SIZE="-2" color="black">    19.  </font><font color="#009900">int</font> <b><font color="#000000">main</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    20.  </font>    <b><font color="#0000FF">const</font></b> <font color="#008080">size_t</font> size <font color="#990000">=</font> <b><font color="#0000FF">sizeof</font></b><font color="#990000">(</font>Person<font color="#990000">);</font>
 <font SIZE="-2" color="black">    21.  </font>
 <font SIZE="-2" color="black">    22.  </font>    <font color="#008080">Person</font> <b><font color="#000000">john</font></b><font color="#990000">(</font><font color="#FF0000">"John Brown"</font><font color="#990000">,</font><font color="#993399">40</font><font color="#990000">);</font>
 <font SIZE="-2" color="black">    23.  </font>    <font color="#008080">Person</font> <b><font color="#000000">mary</font></b><font color="#990000">(</font><font color="#FF0000">"Mary Wiles"</font><font color="#990000">,</font><font color="#993399">26</font><font color="#990000">);</font>
 <font SIZE="-2" color="black">    24.  </font>
 <font SIZE="-2" color="black">    25.  </font>    <font color="#008080">ofstream</font> <b><font color="#000000">out</font></b><font color="#990000">(</font><font color="#FF0000">"person.ob"</font><font color="#990000">);</font>
 <font SIZE="-2" color="black">    26.  </font>    out<font color="#990000">.</font><b><font color="#000000">write</font></b><font color="#990000">(</font><b><font color="#0000FF">reinterpret_cast</font></b><font color="#990000">&lt;</font><font color="#009900">char</font><font color="#990000">*&gt;(&amp;</font>john<font color="#990000">),</font>size<font color="#990000">);</font>
 <font SIZE="-2" color="black">    27.  </font>    out<font color="#990000">.</font><b><font color="#000000">write</font></b><font color="#990000">(</font>                <font color="#990000">(</font><font color="#009900">char</font><font color="#990000">*)</font> <font color="#990000">&amp;</font>mary <font color="#990000">,</font>size<font color="#990000">);</font>
 <font SIZE="-2" color="black">    28.  </font>    out<font color="#990000">.</font><b><font color="#000000">close</font></b><font color="#990000">();</font>
 <font SIZE="-2" color="black">    29.  </font>
 <font SIZE="-2" color="black">    30.  </font>    <font color="#009900">char</font><font color="#990000">*</font> buff1 <font color="#990000">=</font> <b><font color="#0000FF">new</font></b> <font color="#009900">char</font><font color="#990000">[</font>size<font color="#990000">];</font>
 <font SIZE="-2" color="black">    31.  </font>    <font color="#009900">char</font><font color="#990000">*</font> buff2 <font color="#990000">=</font> <b><font color="#0000FF">new</font></b> <font color="#009900">char</font><font color="#990000">[</font>size<font color="#990000">];</font>
 <font SIZE="-2" color="black">    32.  </font>    <font color="#008080">ifstream</font> <b><font color="#000000">in</font></b><font color="#990000">(</font><font color="#FF0000">"person.ob"</font><font color="#990000">);</font>
 <font SIZE="-2" color="black">    33.  </font>    in<font color="#990000">.</font><b><font color="#000000">read</font></b><font color="#990000">(</font>buff1<font color="#990000">,</font>size<font color="#990000">);</font>
 <font SIZE="-2" color="black">    34.  </font>    in<font color="#990000">.</font><b><font color="#000000">read</font></b><font color="#990000">(</font>buff2<font color="#990000">,</font>size<font color="#990000">);</font>
 <font SIZE="-2" color="black">    35.  </font>    in<font color="#990000">.</font><b><font color="#000000">close</font></b><font color="#990000">();</font>
 <font SIZE="-2" color="black">    36.  </font>
 <font SIZE="-2" color="black">    37.  </font>    Person<font color="#990000">*</font> p1 <font color="#990000">=</font> <b><font color="#0000FF">reinterpret_cast</font></b><font color="#990000">&lt;</font>Person<font color="#990000">*&gt;(</font>buff1<font color="#990000">);</font>
 <font SIZE="-2" color="black">    38.  </font>    Person<font color="#990000">*</font> p2 <font color="#990000">=</font>                 <font color="#990000">(</font>Person<font color="#990000">*)</font> buff2 <font color="#990000">;</font>
 <font SIZE="-2" color="black">    39.  </font>
 <font SIZE="-2" color="black">    40.  </font>    p1<font color="#990000">-&gt;</font><b><font color="#000000">info</font></b><font color="#990000">();</font>
 <font SIZE="-2" color="black">    41.  </font>    p2<font color="#990000">-&gt;</font><b><font color="#000000">info</font></b><font color="#990000">();</font>
 <font SIZE="-2" color="black">    42.  </font>
 <font SIZE="-2" color="black">    43.  </font>    <b><font color="#0000FF">delete</font></b> <font color="#990000">[]</font> buff1<font color="#990000">;</font>
 <font SIZE="-2" color="black">    44.  </font>    <b><font color="#0000FF">delete</font></b> <font color="#990000">[]</font> buff2<font color="#990000">;</font>
 <font SIZE="-2" color="black">    45.  </font><font color="#FF0000">}</font>
</tt></pre>
<hr>

</div>

<P>
Zdefiniowaliśmy tu (linie&nbsp;22 i&nbsp;23) dwa obiekty klasy
<!--O--><span class='klasa'>Person<!--C--></span>,
zawierającej jedną składową tablicową i&nbsp;jedną typu
<!--O--><span class='typ'>int<!--C--></span>.
W liniach&nbsp;26 i&nbsp;27 zapisujemy te obiekty w&nbsp;formie binarnej do pliku.
Metoda
<!--O--><span class='funkcja'>write<!--C--></span>

(patrz rozdział o&nbsp;zapisie <A HREF="node107.html#io:zapnieform">nieformatowanym</A> )
ma pierwszy parametr typu
<!--O--><span class='typ'>const char*<!--C--></span>. Tymczasem chcemy zapisać
reprezentację binarną obiektu
<!--O--><span class='zmienna'>john<!--C--></span>
 klasy
<!--O--><span class='klasa'>Person<!--C--></span>:
obiekt ten znajduje się pod adresem
<!--O--><span class='zmienna'>&amp;john<!--C--></span>
 i&nbsp;ma długość

<FONT COLOR="#000000"><TT>sizeof(Person)</TT></FONT>. Typem
<!--O--><span class='zmienna'>&amp;john<!--C--></span>
 jest
<!--O--><span class='typ'>Person*<!--C--></span>,
zatem dokonujemy konwersji tego argumentu do typu
<!--O--><span class='typ'>char*<!--C--></span>

za pomocą rzutowania z&nbsp;użyciem
<!--O--><span class='klucz'>reinterpret_cast<!--C--></span>.
W&nbsp;linii&nbsp;27 robimy to samo za pomocą rzutowania w&nbsp;stylu C, aby pokazać,
te dwie formy mogą tu być użyte zamiennie.

<P>
Dwa obiekty klasy
<!--O--><span class='klasa'>Person<!--C--></span>
 zapisane na dysk odczytujemy
następnie do dwóch tablic znakowych
<!--O--><span class='zmienna'>buff1<!--C--></span>

i&nbsp;
<!--O--><span class='zmienna'>buff2<!--C--></span>
 (linie&nbsp;33 i&nbsp;34). Po wczytaniu są to po prostu
tablice znaków (bajtów): ani w&nbsp;czasie kompilacji, ani w&nbsp;czasie
wykonania system nie ma możliwości sprawdzenia, czy zawarte w&nbsp;nich
ciągi bajtów rzeczywiście są reprezentacją obiektów klasy

<!--O--><span class='klasa'>Person<!--C--></span>. Ale my wiemy, że powinno tak być, bo sami przed
chwilą te ciągi bajtów zapisaliśmy. Wymuszamy zatem (linie&nbsp;37 i&nbsp;38)
konwersję zmiennych
<!--O--><span class='zmienna'>buff<!--C--></span>
 do typu
<!--O--><span class='typ'>Person*<!--C--></span>
 &mdash;&nbsp;znów
na dwa sposoby: raz za pomocą
<!--O--><span class='klucz'>reinterpret_cast<!--C--></span>
 i&nbsp;raz za
pomocą rzutowania w&nbsp;stylu C. Wydruk z&nbsp;linii&nbsp;40 i&nbsp;41
<PRE>
    John Brown (40)
    Mary Wiles (26)
</PRE>
przekonuje nas, że konwersja się udała. Pamiętać jednak trzeba,
że karkołomne konwersje wymuszane nie zawsze dają rezultaty zgodne
z&nbsp;oczekiwaniem. Co gorsza, rezultaty te mogą zależeć od użytego
kompilatora i&nbsp;architektury komputera: skoro świadomie zrezygnowaliśmy
z&nbsp;kontroli typów, język nie daje nam tu żadnych gwarancji. Tworzona
jest wartość, która ma wzorzec bitowy taki jak wartość
konwertowana, ale przypisany jest jej inny typ: sensowność tego nie
jest ani zapewniana, ani sprawdzana.

<DIV CLASS="navigation"><HR>
<A NAME="tex2html2513"
  HREF="node120.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="ikonypng/prev.png"></A>
<A NAME="tex2html2517"
  HREF="node119.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="ikonypng/up.png"></A>
<A NAME="tex2html2523"
  HREF="node122.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="ikonypng/next.png"></A>
<A NAME="tex2html2519"
  HREF="node1.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="ikonypng/contents.png"></A>
<A NAME="tex2html2521"
  HREF="node150.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="index"
 SRC="ikonypng/index.png"></A> <BR>
<B>Wstecz:</B> <A NAME="tex2html2514"
  HREF="node120.html">19.1 Konwersje od i&nbsp;do</A>
<B>W g&#243;r&#281;:</B> <A NAME="tex2html2518"
  HREF="node119.html">19. Jeszcze o&nbsp;konwersjach</A>
<B>Dalej:</B> <A NAME="tex2html2524"
  HREF="node122.html">20. Dziedziczenie i polimorfizm</A>
</DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<p style="text-align:right;"><I><font size=-2>T.R. Werner, 28 września 2018; 23:31</font></I></p>
</ADDRESS>
</BODY>
</HTML>
