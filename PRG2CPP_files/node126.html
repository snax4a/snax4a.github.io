<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
<TITLE>20.4 Metody wirtualne i&nbsp;polimorfizm</TITLE>
<META NAME="description" CONTENT="20.4 Metody wirtualne i&nbsp;polimorfizm">
<META NAME="keywords" CONTENT="PRG2CPP">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="LaTeX2HTML v2016">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="PRG2CPP.css">

<LINK REL="next" HREF="node127.html">
<LINK REL="previous" HREF="node125.html">
<LINK REL="up" HREF="node122.html">
<LINK REL="next" HREF="node127.html">
</HEAD>

<BODY >

<DIV CLASS="navigation">
<A NAME="tex2html2592"
  HREF="node125.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="ikonypng/prev.png"></A>
<A NAME="tex2html2598"
  HREF="node122.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="ikonypng/up.png"></A>
<A NAME="tex2html2604"
  HREF="node127.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="ikonypng/next.png"></A>
<A NAME="tex2html2600"
  HREF="node1.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="ikonypng/contents.png"></A>
<A NAME="tex2html2602"
  HREF="node150.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="index"
 SRC="ikonypng/index.png"></A> <BR>
<B>Wstecz:</B> <A NAME="tex2html2593"
  HREF="node125.html">20.3 Operator przypisania dla</A>
<B>W g&#243;r&#281;:</B> <A NAME="tex2html2599"
  HREF="node122.html">20. Dziedziczenie i polimorfizm</A>
<B>Dalej:</B> <A NAME="tex2html2605"
  HREF="node127.html">20.5 Klasy abstrakcyjne</A>
<BR> <HR> <P>
</DIV>
<!--End of Navigation Panel-->

<H1><A NAME="SECTION002140000000000000000"></A><A NAME="dzie:wirt"></A>
<BR>
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">4</SPAN> Metody wirtualne i&nbsp;polimorfizm
</H1>

<P>
W klasie pochodnej można zdefiniować metodę o&nbsp;sygnaturze i&nbsp;typie
zwracanym (patrz rozdział o <A HREF="node61.html#funk:dekl">funkcjach</A> )
takich samych jak dla pewnej metody z&nbsp;klasy bazowej.
Nie jest to przeciążenie, tylko <FONT COLOR="#7b003e"><B>przesłonięcie</B></FONT>:
<A NAME="26091"></A><A NAME="26092"></A>
sygnatury są bowiem te same (a funkcje przeciążane mają tę
samą nazwę, ale <FONT COLOR="#7b003e"><I>różne</I></FONT> sygnatury).

<P>
Załóżmy następującą sytuację:
<pre><tt>       <b><font color="#0000FF">class</font></b> <font color="#008080">A</font> <font color="#FF0000">{</font>
           <i><font color="#9A1900">// ...</font></i>
           <font color="#009900">void</font> <b><font color="#000000">fun</font></b><font color="#990000">()</font> <font color="#FF0000">{</font> <font color="#990000">...</font> <font color="#FF0000">}</font>
           <i><font color="#9A1900">// ...</font></i>
       <font color="#FF0000">}</font><font color="#990000">;</font>

       <b><font color="#0000FF">class</font></b> <font color="#008080">B</font> <font color="#990000">:</font> <b><font color="#0000FF">public</font></b> A <font color="#FF0000">{</font>
           <i><font color="#9A1900">// ...</font></i>
           <font color="#009900">void</font> <b><font color="#000000">fun</font></b><font color="#990000">()</font> <font color="#FF0000">{</font> <font color="#990000">...</font> <font color="#FF0000">}</font>
           <i><font color="#9A1900">// ...</font></i>
       <font color="#FF0000">}</font><font color="#990000">;</font>
</tt></pre>
Zdefiniujmy teraz
<pre><tt>       <font color="#008080">A</font> a<font color="#990000">,</font> <font color="#990000">*</font>pa  <font color="#990000">=</font> <b><font color="#0000FF">new</font></b> A<font color="#990000">,</font> <font color="#990000">*</font>pab <font color="#990000">=</font> <b><font color="#0000FF">new</font></b> B<font color="#990000">,</font>
            <font color="#990000">&amp;</font>raa <font color="#990000">=</font> a<font color="#990000">,</font>     <font color="#990000">&amp;</font>rab <font color="#990000">=</font> <font color="#990000">*</font>pab<font color="#990000">;</font>
</tt></pre>
A zatem

<UL>
<LI>
<!--O--><span class='zmienna'>a<!--C--></span>
 jest obiektem klasy&nbsp;
<!--O--><span class='klasa'>A<!--C--></span>;
</LI>
<LI>
<!--O--><span class='zmienna'>pa<!--C--></span>
 jest wskaźnikiem typu
<!--O--><span class='typ'>A*<!--C--></span>
 do obiektu
          klasy&nbsp;
<!--O--><span class='klasa'>A<!--C--></span>. Mówimy, że typem <FONT COLOR="#7b003e"><I>statycznym</I></FONT>
          <A NAME="26105"></A> obiektu wskazywanego przez
<!--O--><span class='zmienna'>pa<!--C--></span>

          jest
<!--O--><span class='klasa'>A<!--C--></span>
 i&nbsp;dynamicznym<A NAME="26108"></A>
          również&nbsp;
<!--O--><span class='typ'>A<!--C--></span>;
</LI>
<LI>
<!--O--><span class='zmienna'>pab<!--C--></span>
 jest wskaźnikiem typu&nbsp;
<!--O--><span class='typ'>A*<!--C--></span>
 do obiektu
          klasy&nbsp;
<!--O--><span class='klasa'>B<!--C--></span>. Typem statycznym obiektu wskazywanego przez

<!--O--><span class='zmienna'>pab<!--C--></span>
 jest&nbsp;
<!--O--><span class='typ'>A<!--C--></span>, ale dynamicznym jego typ
          prawdziwy, czyli&nbsp;
<!--O--><span class='typ'>B<!--C--></span>;
</LI>
<LI>
<!--O--><span class='zmienna'>raa<!--C--></span>
 jest referencją typu&nbsp;
<!--O--><span class='typ'>A&amp;<!--C--></span>
 do obiektu
          klasy&nbsp;
<!--O--><span class='klasa'>A<!--C--></span>. Typem statycznym obiektu, do którego
          referencją jest
<!--O--><span class='zmienna'>raa<!--C--></span>
 jest typ&nbsp;
<!--O--><span class='typ'>A<!--C--></span>;
          dynamicznym również&nbsp;
<!--O--><span class='typ'>A<!--C--></span>;
</LI>
<LI>
<!--O--><span class='zmienna'>rab<!--C--></span>
 jest referencją typu&nbsp;
<!--O--><span class='typ'>A&amp;<!--C--></span>
 do obiektu
          klasy&nbsp;
<!--O--><span class='klasa'>B<!--C--></span>. Typ statyczny obiektu, do którego
          referencją jest
<!--O--><span class='zmienna'>rab<!--C--></span>
 to&nbsp;
<!--O--><span class='typ'>A<!--C--></span>, typ dynamiczny
          to&nbsp;
<!--O--><span class='typ'>B<!--C--></span>.
</LI>
</UL>
Przypomnijmy, że

<P>

<P>

<div class='wazne'>
Typ <FONT COLOR="#7b003e"><I>statyczny</I></FONT> obiektu wskazywanego przez wskaźnik lub
    referencję określony jest przez deklarację tego wskaźnika
    (referencji). Typ <FONT COLOR="#7b003e"><I>dynamiczny</I></FONT> to rzeczywisty typ obiektu, do
    którego odnosi się ten wskaźnik lub to referencja. Typ
    dynamiczny obiektu może być zazwyczaj określony dopiero podczas
    wykonania programu; typ statyczny jest znany już w&nbsp;czasie
    kompilacji.


</div>

<P>
Przypuśćmy teraz, że wywołujemy funkcję
<!--O--><span class='funkcja'>fun<!--C--></span>
 za pomocą
zmiennych
<!--O--><span class='zmienna'>a<!--C--></span>,
<!--O--><span class='zmienna'>pa<!--C--></span>,
<!--O--><span class='zmienna'>pab<!--C--></span>,
<!--O--><span class='zmienna'>raa<!--C--></span>

i&nbsp;
<!--O--><span class='zmienna'>rab<!--C--></span>
 i&nbsp;pytamy, która z&nbsp;metod: czy ta z&nbsp;klasy&nbsp;
<!--O--><span class='klasa'>A<!--C--></span>,
czy ta z&nbsp;klasy&nbsp;
<!--O--><span class='klasa'>B<!--C--></span>, zostanie wywołana. Otóż dla wszystkich
wywołań decyduje tu typ <FONT COLOR="#7b003e"><I>statyczny</I></FONT>; wywołania
<pre><tt>       a<font color="#990000">.</font><b><font color="#000000">fun</font></b><font color="#990000">();</font> pa<font color="#990000">-&gt;</font><b><font color="#000000">fun</font></b><font color="#990000">();</font> pab<font color="#990000">-&gt;</font><b><font color="#000000">fun</font></b><font color="#990000">();</font> raa<font color="#990000">.</font><b><font color="#000000">fun</font></b><font color="#990000">();</font> rab<font color="#990000">.</font><b><font color="#000000">fun</font></b><font color="#990000">();</font>
</tt></pre>
wszystkie spowodują wywołanie funkcji
<!--O--><span class='funkcja'>fun<!--C--></span>
 z&nbsp;klasy&nbsp;
<!--O--><span class='klasa'>A<!--C--></span>,
mimo że w&nbsp;trzecim i&nbsp;piątym przypadku obiekt, na rzecz którego
nastąpi wywołanie, jest w&nbsp;rzeczywistości obiektem klasy
pochodnej&nbsp;
<!--O--><span class='klasa'>B<!--C--></span>, a&nbsp;w klasie tej metoda
<!--O--><span class='funkcja'>fun<!--C--></span>
 została
przedefiniowana, przesłaniając wersję odziedziczoną z&nbsp;klasy
bazowej.

<P>
Dla znających Pythona<A NAME="26146"></A>
czy Javę<A NAME="26147"></A> może to być zaskoczenie.
Tam bowiem, jak w&nbsp;większości języków obiektowych, decyduje typ
dynamiczny: jeśli obiekt, na rzecz którego wywołujemy metodę,
jest klasy pochodnej względem tej, która jest typem statycznym
wskaźnika (referencji) do tego obiektu, to wywołana będzie wersja
tej metody pochodząca z&nbsp;klasy pochodnej (jeśli została tam
przedefiniowana). Mówimy wtedy, że metody są <FONT COLOR="#7b003e"><B>wirtualne</B></FONT>.
<A NAME="26149"></A> A zatem w&nbsp;Javie wszystkie metody (prócz
finalnych i&nbsp;prywatnych) <FONT COLOR="#7b003e"><I>są</I></FONT> wirtualne. Klasy w&nbsp;których istnieją
metody wirtualne, nazywamy klasami <FONT COLOR="#7b003e"><B>polimorficznymi</B></FONT>,
<A NAME="26152"></A><A NAME="26153"></A> bo wywołanie ich
poprzez wskaźnik (referencję) pewnego typu zależy od typu obiektu
na który ten wskaźnik wskazuje, ma zatem &bdquo;wiele kształtów&rdquo;.
A&nbsp;zatem w&nbsp;Javie klasy, prócz finalnych, <FONT COLOR="#7b003e"><I>są</I></FONT> polimorficzne.

<P>
Trzeba jednak zdawać sobie sprawę, że ceną za polimorfizm jest
pewna utrata wydajności. Dla wywołań na rzecz obiektów klas
niepolimorficznych odpowiednia metoda jest wybierana już w&nbsp;czasie
kompilacji na podstawie typu statycznego. Mówimy, że następuje wtedy
<FONT COLOR="#7b003e"><B>wczesne wiązanie</B></FONT> (ang.&nbsp;<FONT COLOR="#7b003e"><I>early binding</I></FONT>).
<A NAME="26157"></A>

<P>
Typ dynamiczny obiektu wskazywanego przez wskaźnik lub referencję
może być natomiast określony dopiero w&nbsp;czasie wykonania. Kompilator,
napotkawszy wywołanie metody z&nbsp;klasy polimorficznej, nie może
umieścić w&nbsp;pliku wykonywalnym kodu odpowiadającego wywołaniu
konkretnej funkcji. Zamiast tego umieszczany jest tam kod sprawdzający
prawdziwy typ obiektu i&nbsp;wybierający odpowiednią metodę. Mówimy, że
następuje wtedy <FONT COLOR="#7b003e"><B>późne wiązanie</B></FONT> (ang.&nbsp;<FONT COLOR="#7b003e"><I>late binding</I></FONT>).
<A NAME="26160"></A>
Tak więc każde wywołanie metody wirtualnej powoduje narzut czasowy
w&nbsp;trakcie wykonania. Wybranie odpowiedniej metody wymaga też dostępu
do informacji o&nbsp;różnych wersjach metody w&nbsp;klasach dziedziczących.
Informacja ta jest zwykle umieszczana w&nbsp;specjalnej tablicy, której
adres jest przechowywany w&nbsp;<FONT COLOR="#7b003e"><I>każdym</I></FONT> obiekcie klasy polimorficznej.
Obiekt taki musi być zatem większy niż obiekt analogicznej klasy
niepolimorficznej &mdash;&nbsp;polimorfizm powoduje zatem również narzut
pamięciowy.

<P>
W C++, przede wszystkim właśnie ze względu na wydajność,
podejście do polimorfizmu jest nieco inne niż w&nbsp;większości innych
języków obiektowych. Jako programiści mamy
mianowicie możliwość wyboru: czy chcemy, aby definiowana klasa była
polimorficzna, czy też z&nbsp;polimorfizmu rezygnujemy na rzecz
podniesienia wydajności. Domyślnie nowo definiowane klasy
<FONT COLOR="#7b003e"><I>nie są</I></FONT> polimorficzne, a&nbsp;zatem definiowane w&nbsp;nich metody
<FONT COLOR="#7b003e"><I>nie są</I></FONT> wirtualne. Jeśli w&nbsp;programie następuje wywołanie,
poprzez wskaźnik lub referencję, dowolnej metody na rzecz obiektu
klasy niepolimorficznej, kompilator umieszcza od razu wywołanie
konkretnej metody w&nbsp;kodzie wynikowym. Kieruje się przy tym wyłącznie
typem zadeklarowanym (statycznym) wskaźnika lub referencji.

<P>
Aby definiowana klasa była polimorficzna, wystarczy jeśli choć
jedna metoda tej klasy będzie wirtualna. W szczególności
<FONT COLOR="#7b003e"><I>może</I></FONT> to być destruktor (ale <FONT COLOR="#7b003e"><I>nie</I></FONT> konstruktor &mdash;&nbsp;ten
wirtualny nie może być nigdy).

<P>
Deklaracja metody jako wirtualnej musi mieć miejsce w&nbsp;klasie
bazowej. Jeśli metoda została zadeklarowana w&nbsp;klasie bazowej
jako wirtualna,<A NAME="26166"></A> to wersje
przesłaniające tę metodę we wszystkich klasach
pochodnych (nie tylko &bdquo;synach&rdquo;, ale i&nbsp;&bdquo;wnukach&rdquo;,
&bdquo;prawnukach&rdquo;,...) są też wirtualne. Ponowne deklarowanie
ich w&nbsp;klasach pochodnych jako wirtualnych jest dopuszczalne i&nbsp;zalecane,
bo zwiększa czytelność kodu, ale w&nbsp;zasadzie zbędne.

<P>
Metodę deklarujemy jako wirtualną przez dodanie modyfikatora

<!--O--><span class='klucz'>virtual<!--C--></span>
 w&nbsp;jej deklaracji. W&nbsp;klasach pochodnych, jak
powiedzieliśmy, powtarzać tego nie musimy; na przykład:
<pre><tt>       <b><font color="#0000FF">class</font></b> <font color="#008080">A</font> <font color="#FF0000">{</font>
           <i><font color="#9A1900">// ...</font></i>
           <b><font color="#0000FF">virtual</font></b> <font color="#009900">double</font> <b><font color="#000000">fun</font></b><font color="#990000">(</font><font color="#009900">int</font><font color="#990000">,</font><font color="#009900">int</font><font color="#990000">);</font>
           <i><font color="#9A1900">// ...</font></i>
       <font color="#FF0000">}</font><font color="#990000">;</font>

       <b><font color="#0000FF">class</font></b> <font color="#008080">B</font> <font color="#990000">:</font> <b><font color="#0000FF">public</font></b> A <font color="#FF0000">{</font>
           <i><font color="#9A1900">// ...</font></i>
           <font color="#009900">double</font> <b><font color="#000000">fun</font></b><font color="#990000">(</font><font color="#009900">int</font><font color="#990000">,</font><font color="#009900">int</font><font color="#990000">);</font>
           <i><font color="#9A1900">// ...</font></i>
       <font color="#FF0000">}</font><font color="#990000">;</font>
</tt></pre>
Zdefiniujmy jak przedtem:
<pre><tt>       <font color="#008080">A</font> a<font color="#990000">,</font> <font color="#990000">*</font>pa  <font color="#990000">=</font> <b><font color="#0000FF">new</font></b> A<font color="#990000">,</font> <font color="#990000">*</font>pab <font color="#990000">=</font> <b><font color="#0000FF">new</font></b> B<font color="#990000">,</font>
            <font color="#990000">&amp;</font>raa <font color="#990000">=</font> a<font color="#990000">,</font>     <font color="#990000">&amp;</font>rab <font color="#990000">=</font> <font color="#990000">*</font>pab<font color="#990000">;</font>
</tt></pre>
Teraz klasy są polimorficzne, metoda
<!--O--><span class='funkcja'>fun<!--C--></span>
 jest wirtualna,
a więc zadziała mechanizm późnego wiązania. Wywołania
<pre><tt>       a<font color="#990000">.</font><b><font color="#000000">fun</font></b><font color="#990000">(),</font> pa<font color="#990000">-&gt;</font><b><font color="#000000">fun</font></b><font color="#990000">(),</font> pab<font color="#990000">-&gt;</font><b><font color="#000000">fun</font></b><font color="#990000">(),</font> raa<font color="#990000">.</font><b><font color="#000000">fun</font></b><font color="#990000">(),</font> rab<font color="#990000">.</font><b><font color="#000000">fun</font></b><font color="#990000">()</font>
</tt></pre>
spowodują teraz w&nbsp;trzecim i&nbsp;piątym przypadku wywołanie metody

<!--O--><span class='funkcja'>fun<!--C--></span>
 z&nbsp;klasy
<!--O--><span class='klasa'>B<!--C--></span>, gdyż:

<UL>
<LI>wywołanie jest poprzez wskaźnik lub referencję
          (typu bazowego: odpowiednio&nbsp;
<!--O--><span class='typ'>A*<!--C--></span>
 i&nbsp;
<!--O--><span class='typ'>A&amp;<!--C--></span>);
</LI>
<LI>prawdziwym typem obiektu, na rzecz którego następuje
          wywołanie, jest typ pochodny&nbsp;
<!--O--><span class='typ'>B<!--C--></span>;
</LI>
<LI>metoda
<!--O--><span class='funkcja'>fun<!--C--></span>
 jest wirtualna;
</LI>
<LI>metoda
<!--O--><span class='funkcja'>fun<!--C--></span>
 została przedefiniowana
          (nadpisana) w&nbsp;klasie&nbsp;
<!--O--><span class='klasa'>B<!--C--></span>.
</LI>
</UL>
Oczywiście, nic by się złego nie stało, gdybyśmy w&nbsp;klasie

<!--O--><span class='klasa'>B<!--C--></span>
 nie przedefiniowali metody
<!--O--><span class='funkcja'>fun<!--C--></span>. Wywołana
zostałaby tak czy owak wersja widoczna w&nbsp;klasie
<!--O--><span class='klasa'>B<!--C--></span>; gdyby

<!--O--><span class='funkcja'>fun<!--C--></span>
 nie została przesłonięta, to w&nbsp;klasie
<!--O--><span class='klasa'>B<!--C--></span>

widoczną wersją metody
<!--O--><span class='funkcja'>fun<!--C--></span>
 byłaby ta odziedziczona
z&nbsp;klasy&nbsp;
<!--O--><span class='klasa'>A<!--C--></span>. Nawet zresztą gdy metodę przedefiniowaliśmy,
możemy jawnie &bdquo;wyłączyć&rdquo; polimorfizm: wywołania
<pre><tt>       pab<font color="#990000">-&gt;</font>A<font color="#990000">::</font><b><font color="#000000">fun</font></b><font color="#990000">();</font>   rab<font color="#990000">.</font>A<font color="#990000">::</font><b><font color="#000000">fun</font></b><font color="#990000">();</font>
</tt></pre>
spowodują wywołanie wersji funkcji
<!--O--><span class='funkcja'>fun<!--C--></span>
 z&nbsp;klasy
bazowej&nbsp;
<!--O--><span class='klasa'>A<!--C--></span>
 nawet jeśli wersja przesłaniająca
w&nbsp;klasie&nbsp;
<!--O--><span class='klasa'>B<!--C--></span>
 istnieje i&nbsp;mimo że obiekt, na rzecz którego
następuje wywołanie, jest typu
<!--O--><span class='typ'>B<!--C--></span>, a&nbsp;wywołanie jest poprzez
wskaźnik lub referencję. Tak więc jawna kwalifikacja nazwy metody
(za pomocą nazwy klasy) powoduje, że normalny mechanizm polimorfizmu
nie jest używany &mdash;&nbsp;takie wywołanie będzie &bdquo;wcześnie wiązane&rdquo;.
Skoro tak, to możliwe jest też wywołanie
<pre><tt>       b<font color="#990000">.</font>A<font color="#990000">::</font><b><font color="#000000">fun</font></b><font color="#990000">()</font>
</tt></pre>
bezpośrednio na rzecz obiektu klasy&nbsp;
<!--O--><span class='klasa'>B<!--C--></span>
 (nie poprzez wskaźnik
lub referencję). Odwrotna sytuacja nie jest oczywiście możliwa nigdy:
nie można, nawet używając nazw kwalifikowanych, wywołać metody
z klasy&nbsp;
<!--O--><span class='klasa'>B<!--C--></span>
 poprzez nazwę <FONT COLOR="#7b003e"><I>obiektu</I></FONT> klasy
bazowej&nbsp;
<!--O--><span class='klasa'>A<!--C--></span>
 (a nie wskaźnika lub referencji):
<pre><tt>       a<font color="#990000">.</font>B<font color="#990000">::</font><b><font color="#000000">fun</font></b><font color="#990000">()</font> <i><font color="#9A1900">// Źle!!</font></i>
</tt></pre>
byłoby nielegalne.

<P>

<P>
<BR>

<P>
Przesłaniając w&nbsp;klasie pochodnej metodę dziedziczoną z&nbsp;klasy bazowej
możemy zawęzić jej dostępność (ale nie rozszerzyć &mdash;&nbsp;
odwrotnie niż w&nbsp;Javie!).<A NAME="26206"></A>

<P>
Jaka zatem będzie dostępność wirtualnej metody wywoływanej poprzez
wskaźnik typu&nbsp;
<!--O--><span class='typ'>A*<!--C--></span>
 do obiektu klasy&nbsp;
<!--O--><span class='klasa'>B<!--C--></span>, jeśli w&nbsp;klasie
pochodnej&nbsp;
<!--O--><span class='klasa'>B<!--C--></span>
 dostępność tej metody zawęziliśmy?
Otóż będzie ona taka, jak w&nbsp;klasie, do której odnosi się wskaźnik
lub referencja (typ statyczny), a&nbsp;<FONT COLOR="#7b003e"><I>nie</I></FONT> taka jak w&nbsp;klasie obiektu
(typ dynamiczny). Jeśli metoda jest publiczna w&nbsp;klasie bazowej, to
odpowiednie wersje tej metody z&nbsp;klas pochodnych będą dostępne
poprzez wskaźnik lub referencja do obiektu klasy bazowej, nawet jeśli
w&nbsp;klasach pochodnych ta sama składowa jest prywatna!
Rozpatrzmy przykład:
<A NAME="figur.cpp"></A>
<BR CLEAR='ALL'>
<div class='kodpro'><HR>
      <SPAN  CLASS="textbf">P<SPAN CLASS="arabic">166</SPAN>:</SPAN>
      <A NAME="tex2html174"
  HREF="source-files/figur.cpp">
<!--O--><span class='downl'>figur.cpp<!--C--></span></A>
<A NAME="26748"></A>
      &nbsp;&nbsp;&nbsp;&nbsp;<SMALL CLASS="SMALL">Dostępność funkcji wirtualnych</SMALL>
      <BR CLEAR="ALL">
<HR>
<pre><tt> <font SIZE="-2" color="black">     1.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;iostream&gt;</font>
 <font SIZE="-2" color="black">     2.  </font><b><font color="#0000FF">using</font></b> <b><font color="#0000FF">namespace</font></b> std<font color="#990000">;</font>
 <font SIZE="-2" color="black">     3.  </font>
 <font SIZE="-2" color="black">     4.  </font><b><font color="#0000FF">class</font></b> <font color="#008080">Figura</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">     5.  </font><b><font color="#0000FF">protected</font></b><font color="#990000">:</font>
 <font SIZE="-2" color="black">     6.  </font>    <font color="#009900">int</font>  height<font color="#990000">;</font>
 <font SIZE="-2" color="black">     7.  </font><b><font color="#0000FF">public</font></b><font color="#990000">:</font>
 <font SIZE="-2" color="black">     8.  </font>    <b><font color="#000000">Figura</font></b><font color="#990000">(</font><font color="#009900">int</font> height <font color="#990000">=</font> <font color="#993399">0</font><font color="#990000">)</font> <font color="#990000">:</font> <b><font color="#000000">height</font></b><font color="#990000">(</font>height<font color="#990000">)</font>
 <font SIZE="-2" color="black">     9.  </font>    <font color="#FF0000">{</font> <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    10.  </font>
 <font SIZE="-2" color="black">    11.  </font>    <b><font color="#0000FF">virtual</font></b> <font color="#009900">void</font> <b><font color="#000000">what</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    12.  </font>        cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"Figura: h="</font> <font color="#990000">&lt;&lt;</font> height <font color="#990000">&lt;&lt;</font>endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    13.  </font>    <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    14.  </font><font color="#FF0000">}</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    15.  </font>
 <font SIZE="-2" color="black">    16.  </font><b><font color="#0000FF">class</font></b> <font color="#008080">Prostokat</font> <font color="#990000">:</font> <b><font color="#0000FF">public</font></b> Figura <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    17.  </font><b><font color="#0000FF">private</font></b><font color="#990000">:</font>
 <font SIZE="-2" color="black">    18.  </font>    <font color="#009900">int</font>  base<font color="#990000">;</font>
 <font SIZE="-2" color="black">    19.  </font>    <font color="#009900">void</font> <b><font color="#000000">what</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    20.  </font>        cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"Prostokat: (h,b)=("</font> <font color="#990000">&lt;&lt;</font> height
 <font SIZE="-2" color="black">    21.  </font>             <font color="#990000">&lt;&lt;</font> <font color="#FF0000">","</font> <font color="#990000">&lt;&lt;</font> base <font color="#990000">&lt;&lt;</font> <font color="#FF0000">")</font><font color="#CC33CC">\n</font><font color="#FF0000">"</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    22.  </font>    <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    23.  </font><b><font color="#0000FF">public</font></b><font color="#990000">:</font>
 <font SIZE="-2" color="black">    24.  </font>    <b><font color="#000000">Prostokat</font></b><font color="#990000">(</font><font color="#009900">int</font> height <font color="#990000">=</font> <font color="#993399">0</font><font color="#990000">,</font> <font color="#009900">int</font> base <font color="#990000">=</font> <font color="#993399">0</font><font color="#990000">)</font>
 <font SIZE="-2" color="black">    25.  </font>        <font color="#990000">:</font> <b><font color="#000000">Figura</font></b><font color="#990000">(</font>height<font color="#990000">),</font> <b><font color="#000000">base</font></b><font color="#990000">(</font>base<font color="#990000">)</font>
 <font SIZE="-2" color="black">    26.  </font>    <font color="#FF0000">{</font> <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    27.  </font><font color="#FF0000">}</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    28.  </font>
 <font SIZE="-2" color="black">    29.  </font><font color="#009900">int</font> <b><font color="#000000">main</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    30.  </font>    <font color="#008080">Figura</font>    <font color="#990000">*</font>f <font color="#990000">=</font> <b><font color="#0000FF">new</font></b> <b><font color="#000000">Prostokat</font></b><font color="#990000">(</font><font color="#993399">4</font><font color="#990000">,</font><font color="#993399">5</font><font color="#990000">)</font>  <font color="#990000">,</font> <font color="#990000">&amp;</font>rf <font color="#990000">=</font> <font color="#990000">*</font>f<font color="#990000">;</font>
 <font SIZE="-2" color="black">    31.  </font>    <font color="#008080">Prostokat</font> <font color="#990000">*</font>p <font color="#990000">=</font> <b><font color="#0000FF">new</font></b> <b><font color="#000000">Prostokat</font></b><font color="#990000">(</font><font color="#993399">40</font><font color="#990000">,</font><font color="#993399">50</font><font color="#990000">);</font>
 <font SIZE="-2" color="black">    32.  </font>
 <font SIZE="-2" color="black">    33.  </font>      <i><font color="#9A1900">// what w Prostokat private, ale w Figura nie!</font></i>
 <font SIZE="-2" color="black">    34.  </font>    f<font color="#990000">-&gt;</font><b><font color="#000000">what</font></b><font color="#990000">();</font>                         <i><font color="#9A1900">// Prostokat</font></i>
 <font SIZE="-2" color="black">    35.  </font>    rf<font color="#990000">.</font><b><font color="#000000">what</font></b><font color="#990000">();</font>                         <i><font color="#9A1900">// Prostokat</font></i>
 <font SIZE="-2" color="black">    36.  </font>
 <font SIZE="-2" color="black">    37.  </font>      <i><font color="#9A1900">// p-&gt;what(); nie, bo what prywatne w Prostokat</font></i>
 <font SIZE="-2" color="black">    38.  </font>      <i><font color="#9A1900">// Ale ponizsze legalne!</font></i>
 <font SIZE="-2" color="black">    39.  </font>    <font color="#990000">((</font>Figura<font color="#990000">*)</font>p<font color="#990000">)-&gt;</font><b><font color="#000000">what</font></b><font color="#990000">();</font>              <i><font color="#9A1900">// Prostokat</font></i>
 <font SIZE="-2" color="black">    40.  </font>    <font color="#990000">((</font>Figura<font color="#990000">&amp;)*</font>p<font color="#990000">).</font><b><font color="#000000">what</font></b><font color="#990000">();</font>              <i><font color="#9A1900">// Prostokat</font></i>
 <font SIZE="-2" color="black">    41.  </font>
 <font SIZE="-2" color="black">    42.  </font>      <i><font color="#9A1900">// OK: wersja publiczna z klasy bazowej Figura</font></i>
 <font SIZE="-2" color="black">    43.  </font>    p<font color="#990000">-&gt;</font>Figura<font color="#990000">::</font><b><font color="#000000">what</font></b><font color="#990000">();</font>                 <i><font color="#9A1900">// Figura</font></i>
 <font SIZE="-2" color="black">    44.  </font><font color="#FF0000">}</font>
</tt></pre>
<hr>

</div>

Wirtualna funkcja
<!--O--><span class='funkcja'>what<!--C--></span>
 jest w&nbsp;klasie
<!--O--><span class='klasa'>Figura<!--C--></span>

zadeklarowana jako
<!--O--><span class='klucz'>public<!--C--></span>
 (linia&nbsp;11). W klasie
<!--O--><span class='klasa'>Prostokat<!--C--></span>

metoda ta jest przesłaniana, a&nbsp;wersja przesłaniająca jest

<!--O--><span class='klucz'>private<!--C--></span>
 (linia&nbsp;19). Zmienne
<!--O--><span class='zmienna'>f<!--C--></span>
 i&nbsp;
<!--O--><span class='zmienna'>rf<!--C--></span>

są typu
<!--O--><span class='typ'>Figura*<!--C--></span>
 i&nbsp;
<!--O--><span class='typ'>Figura&amp;<!--C--></span>, ale obiektem przez nie
wskazywanym jest obiekt klasy
<!--O--><span class='klasa'>Prostokat<!--C--></span>
 (linia&nbsp;30).
Tak więc typem <SPAN  CLASS="textit">dynamicznym</SPAN> wskazywanego obiektu jest

<!--O--><span class='typ'>Prostokat<!--C--></span>, ale statycznym
<!--O--><span class='klasa'>Figura<!--C--></span>.
Przyjrzyjmy się wywołaniom z&nbsp;linii&nbsp;34 i&nbsp;35. Wywołujemy tam
metodę
<!--O--><span class='funkcja'>what<!--C--></span>
 z&nbsp;klasy obiektu, czyli z&nbsp;klasy
<!--O--><span class='klasa'>Prostokat<!--C--></span>,
bo metoda jest wirtualna i&nbsp;brany jest pod uwagę typ dynamiczny.
W tej klasie metoda
<!--O--><span class='funkcja'>what<!--C--></span>
 jest prywatna, ale mimo to
wywołanie się powiedzie: typ statyczny obieku do którego
odnoszą się zmienne
<!--O--><span class='zmienna'>f<!--C--></span>
 i&nbsp;
<!--O--><span class='zmienna'>rf<!--C--></span>

to
<!--O--><span class='klasa'>Figura<!--C--></span>, a&nbsp;tam metoda ta była publiczna.
<PRE>
    Prostokat: (h,b)=(4,5)
    Prostokat: (h,b)=(4,5)
    Prostokat: (h,b)=(40,50)
    Prostokat: (h,b)=(40,50)
    Figura: h=40
</PRE>
Natomiast zakomentowane wywołanie z&nbsp;linii&nbsp;37 nie powiodłoby
się. Tam bowiem typem statycznym obiektu wskazywanego przez

<!--O--><span class='zmienna'>p<!--C--></span>
 jest obiekt klasy
<!--O--><span class='klasa'>Prostokat<!--C--></span>, a&nbsp;w tej klasie
metoda
<!--O--><span class='funkcja'>what<!--C--></span>
 jest prywatna.

<P>
Zwróćmy uwagę na wywołania z&nbsp;linii&nbsp;39 i&nbsp;40. Zmienna
<!--O--><span class='zmienna'>p<!--C--></span>

jest co prawda wskaźnikiem do obiektu typu pochodnego (i&nbsp;na taki
obiekt wskazuje), ale przed wywołaniem rzutujemy wartość tego
wskaźnika na typ
<!--O--><span class='klasa'>Figura*<!--C--></span>, a&nbsp;zatem zmieniamy typ statyczny
wskazywanego obiektu na
<!--O--><span class='klasa'>Figura<!--C--></span>, w&nbsp;której to klasie

<!--O--><span class='funkcja'>what<!--C--></span>
 jest metodą publiczną &mdash;&nbsp;analogiczny mechanizm
zastosowaliśmy dla referencji
<!--O--><span class='zmienna'>rf<!--C--></span>. Zatem oba te wywołania
powiodą się.

<P>
Ostatnia linia wydruku jest rezultatem instrukcji z&nbsp;linii&nbsp;43 programu.
Obiektem wskazywanym przez zmienną wskaźnikową
<!--O--><span class='zmienna'>p<!--C--></span>
 jest co
prawda obiekt klasy
<!--O--><span class='klasa'>Prostokat<!--C--></span>, ale wywołaliśmy jawnie,
poprzez kwalifikację nazwą zakresu, metodę
<!--O--><span class='funkcja'>what<!--C--></span>
 z&nbsp;klasy
bazowej
<!--O--><span class='klasa'>Figura<!--C--></span>. Wywołanie zatem nie jest polimorficzne. Było
możliwe, gdyż w&nbsp;klasie
<!--O--><span class='klasa'>Figura<!--C--></span>
 metoda
<!--O--><span class='funkcja'>what<!--C--></span>
 jest
publiczna.

<P>

<P>
<BR>

<P>
Przekonajmy się jeszcze, że polimorfizm rzeczywiście kosztuje,
a&nbsp;zatem nie powinien być stosowany bez potrzeby.
W przykładzie poniżej definiujemy trzy bardzo podobne klasy:
<A NAME="polysiz.cpp"></A>
<BR CLEAR='ALL'>
<div class='kodpro'><HR>
      <SPAN  CLASS="textbf">P<SPAN CLASS="arabic">167</SPAN>:</SPAN>
      <A NAME="tex2html175"
  HREF="source-files/polysiz.cpp">
<!--O--><span class='downl'>polysiz.cpp<!--C--></span></A>
<A NAME="26757"></A>
      &nbsp;&nbsp;&nbsp;&nbsp;<SMALL CLASS="SMALL">Wzrost rozmiaru obiektów klas polimorficznych</SMALL>
      <BR CLEAR="ALL">
<HR>
<pre><tt> <font SIZE="-2" color="black">     1.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;iostream&gt;</font>
 <font SIZE="-2" color="black">     2.  </font><b><font color="#0000FF">using</font></b> <b><font color="#0000FF">namespace</font></b> std<font color="#990000">;</font>
 <font SIZE="-2" color="black">     3.  </font>
 <font SIZE="-2" color="black">     4.  </font><b><font color="#0000FF">class</font></b> <font color="#008080">A</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">     5.  </font>    <font color="#009900">int</font> i<font color="#990000">;</font>
 <font SIZE="-2" color="black">     6.  </font><b><font color="#0000FF">public</font></b><font color="#990000">:</font>
 <font SIZE="-2" color="black">     7.  </font>    <b><font color="#000000">A</font></b><font color="#990000">()</font> <font color="#990000">:</font> <b><font color="#000000">i</font></b><font color="#990000">(</font><font color="#993399">0</font><font color="#990000">)</font>
 <font SIZE="-2" color="black">     8.  </font>    <font color="#FF0000">{</font> <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">     9.  </font><font color="#FF0000">}</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    10.  </font>
 <font SIZE="-2" color="black">    11.  </font><b><font color="#0000FF">class</font></b> <font color="#008080">B</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    12.  </font>    <font color="#009900">int</font> i<font color="#990000">;</font>
 <font SIZE="-2" color="black">    13.  </font><b><font color="#0000FF">public</font></b><font color="#990000">:</font>
 <font SIZE="-2" color="black">    14.  </font>    <b><font color="#000000">B</font></b><font color="#990000">()</font> <font color="#990000">:</font> <b><font color="#000000">i</font></b><font color="#990000">(</font><font color="#993399">0</font><font color="#990000">)</font>
 <font SIZE="-2" color="black">    15.  </font>    <font color="#FF0000">{</font> <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    16.  </font>    <font color="#990000">~</font><b><font color="#000000">B</font></b><font color="#990000">()</font>
 <font SIZE="-2" color="black">    17.  </font>    <font color="#FF0000">{</font> <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    18.  </font><font color="#FF0000">}</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    19.  </font>
 <font SIZE="-2" color="black">    20.  </font><b><font color="#0000FF">class</font></b> <font color="#008080">C</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    21.  </font>    <font color="#009900">int</font> i<font color="#990000">;</font>
 <font SIZE="-2" color="black">    22.  </font><b><font color="#0000FF">public</font></b><font color="#990000">:</font>
 <font SIZE="-2" color="black">    23.  </font>    <b><font color="#000000">C</font></b><font color="#990000">()</font> <font color="#990000">:</font> <b><font color="#000000">i</font></b><font color="#990000">(</font><font color="#993399">0</font><font color="#990000">)</font>
 <font SIZE="-2" color="black">    24.  </font>    <font color="#FF0000">{</font> <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    25.  </font>    <b><font color="#0000FF">virtual</font></b> <font color="#990000">~</font><b><font color="#000000">C</font></b><font color="#990000">()</font>
 <font SIZE="-2" color="black">    26.  </font>    <font color="#FF0000">{</font> <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    27.  </font><font color="#FF0000">}</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    28.  </font>
 <font SIZE="-2" color="black">    29.  </font><font color="#009900">int</font> <b><font color="#000000">main</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    30.  </font>   cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"sizeof(A): "</font> <font color="#990000">&lt;&lt;</font> <b><font color="#0000FF">sizeof</font></b><font color="#990000">(</font>A<font color="#990000">)</font> <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    31.  </font>   cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"sizeof(B): "</font> <font color="#990000">&lt;&lt;</font> <b><font color="#0000FF">sizeof</font></b><font color="#990000">(</font>B<font color="#990000">)</font> <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    32.  </font>   cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"sizeof(C): "</font> <font color="#990000">&lt;&lt;</font> <b><font color="#0000FF">sizeof</font></b><font color="#990000">(</font>C<font color="#990000">)</font> <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    33.  </font><font color="#FF0000">}</font>
</tt></pre>
<hr>

</div>

Klasa&nbsp;
<!--O--><span class='klasa'>B<!--C--></span>
 jest identyczna jak klasa&nbsp;
<!--O--><span class='klasa'>A<!--C--></span>, tyle że
definiuje destruktor (zresztą w&nbsp;tej klasie niepotrzebny).
Destruktor ten nie jest wirtualny, a&nbsp;więc klasa nie jest polimorficzna.
Natomiast klasa&nbsp;
<!--O--><span class='klasa'>C<!--C--></span>
 jest identyczna jak&nbsp;
<!--O--><span class='klasa'>B<!--C--></span>, ale jej
destruktor jest wirtualny. Wystarczy to, aby klasa ta była
polimorficzna (choć, póki co, żadna inna klasa z&nbsp;niej nie
dziedziczy). W liniach&nbsp;30-32 drukujemy rozmiary obiektów wszystkich
trzech klas:
<PRE>
    sizeof(A): 4
    sizeof(B): 4
    sizeof(C): 8
</PRE>
Widzimy, że dopóki klasa nie jest polimorficzna, rozmiar obiektu jest
taki, jak wynika z&nbsp;rozmiaru pól. Samo dodanie metody (w tym przypadku
destruktora) nie zwiększa rozmiaru obiektów. Natomiast dodanie
polimorfizmu, jak dla klasy&nbsp;
<!--O--><span class='klasa'>C<!--C--></span>, powoduje wzrost rozmiaru obiektu,
w naszym przykładzie o&nbsp;cztery bajty. W przypadku tej prostej klasy
oznacza to zatem wzrost o&nbsp;100%.

<P>
Często się zdarza, że pola klasy są głównie typu wskaźnikowego;
obiekty takich klas zwykle nie są duże. Narzut spowodowany
polimorfizmem, a&nbsp;więc obecnością dodatkowej informacji
(o&nbsp;tzw.&nbsp;tablicy funkcji wirtualnych) w&nbsp;każdym obiekcie klasy może
być więc dość spory.

<P>

<DIV CLASS="navigation"><HR>
<A NAME="tex2html2592"
  HREF="node125.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="ikonypng/prev.png"></A>
<A NAME="tex2html2598"
  HREF="node122.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="ikonypng/up.png"></A>
<A NAME="tex2html2604"
  HREF="node127.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="ikonypng/next.png"></A>
<A NAME="tex2html2600"
  HREF="node1.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="ikonypng/contents.png"></A>
<A NAME="tex2html2602"
  HREF="node150.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="index"
 SRC="ikonypng/index.png"></A> <BR>
<B>Wstecz:</B> <A NAME="tex2html2593"
  HREF="node125.html">20.3 Operator przypisania dla</A>
<B>W g&#243;r&#281;:</B> <A NAME="tex2html2599"
  HREF="node122.html">20. Dziedziczenie i polimorfizm</A>
<B>Dalej:</B> <A NAME="tex2html2605"
  HREF="node127.html">20.5 Klasy abstrakcyjne</A>
</DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<p style="text-align:right;"><I><font size=-2>T.R. Werner, 28 września 2018; 23:31</font></I></p>
</ADDRESS>
</BODY>
</HTML>
