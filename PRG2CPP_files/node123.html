<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
<TITLE>20.1 Podstawy dziedziczenia</TITLE>
<META NAME="description" CONTENT="20.1 Podstawy dziedziczenia">
<META NAME="keywords" CONTENT="PRG2CPP">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="LaTeX2HTML v2016">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="PRG2CPP.css">

<LINK REL="next" HREF="node124.html">
<LINK REL="previous" HREF="node122.html">
<LINK REL="up" HREF="node122.html">
<LINK REL="next" HREF="node124.html">
</HEAD>

<BODY >

<DIV CLASS="navigation">
<A NAME="tex2html2550"
  HREF="node122.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="ikonypng/prev.png"></A>
<A NAME="tex2html2556"
  HREF="node122.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="ikonypng/up.png"></A>
<A NAME="tex2html2562"
  HREF="node124.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="ikonypng/next.png"></A>
<A NAME="tex2html2558"
  HREF="node1.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="ikonypng/contents.png"></A>
<A NAME="tex2html2560"
  HREF="node150.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="index"
 SRC="ikonypng/index.png"></A> <BR>
<B>Wstecz:</B> <A NAME="tex2html2551"
  HREF="node122.html">20. Dziedziczenie i polimorfizm</A>
<B>W g&#243;r&#281;:</B> <A NAME="tex2html2557"
  HREF="node122.html">20. Dziedziczenie i polimorfizm</A>
<B>Dalej:</B> <A NAME="tex2html2563"
  HREF="node124.html">20.2 Konstruktory i&nbsp;destruktory klas</A>
<BR> <HR> <P>
</DIV>
<!--End of Navigation Panel-->

<H1><A NAME="SECTION002110000000000000000"></A><A NAME="dzie:pdst"></A>
<BR>
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">1</SPAN> Podstawy dziedziczenia
</H1>

<P>
Definiując klasę pochodną<A NAME="25667"></A>
definiujemy typ danych rozszerzający typ
określany przez klasę bazową,<A NAME="25668"></A>
a&nbsp;więc tę, z&nbsp;której klasa dziedziczy. Obiekty klasy pochodnej będą
zawierać te składowe, które zawierają obiekty klasy bazowej, i,
choć niekoniecznie, dodatkowe składowe, których nie było w&nbsp;klasie
bazowej. Klasa pochodna może też dodawać nowe metody lub zmieniać
implementację metod odziedziczonych ze swojej klasy bazowej.

<P>
Zatem klasa bazowa jest bardziej ogólna, modeluje pewien fragment
rzeczywistości na wyższym poziomie abstrakcji. Klasa pochodna jest
bardziej szczegółowa, mniej abstrakcyjna. Tak więc, na przykład,
pojęcie <SPAN  CLASS="textit">mebel</SPAN> jest bardziej abstrakcyjne, zaś krzesło bardziej
konkretne: zatem klasa opisująca krzesła dziedziczyłaby z&nbsp;klasy
opisującej meble:
<!--O--><span class='klasa'>Mebel<!--C--></span>
 <!-- MATH
 $\leftarrow$
 -->
<SPAN CLASS="MATH">&#8592;</SPAN>
<!--O--><span class='klasa'>Krzeslo<!--C--></span>.
Mogłaby dodać, na przykład, składową opisującą ilość nóg,
której w&nbsp;bardziej ogólnej klasie
<!--O--><span class='klasa'>Mebel<!--C--></span>
 nie było,
bo nie każdy mebel ma nogi.

<P>
Zauważmy tu, że zaznaczając dziedziczenie za pomocą strzałek,
jak to zrobiliśmy powyżej, rysujemy te strzałki w&nbsp;kierunku od klasy
pochodnej do klasy bazowej.

<P>
Składnia deklaracji/definicji klas pochodnych jest następująca:
<pre><tt>       <b><font color="#0000FF">class</font></b> <font color="#008080">A</font> <font color="#FF0000">{</font>
           <i><font color="#9A1900">// ...</font></i>
       <font color="#FF0000">}</font><font color="#990000">;</font>

       <b><font color="#0000FF">class</font></b> <font color="#008080">B</font> <font color="#990000">:</font> <b><font color="#0000FF">public</font></b> A <font color="#FF0000">{</font>
           <i><font color="#9A1900">// ...</font></i>
       <font color="#FF0000">}</font><font color="#990000">;</font>

       <b><font color="#0000FF">class</font></b> <font color="#008080">C</font> <font color="#990000">:</font> B <font color="#FF0000">{</font>
           <i><font color="#9A1900">// ...</font></i>
       <font color="#FF0000">}</font><font color="#990000">;</font>
</tt></pre>
Klasy bazowe dla danej klasy deklarujemy na
<FONT COLOR="#7b003e"><B>liście dziedziczenia</B></FONT><A NAME="25676"></A>
umieszczonej po nazwie klasy i&nbsp;dwukropku, a&nbsp;przed definicją (ciałem)
klasy. Klas bazowych może być kilka: ich nazwy umieszczamy wtedy na
liście oddzielając je przecinkami. Powyższy zapis oznacza, że

<UL>
<LI>klasa
<!--O--><span class='klasa'>A<!--C--></span>
 jest klasą pierwotną; nie dziedziczy
          z&nbsp;żadnej innej klasy (nie ma&nbsp;w C++ wspólnego
          &bdquo;przodka&rdquo; w&nbsp;rodzaju klasy
<!--O--><span class='klasa'>Object<!--C--></span>

          z Javy);<A NAME="25680"></A>
</LI>
<LI>klasa
<!--O--><span class='klasa'>B<!--C--></span>
 dziedziczy z&nbsp;
<!--O--><span class='klasa'>A<!--C--></span>;
</LI>
<LI>klasa
<!--O--><span class='klasa'>C<!--C--></span>
 dziedziczy z&nbsp;
<!--O--><span class='klasa'>B<!--C--></span>, a&nbsp;więc pośrednio
          również z&nbsp;klasy&nbsp;
<!--O--><span class='klasa'>A<!--C--></span>.
</LI>
</UL>
W definicji klasy
<!--O--><span class='klasa'>B<!--C--></span>
 występuje specyfikator dostępu

<!--O--><span class='klucz'>public<!--C--></span>.<A NAME="25689"></A>  Prócz tego specyfikatora, mogą w&nbsp;tym
miejscu wystąpić również specyfikatory
<!--O--><span class='klucz'>private<!--C--></span>

<A NAME="25691"></A> lub
<!--O--><span class='klucz'>protected<!--C--></span>.<A NAME="25693"></A>
Określają one górną granicę dostępności tych składowych klasy
pochodnej, które odziedziczone zostały z&nbsp;klasy bazowej
(patrz rozdział o&nbsp;dostępności <A HREF="node87.html#klasy:access">składowych</A> klasy).
Oznacza to, że składowe określone w&nbsp;klasie bazowej będą w&nbsp;klasie
pochodnej miały dostępność taką samą jak w&nbsp;klasie bazowej lub
węższą, jeśli ich dostępność w klasie bazowej była szersza
niż ta zadeklarowana w&nbsp;klasie pochodnej. Odziedziczone składowe
prywatne w&nbsp;ogóle nie są w&nbsp;klasie pochodnej bezpośrednio dostępne.
Mogą jednak być dostępne za pomocą odziedziczonych nieprywatnych
metod z&nbsp;klasy bazowej &mdash;&nbsp;takie metody znajdują się w&nbsp;zakresie klasy
bazowej, więc do jej składowych prywatnych oczywiście mają dostęp.

<P>

<P>

<div class='wazne'>
Składowe prywatne odziedziczone z&nbsp;klasy bazowej, nawet jeśli
    nie są widoczne w&nbsp;klasie pochodnej, fizycznie wchodzą w&nbsp;skład
    obiektów klasy pochodnej.


</div>

<P>
Reasumując:

<UL>
<LI>Specyfikator
<!--O--><span class='klucz'>public<!--C--></span>
 oznacza, że wszystkie składowe
          publiczne w&nbsp;klasie bazowej będą publiczne i&nbsp;w klasie
          pochodnej, a&nbsp;składowe chronione (<!--O--><span class='klucz'>protected<!--C--></span>) będą
          chronione i&nbsp;w klasie dziedziczącej (składowe prywatne, jak
          powiedzieliśmy, nie są widoczne);
</LI>
<LI>Specyfikator
<!--O--><span class='klucz'>protected<!--C--></span>
 oznacza, że wszystkie
          składowe publiczne w&nbsp;klasie bazowej będą <FONT COLOR="#7b003e"><I>chronione</I></FONT>
          (<!--O--><span class='klucz'>protected<!--C--></span>) w&nbsp;klasie pochodnej, tak jak i&nbsp;składowe
          chronione z&nbsp;klasy bazowej.
</LI>
<LI>Specyfikator
<!--O--><span class='klucz'>private<!--C--></span>
 oznacza, że wszystkie składowe
          publiczne i&nbsp;chronione z&nbsp;klasy bazowej stają się prywatnymi
          w&nbsp;klasie pochodnej.
</LI>
</UL>
Przypomnijmy tu, że

<P>

<P>

<div class='wazne'>
Atrybut
<!--O--><span class='klucz'>protected<!--C--></span>
 oznacza, że dane pole
    czy metoda będą dostępne (tak jakby były publiczne) w&nbsp;klasach
    pochodnych danej klasy, a&nbsp;zachowują się jak prywatne dla
    wszystkich innych klas i&nbsp;funkcji.


</div>

<P>
Brak specyfikatora na liście dziedziczenia, jak w&nbsp;definicji
klasy&nbsp;
<!--O--><span class='klasa'>C<!--C--></span>
 z&nbsp;powyższego przykładu, jest równoważny z&nbsp;określeniem
specyfikatora
<!--O--><span class='klucz'>private<!--C--></span>.

<P>
Zauważmy, że w powyższym przykładzie dziedziczenie z&nbsp;klasy&nbsp;
<!--O--><span class='klasa'>C<!--C--></span>

miałoby już niewielki sens, bo w&nbsp;obiektach ewentualnej klasy
dziedziczącej żadne składowe z&nbsp;klas bazowych (w tym przypadku

<!--O--><span class='klasa'>A<!--C--></span>,
<!--O--><span class='klasa'>B<!--C--></span>
 i&nbsp;
<!--O--><span class='klasa'>C<!--C--></span>) nie byłyby w&nbsp;ogóle widoczne.

<P>
Jeśli w&nbsp;klasie pochodnej zawęziliśmy dostępność
pól/metod specyfikatorem
<!--O--><span class='klucz'>protected<!--C--></span>
 lub
<!--O--><span class='klucz'>private<!--C--></span>

w&nbsp;definicji klasy (po dwukropku, a&nbsp;przed ciałem klasy), to można tę
dostępność <FONT COLOR="#7b003e"><I>przywrócić</I></FONT> indywidualnie dla
wybranych pól/metod, podając ich identyfikatory w&nbsp;postaci
kwalifikowanych nazw w&nbsp;odpowiednich sekcjach. Podkreślmy jeszcze raz:
<FONT COLOR="#7b003e"><I>nazwy</I></FONT>, a&nbsp;nie pełne deklaracje. Kwalifikowane, czyli wraz
z&nbsp;nazwą klasy bazowej.

<P>
W poniższym przykładzie
w klasie
<!--O--><span class='klasa'>A<!--C--></span>
 składowe
<!--O--><span class='zmienna'>x<!--C--></span>,
<!--O--><span class='zmienna'>y<!--C--></span>
 i&nbsp;
<!--O--><span class='zmienna'>z<!--C--></span>
 są
publiczne, a&nbsp;składowe (tutaj będące metodami)
<!--O--><span class='funkcja'>fff<!--C--></span>,

<!--O--><span class='funkcja'>ggg<!--C--></span>
 i&nbsp;
<!--O--><span class='funkcja'>hhh<!--C--></span>
 są chronione. Składowa
<!--O--><span class='zmienna'>k<!--C--></span>
 jest
prywatna i&nbsp;nie będzie bezpośrednnio widoczna w&nbsp;klasie pochodnej.
<pre><tt>       <b><font color="#0000FF">class</font></b> <font color="#008080">A</font> <font color="#FF0000">{</font>
           <font color="#009900">double</font> k<font color="#990000">;</font>

       <b><font color="#0000FF">public</font></b><font color="#990000">:</font>
           <font color="#009900">int</font> x<font color="#990000">,</font> y<font color="#990000">,</font> z

       <b><font color="#0000FF">protected</font></b><font color="#990000">:</font>
           <font color="#009900">double</font> <b><font color="#000000">fff</font></b><font color="#990000">(</font><font color="#009900">int</font><font color="#990000">);</font>
           <font color="#009900">double</font> <b><font color="#000000">ggg</font></b><font color="#990000">(</font><font color="#009900">int</font><font color="#990000">);</font>
           <font color="#009900">double</font> <b><font color="#000000">hhh</font></b><font color="#990000">(</font><font color="#009900">int</font><font color="#990000">);</font>
           <i><font color="#9A1900">// ...</font></i>
       <font color="#FF0000">}</font><font color="#990000">;</font>
</tt></pre>
Niech teraz klasa
<!--O--><span class='klasa'>B<!--C--></span>
 będzie zdefiniowana tak:
<pre><tt> <font SIZE="-2" color="black">     1.  </font>    <b><font color="#0000FF">class</font></b> <font color="#008080">B</font> <font color="#990000">:</font> <b><font color="#0000FF">private</font></b> A <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">     2.  </font>    <b><font color="#0000FF">public</font></b><font color="#990000">:</font>
 <font SIZE="-2" color="black">     3.  </font>        A<font color="#990000">::</font>x<font color="#990000">;</font>
 <font SIZE="-2" color="black">     4.  </font>        A<font color="#990000">::</font>y<font color="#990000">;</font>
 <font SIZE="-2" color="black">     5.  </font>
 <font SIZE="-2" color="black">     6.  </font>    <b><font color="#0000FF">protected</font></b><font color="#990000">:</font>
 <font SIZE="-2" color="black">     7.  </font>        A<font color="#990000">::</font>fff<font color="#990000">;</font>
 <font SIZE="-2" color="black">     8.  </font>        <i><font color="#9A1900">// ...</font></i>
 <font SIZE="-2" color="black">     9.  </font>    <font color="#FF0000">}</font><font color="#990000">;</font>
</tt></pre>
W klasie
<!--O--><span class='klasa'>B<!--C--></span>
 dostępność dziedziczonych składowych klasy

<!--O--><span class='klasa'>A<!--C--></span>
 zawężona jest do poziomu
<!--O--><span class='klucz'>private<!--C--></span>
 (linia&nbsp;1; ten sam
efekt można było zapewnić nie podając specyfikatora dostępności
w&nbsp;ogóle, gdyż dostępność
<!--O--><span class='klucz'>private<!--C--></span>
 jest domyślna).
Następnie jednak przywracana jest dostępność publiczna
dla składowych
<!--O--><span class='zmienna'>x<!--C--></span>&nbsp;i&nbsp;
<!--O--><span class='zmienna'>y<!--C--></span>
 (linie 2-4).
Zauważmy, że <FONT COLOR="#7b003e"><I>nie</I></FONT> przywracamy takiej dostępności składowej

<!--O--><span class='zmienna'>z<!--C--></span>, tak więc w&nbsp;klasie
<!--O--><span class='klasa'>B<!--C--></span>
 stanie się ona prywatna.
Zauważmy też, że w&nbsp;liniach&nbsp;3 i&nbsp;4 wymienieliśmy tylko kwalifikowane
nazwy, a&nbsp;nie deklaracje &mdash;&nbsp;nie podaliśmy na przykład typu pól.

<P>
W liniach&nbsp;6-7 przywróciliśmy dostępność chronioną dla
składowej
<!--O--><span class='funkcja'>fff<!--C--></span>. Tu również podaliśmy tylko kwalifikowaną
nazwę, a&nbsp;nie deklarację funkcji &mdash;&nbsp;nie ma tu listy parametrów
czy określenia typu wartości zwracanej. Metody
<!--O--><span class='funkcja'>ggg<!--C--></span>

i&nbsp;
<!--O--><span class='funkcja'>hhh<!--C--></span>, którym dostępności chronionej nie przywróciliśmy,
stają się w&nbsp;klasie
<!--O--><span class='klasa'>B<!--C--></span>
 prywatne.

<P>
Prócz odziedziczonych składowych w&nbsp;klasie pochodnej można
definiować własne pola i&nbsp;metody. Tak więc obiekt klasy pochodnej
nigdy nie będzie mniejszy niż obiekt klasy bazowej: jak
wspomnieliśmy, zawiera bowiem zawsze kompletny podobiekt klasy bazowej
i&nbsp;często dodatkowe składowe, których w&nbsp;klasie bazowej
nie było.

<P>
W klasie pochodnej można definiować składowe o&nbsp;tych samych nazwach
co składowe klasy bazowej. Mówimy wtedy o
przesłanianiu<A NAME="25746"></A> pól i&nbsp;metod
(przedefiniowywaniu, nadpisywaniu, przekrywaniu, przykrywaniu ...;
ang.&nbsp;<FONT COLOR="#7b003e"><I>overriding</I></FONT>). Przesłaniania pól lepiej nie stosować,
bo prowadzi to do chaosu trudnego do opanowania. Natomiast
przesłanianie metod jest fundamentalnym narzędziem
programowania obiektowego.

<P>
Metody/pola z&nbsp;klasy bazowej (na przykład klasy&nbsp;
<!--O--><span class='klasa'>A<!--C--></span>) mają zakres
tejże klasy bazowej; na przykład mają dostęp do składowych
prywatnych tej klasy. Natomiast zakres klasy pochodnej jest
zawarty w&nbsp;zakresie klasy podstawowej. Znaczy to, że
jeśli te pola i&nbsp;metody <FONT COLOR="#7b003e"><I>nie</I></FONT> są prywatne i&nbsp;<FONT COLOR="#7b003e"><I>nie</I></FONT> zostały
w&nbsp;klasie pochodnej przedefiniowane (przesłonięte),
to w&nbsp;klasie pochodnej (na przykład
<!--O--><span class='klasa'>B<!--C--></span>) są również widoczne
bezpośrednio (a więc nie trzeba stosować dla nich nazw
kwalifikowanych). Jeśli natomiast w&nbsp;klasie pochodnej zostały
przesłonięte, to zakresem takich pól/metod będzie klasa pochodna

<!--O--><span class='klasa'>B<!--C--></span>: w&nbsp;tej klasie dostępne są bezpośrednio &bdquo;wersje&rdquo;
przedefiniowane. Oczywiście składowe prywatne z&nbsp;klasy bazowej nie są
dostępne w&nbsp;zakresie klasy
<!--O--><span class='klasa'>B<!--C--></span>. Natomiast do składowych
nieprywatnych z&nbsp;klasy
<!--O--><span class='klasa'>A<!--C--></span>, przesłoniętych w&nbsp;klasie pochodnej

<!--O--><span class='klasa'>B<!--C--></span>, można się wciąż odwołać z&nbsp;zakresu klasy
<!--O--><span class='klasa'>B<!--C--></span>

poprzez jawną kwalifikację nazwy za pomocą operatora zakresu
klasowego, a&nbsp;więc, w&nbsp;naszym przypadku, poprzedzając nazwę
wskazaniem zakresu '
<FONT COLOR="#000000"><TT>A::</TT></FONT>'.

<P>
Rozpatrzmy przykład:
<A NAME="inher.cpp"></A>
<BR CLEAR='ALL'>
<div class='kodpro'><HR>
      <SPAN  CLASS="textbf">P<SPAN CLASS="arabic">159</SPAN>:</SPAN>
      <A NAME="tex2html167"
  HREF="source-files/inher.cpp">
<!--O--><span class='downl'>inher.cpp<!--C--></span></A>
<A NAME="26471"></A>
      &nbsp;&nbsp;&nbsp;&nbsp;<SMALL CLASS="SMALL">Widoczność przesłoniętych składowych</SMALL>
      <BR CLEAR="ALL">
<HR>
<pre><tt> <font SIZE="-2" color="black">     1.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;iostream&gt;</font>
 <font SIZE="-2" color="black">     2.  </font><b><font color="#0000FF">using</font></b> <b><font color="#0000FF">namespace</font></b> std<font color="#990000">;</font>
 <font SIZE="-2" color="black">     3.  </font>
 <font SIZE="-2" color="black">     4.  </font><b><font color="#0000FF">class</font></b> <font color="#008080">A</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">     5.  </font><b><font color="#0000FF">public</font></b><font color="#990000">:</font>
 <font SIZE="-2" color="black">     6.  </font>    <font color="#009900">int</font> <b><font color="#000000">fun</font></b><font color="#990000">(</font><font color="#009900">int</font> x<font color="#990000">)</font> <font color="#FF0000">{</font> <b><font color="#0000FF">return</font></b> x<font color="#990000">*</font>x<font color="#990000">;</font> <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">     7.  </font><font color="#FF0000">}</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">     8.  </font>
 <font SIZE="-2" color="black">     9.  </font><b><font color="#0000FF">class</font></b> <font color="#008080">B</font> <font color="#990000">:</font> <b><font color="#0000FF">private</font></b> A <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    10.  </font>    <font color="#009900">int</font> <b><font color="#000000">fun</font></b><font color="#990000">(</font><font color="#009900">int</font> x<font color="#990000">,</font> <font color="#009900">int</font> y<font color="#990000">)</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    11.  </font>        <b><font color="#0000FF">return</font></b> A<font color="#990000">::</font><b><font color="#000000">fun</font></b><font color="#990000">(</font>x<font color="#990000">)</font> <font color="#990000">+</font> y<font color="#990000">*</font>y<font color="#990000">;</font>
 <font SIZE="-2" color="black">    12.  </font>    <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    13.  </font><b><font color="#0000FF">public</font></b><font color="#990000">:</font>
 <font SIZE="-2" color="black">    14.  </font>    <font color="#009900">int</font> <b><font color="#000000">pub</font></b><font color="#990000">(</font><font color="#009900">int</font> x<font color="#990000">,</font> <font color="#009900">int</font> y<font color="#990000">)</font> <font color="#FF0000">{</font> <b><font color="#0000FF">return</font></b> <b><font color="#000000">fun</font></b><font color="#990000">(</font>x<font color="#990000">,</font>y<font color="#990000">);</font> <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    15.  </font><font color="#FF0000">}</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    16.  </font>
 <font SIZE="-2" color="black">    17.  </font><font color="#009900">int</font> <b><font color="#000000">main</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    18.  </font>    <font color="#008080">A</font> a<font color="#990000">;</font>
 <font SIZE="-2" color="black">    19.  </font>    <font color="#008080">B</font> b<font color="#990000">;</font>
 <font SIZE="-2" color="black">    20.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"a.fun(3)   = "</font> <font color="#990000">&lt;&lt;</font> a<font color="#990000">.</font><b><font color="#000000">fun</font></b><font color="#990000">(</font><font color="#993399">3</font><font color="#990000">)</font>   <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    21.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"b.pub(3,4) = "</font> <font color="#990000">&lt;&lt;</font> b<font color="#990000">.</font><b><font color="#000000">pub</font></b><font color="#990000">(</font><font color="#993399">3</font><font color="#990000">,</font><font color="#993399">4</font><font color="#990000">)</font> <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    22.  </font> <i><font color="#9A1900">// cout &lt;&lt; "b.fun(3,4) = " &lt;&lt; b.fun(3,4) &lt;&lt; endl;</font></i>
 <font SIZE="-2" color="black">    23.  </font><font color="#FF0000">}</font>
</tt></pre>
<hr>

</div>

W klasie
<!--O--><span class='klasa'>A<!--C--></span>
 funkcja
<!--O--><span class='funkcja'>fun<!--C--></span>
 jest publiczna. Klasa
<!--O--><span class='klasa'>B<!--C--></span>

dziedziczy z&nbsp;klasy
<!--O--><span class='klasa'>A<!--C--></span>, ale ogranicza dostępność składowych
odziedziczonych do
<!--O--><span class='klucz'>private<!--C--></span>. W klasie
<!--O--><span class='klasa'>B<!--C--></span>
 funkcja

<!--O--><span class='funkcja'>fun<!--C--></span>
 jest przesłaniana; ponadto klasa ta definiuje publiczną
funkcję
<!--O--><span class='funkcja'>pub<!--C--></span>. Wewnątrz funkcji
<!--O--><span class='funkcja'>pub<!--C--></span>
 użyta jest
nazwa
<!--O--><span class='funkcja'>fun<!--C--></span>. Czego ona dotyczy? Ponieważ funkcja
<!--O--><span class='funkcja'>pub<!--C--></span>

jest składową klasy
<!--O--><span class='klasa'>B<!--C--></span>, więc w&nbsp;jej zakresie nazwa

<!--O--><span class='funkcja'>fun<!--C--></span>
 odnosi się do wersji zdefiniowanej w&nbsp;tejże klasie, czyli
do funkcji zdefiniowanej w&nbsp;liniach&nbsp;10-12. W definicji tej funkcji
wywołana ma być funkcja
<!--O--><span class='funkcja'>fun<!--C--></span>, ale w&nbsp;wersji z&nbsp;klasy bazowej.
Ponieważ funkcja
<!--O--><span class='funkcja'>fun<!--C--></span>
 w&nbsp;klasie bazowej jest publiczna,
można ją wywołać z&nbsp;zakresu klasy pochodnej pod warunkiem, że
użyjemy nazwy kwalifikowanej (linia&nbsp;11). Gdybyśmy nie kwalifikowali
nazwy
<!--O--><span class='funkcja'>fun<!--C--></span>, to użyta zostałaby wersja z&nbsp;klasy
<!--O--><span class='klasa'>B<!--C--></span>, co
doprowadziłoby w&nbsp;naszym przypadku do nieskończonej rekursji; dzięki
kwalifikacji natomiast wywołana zostanie właściwa funkcja:
<PRE>
    a.fun(3)   = 9
    b.pub(3,4) = 25
</PRE>
Zauważmy, że na rzecz obiektu klasy
<!--O--><span class='klasa'>A<!--C--></span>
 możemy wywołać
funkcję
<!--O--><span class='funkcja'>fun<!--C--></span>
 (linia&nbsp;20), bo w&nbsp;tej klasie funkcja ta,
zdefiniowana w&nbsp;linii&nbsp;6, jest publiczna. Natomiast na rzecz obiektu
klasy
<!--O--><span class='klasa'>B<!--C--></span>
 (wykomentowana linia&nbsp;22) tego zrobić nie możemy, bo
w&nbsp;klasie
<!--O--><span class='klasa'>B<!--C--></span>
 funkcja
<!--O--><span class='funkcja'>fun<!--C--></span>
 jest prywatna. Możemy
natomiast wywołać publiczną funkcję
<!--O--><span class='funkcja'>pub<!--C--></span>, a&nbsp;ta, jako
metoda klasy
<!--O--><span class='klasa'>B<!--C--></span>, ma w&nbsp;swoim zakresie prywatną wersję funkcji

<!--O--><span class='funkcja'>fun<!--C--></span>
 zdefiniowaną w&nbsp;tej klasie.

<P>
Jak już mówiliśmy, obiekt klasy pochodnej jest obiektem klasy
bazowej, uzupełnionym ewentualnie przez dodatkowe składowe.
W tym
sensie może być w&nbsp;wielu sytuacjach traktowany jak gdyby był obiektem
klasy bazowej (tak jak w&nbsp;Javie<A NAME="25789"></A>
i&nbsp;innych językach obiektowych).

<P>
Na przykład wskaźnik lub referencja do obiektu klasy pochodnej
może być użyty tam, gdzie oczekiwany jest wskaźnik (referencja)
do obiektu klasy bazowej &mdash;&nbsp;wskazywanym obiektem będzie wówczas
podobiekt klasy bazowej zawarty w&nbsp;obiekcie klasy pochodnej.
Taka konwersja, zwana rzutowaniem
<FONT COLOR="#7b003e"><B>w górę</B></FONT><A NAME="25791"></A> (ang.&nbsp;<FONT COLOR="#7b003e"><I>upcasting</I></FONT>)
jest standardowa i&nbsp;może być wykonywana niejawnie.

<P>

<P>

<div class='wazne'>
Niejawne rzutowanie w&nbsp;górę zachodzi tylko jeśli klasa
    pochodna dziedziczy z&nbsp;klasy bazowej publicznie (ze specyfikatorem

<!--O--><span class='klucz'>public<!--C--></span>). W&nbsp;innych przypadkach takiej konwersji trzeba
    zażądać jawnie za pomocą operatora
<!--O--><span class='klucz'>static_cast<!--C--></span>

    lub
<!--O--><span class='klucz'>dynamic_cast<!--C--></span>.


</div>

<P>
Mechanizm, o&nbsp;którym wspomnieliśmy, ma dla programowania obiektowego
fundamentalne znaczenie i&nbsp;w dalszym ciągu znajdziemy wiele
przykładów na jego zastosowanie. Dzięki niemu:

<UL>
<LI>możemy przekazywać referencję do obiektu klasy pochodnej do
          konstruktora klasy bazowej, na przykład, aby utworzyć
          podobiekt klasy bazowej w&nbsp;czasie konstruowania obiektu klasy
          pochodnej;
</LI>
<LI>jeśli funkcja zwraca wskaźnik (referencję) do obiektu klasy
          bazowej, to w&nbsp;instrukcji
<!--O--><span class='klucz'>return<!--C--></span>
 można zwrócić
          wskaźnik (referencję) do obiektu klasy pochodnej;
</LI>
<LI>dla operatorów, w&nbsp;których parametrem jest referencja do
          obiektu klasy bazowej, nastąpi ich wywołanie, gdy jako
          argument (obiekt po prawej stronie operatora) pojawi się
          obiekt klasy pochodnej.
          Dla operatorów zdefiniowanych jako metody
          nie dotyczy to jednak argumentu domyślnego
<!--O--><span class='klucz'>this<!--C--></span>

          (wskaźnika do obiektu, na rzecz którego następuje
          wywołanie, czyli tego po lewej stronie operatora).
          Znaczy to, że jeśli w&nbsp;klasie
<!--O--><span class='klasa'>A<!--C--></span>
 przeciążyliśmy
          operator dodawania, a&nbsp;
<!--O--><span class='zmienna'>b<!--C--></span>
 jest obiektem klasy

<!--O--><span class='klasa'>B<!--C--></span>
 dziedziczącej z&nbsp;
<!--O--><span class='klasa'>A<!--C--></span>, to opracowanie
          wyrażenia '
<FONT COLOR="#000000"><TT>b+a</TT></FONT>' <FONT COLOR="#7b003e"><I>nie</I></FONT> spowoduje wywołania
          metody przeciążającej dodawanie z&nbsp;klasy
<!--O--><span class='klasa'>A<!--C--></span>, bo
          wywołanie jest na rzecz obiektu klasy pochodnej.
          Natomiast '
<FONT COLOR="#000000"><TT>a+b</TT></FONT>' zadziała, bo
<!--O--><span class='zmienna'>a<!--C--></span>
 jest
          typu
<!--O--><span class='klasa'>A<!--C--></span>, a&nbsp;dla argumentu
<!--O--><span class='zmienna'>b<!--C--></span>
 niejawna
          konwersja
<!--O--><span class='typ'>B&amp;<!--C--></span>
 <!-- MATH
 $\rightarrow$
 -->
<SPAN CLASS="MATH">&#8594;</SPAN>
<!--O--><span class='typ'>A&amp;<!--C--></span>
 zajdzie.
</LI>
</UL>
Konwersja w&nbsp;drugą stronę, od wskaźnika/referencji do obiektu
klasy bazowej do wskaźnika/referencji do obiektu klasy pochodnej musi
jednak być zawsze jawna; na przykład (dla klas polimorficznych,
o&nbsp;czym za chwilę) za pomocą operatora konwersji dynamicznej
(<!--O--><span class='klucz'>dynamic_cast<!--C--></span>), jak o&nbsp;tym wspominaliśmy
w&nbsp;rozdziale o <A HREF="node121.html#konw:dyn">konwersjach</A> . Taki typ konwersji nazywamy rzutowaniem
w&nbsp;<FONT COLOR="#7b003e"><B>dół</B></FONT><A NAME="25823"></A> (ang.&nbsp;<FONT COLOR="#7b003e"><I>downcasting</I></FONT>).
Nastąpi wtedy dynamicznie, czyli w&nbsp;trakcie wykonania programu,
sprawdzenie poprawności takiego rzutowania.

<P>
Zauważmy, że mówimy tu o&nbsp;wskaźnikach i&nbsp;referencjach, a&nbsp;nie
o&nbsp;konwersji samych obiektów. Na przykład, jeśli parametrem funkcji
jest <FONT COLOR="#7b003e"><I>obiekt</I></FONT> klasy bazowej
<!--O--><span class='klasa'>A<!--C--></span>
 (przekazywany przez wartość,
a&nbsp;nie przez wskaźnik lub referencję), to jako argumentu <FONT COLOR="#7b003e"><I>nie
powinniśmy</I></FONT> używać obiektu klasy pochodnej
<!--O--><span class='klasa'>B<!--C--></span>. Wynika to
choćby z faktu, że obiekty klasy pochodnej i&nbsp;bazowej zajmują na
stosie różną liczbę bajtów, a więc aby takie wywołanie
zrealizować obiekt musiałby zostać &bdquo;przycięty&rdquo; (do zawartego
w&nbsp;nim podobiektu typu
<!--O--><span class='klasa'>A<!--C--></span>), co czasem daje oczekiwane rezultaty,
a&nbsp;czasem zupełnie nieoczekiwane...

<P>

<P>
<BR>

<P>
Często zachodzi potrzeba definiowania  wskaźników lub referencji
do podobiektu klasy bazowej zawartego w&nbsp;obiekcie klasy pochodnej
lub odwrotnie. Niech
<!--O--><span class='klasa'>A<!--C--></span>
 będzie klasą bazową, a&nbsp;
<!--O--><span class='klasa'>B<!--C--></span>
 klasą
pochodną. Wtedy:

<UL>
<LI>jeśli
<!--O--><span class='zmienna'>pb<!--C--></span>
 jest wskaźnikiem typu
<!--O--><span class='typ'>B*<!--C--></span>

          na obiekt
<!--O--><span class='zmienna'>b<!--C--></span>
 klasy
<!--O--><span class='klasa'>B<!--C--></span>, to

<FONT COLOR="#000000"><TT>(A*)pb</TT></FONT> lub

<FONT COLOR="#000000"><TT>static_cast&lt;A*&gt;(pb)</TT></FONT>
          jest wskaźnikiem do podobiektu klasy
<!--O--><span class='klasa'>A<!--C--></span>
 zawartego w
          obiekcie
<!--O--><span class='zmienna'>b<!--C--></span>. Zamiast
<!--O--><span class='zmienna'>pb<!--C--></span>
 można oczywiście
          użyć równoważnie
<!--O--><span class='zmienna'>&amp;b<!--C--></span>;
</LI>
<LI>podobnie,

<FONT COLOR="#000000"><TT>(A&amp;)b</TT></FONT>
          lub

<FONT COLOR="#000000"><TT>static_cast&lt;A&amp;&gt;(b)</TT></FONT>
          <A NAME="25849"></A>
          jest referencją do tego podobiektu;
</LI>
<LI>jeśli
<!--O--><span class='zmienna'>pa<!--C--></span>
 jest wskaźnikiem typu
<!--O--><span class='typ'>A*<!--C--></span>
 do
          obiektu klasy
<!--O--><span class='klasa'>B<!--C--></span>, to

<FONT COLOR="#000000"><TT>(B*)pa</TT></FONT>
          lub

<FONT COLOR="#000000"><TT>dynamic_cast&lt;B*&gt;(pa)</TT></FONT>
          <A NAME="25857"></A>
          jest wskaźnikiem do obiektu typu
<!--O--><span class='klasa'>B<!--C--></span>. Aby użyć
          rzutowania dynamicznego, klasa
<!--O--><span class='klasa'>A<!--C--></span>
 powinna być
          polimorficzna, a&nbsp;więc zawierać przynajmniej jedną metodę
          wirtualną (wystarczy, że jest to na przykład destruktor
          &mdash;&nbsp;patrz dalsza część rozdziału);
</LI>
<LI>podobnie

<FONT COLOR="#000000"><TT>(B&amp;)(*pa)</TT></FONT>
          lub

<FONT COLOR="#000000"><TT>dynamic_cast&lt;B&amp;&gt;(*pa)</TT></FONT>
          jest referencją do tego obiektu.
</LI>
</UL>
Operowanie tymi konwersjami jest przydatne i&nbsp;konieczne zarówno przy
korzystaniu z&nbsp;polimorfizmu, jak i&nbsp;na przykład w&nbsp;konstruktorach
i&nbsp;przypisaniach definiowanych w&nbsp;klasach dziedziczących z&nbsp;innych klas.

<P>
Rozpatrzmy przykład ilustrujący różne tego rodzaju rzutowania.
<A NAME="cast.cpp"></A>
<BR CLEAR='ALL'>
<div class='kodpro'><HR>
      <SPAN  CLASS="textbf">P<SPAN CLASS="arabic">160</SPAN>:</SPAN>
      <A NAME="tex2html168"
  HREF="source-files/cast.cpp">
<!--O--><span class='downl'>cast.cpp<!--C--></span></A>
<A NAME="26544"></A>
      &nbsp;&nbsp;&nbsp;&nbsp;<SMALL CLASS="SMALL">Konwersje wiążące obiekt i&nbsp;podobiekt</SMALL>
      <BR CLEAR="ALL">
<HR>
<pre><tt> <font SIZE="-2" color="black">     1.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;iostream&gt;</font>
 <font SIZE="-2" color="black">     2.  </font><b><font color="#0000FF">using</font></b> <b><font color="#0000FF">namespace</font></b> std<font color="#990000">;</font>
 <font SIZE="-2" color="black">     3.  </font>
 <font SIZE="-2" color="black">     4.  </font><b><font color="#0000FF">struct</font></b> <font color="#008080">A</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">     5.  </font>    <font color="#009900">int</font> x<font color="#990000">;</font>
 <font SIZE="-2" color="black">     6.  </font>    <font color="#009900">int</font> y<font color="#990000">;</font>
 <font SIZE="-2" color="black">     7.  </font>    <b><font color="#000000">A</font></b><font color="#990000">()</font> <font color="#990000">:</font> <b><font color="#000000">x</font></b><font color="#990000">(</font><font color="#993399">1</font><font color="#990000">),</font> <b><font color="#000000">y</font></b><font color="#990000">(</font><font color="#993399">2</font><font color="#990000">)</font> <font color="#FF0000">{}</font>
 <font SIZE="-2" color="black">     8.  </font><font color="#FF0000">}</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">     9.  </font>
 <font SIZE="-2" color="black">    10.  </font><b><font color="#0000FF">struct</font></b> <font color="#008080">B</font> <font color="#990000">:</font> <b><font color="#0000FF">public</font></b> A <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    11.  </font>    <font color="#009900">int</font> x<font color="#990000">;</font>  <i><font color="#9A1900">// ????</font></i>
 <font SIZE="-2" color="black">    12.  </font><font color="#FF0000">}</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    13.  </font>
 <font SIZE="-2" color="black">    14.  </font><font color="#009900">int</font> <b><font color="#000000">main</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    15.  </font>    <font color="#008080">B</font> b<font color="#990000">,</font> <font color="#990000">*</font>pb <font color="#990000">=</font> <font color="#990000">&amp;</font>b<font color="#990000">;</font>
 <font SIZE="-2" color="black">    16.  </font>    b<font color="#990000">.</font>x <font color="#990000">=</font> <font color="#993399">11</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    17.  </font>    b<font color="#990000">.</font>y <font color="#990000">=</font> <font color="#993399">12</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    18.  </font>
 <font SIZE="-2" color="black">    19.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"b.x="</font> <font color="#990000">&lt;&lt;</font> b<font color="#990000">.</font>x        <font color="#990000">&lt;&lt;</font> <font color="#FF0000">" b.y="</font>
 <font SIZE="-2" color="black">    20.  </font>         <font color="#990000">&lt;&lt;</font> b<font color="#990000">.</font>y    <font color="#990000">&lt;&lt;</font> <font color="#FF0000">" b.A::x="</font> <font color="#990000">&lt;&lt;</font> b<font color="#990000">.</font>A<font color="#990000">::</font>x
 <font SIZE="-2" color="black">    21.  </font>         <font color="#990000">&lt;&lt;</font> <font color="#FF0000">" b.A::y="</font> <font color="#990000">&lt;&lt;</font> b<font color="#990000">.</font>A<font color="#990000">::</font>y <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    22.  </font>
 <font SIZE="-2" color="black">    23.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"</font><font color="#CC33CC">\n</font><font color="#FF0000">      pb-&gt;x="</font> <font color="#990000">&lt;&lt;</font>    pb <font color="#990000">-&gt;</font>x   <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    24.  </font>    cout <font color="#990000">&lt;&lt;</font>   <font color="#FF0000">"((A*)pb)-&gt;x="</font> <font color="#990000">&lt;&lt;</font> <font color="#990000">((</font>A<font color="#990000">*)</font>pb<font color="#990000">)-&gt;</font>x <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    25.  </font>    cout <font color="#990000">&lt;&lt;</font>   <font color="#FF0000">"        b.x="</font> <font color="#990000">&lt;&lt;</font>       b<font color="#990000">.</font>x   <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    26.  </font>    cout <font color="#990000">&lt;&lt;</font>   <font color="#FF0000">"  ((A&amp;)b).x="</font> <font color="#990000">&lt;&lt;</font> <font color="#990000">((</font>A<font color="#990000">&amp;)</font>b<font color="#990000">).</font>x   <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    27.  </font>    cout <font color="#990000">&lt;&lt;</font>   <font color="#FF0000">"((A*)&amp;b)-&gt;x="</font> <font color="#990000">&lt;&lt;</font> <font color="#990000">((</font>A<font color="#990000">*)&amp;</font>b<font color="#990000">)-&gt;</font>x <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    28.  </font>
 <font SIZE="-2" color="black">    29.  </font>    A<font color="#990000">*</font> pa <font color="#990000">=</font> <b><font color="#0000FF">new</font></b> B<font color="#990000">;</font>
 <font SIZE="-2" color="black">    30.  </font>    <font color="#990000">((</font>B<font color="#990000">&amp;)*</font>pa<font color="#990000">).</font>x <font color="#990000">=</font> <font color="#993399">11</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    31.  </font>
 <font SIZE="-2" color="black">    32.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"</font><font color="#CC33CC">\n</font><font color="#FF0000">    (*pa).x="</font> <font color="#990000">&lt;&lt;</font> <font color="#990000">(*</font>pa<font color="#990000">).</font>x     <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    33.  </font>    cout <font color="#990000">&lt;&lt;</font>   <font color="#FF0000">"((B&amp;)*pa).x="</font> <font color="#990000">&lt;&lt;</font> <font color="#990000">((</font>B<font color="#990000">&amp;)*</font>pa<font color="#990000">).</font>x <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    34.  </font>    cout <font color="#990000">&lt;&lt;</font>   <font color="#FF0000">"      pa-&gt;x="</font> <font color="#990000">&lt;&lt;</font>       pa<font color="#990000">-&gt;</font>x <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    35.  </font>    cout <font color="#990000">&lt;&lt;</font>   <font color="#FF0000">"((B*)pa)-&gt;x="</font> <font color="#990000">&lt;&lt;</font> <font color="#990000">((</font>B<font color="#990000">*)</font>pa<font color="#990000">)-&gt;</font>x <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    36.  </font>
 <font SIZE="-2" color="black">    37.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"</font><font color="#CC33CC">\n</font><font color="#FF0000">sizeof(b) = "</font> <font color="#990000">&lt;&lt;</font> <b><font color="#0000FF">sizeof</font></b> b <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    38.  </font>    <font color="#009900">int</font><font color="#990000">*</font> t <font color="#990000">=</font> <font color="#990000">(</font><font color="#009900">int</font><font color="#990000">*)</font> <font color="#990000">&amp;</font>b<font color="#990000">;</font>
 <font SIZE="-2" color="black">    39.  </font>    cout <font color="#990000">&lt;&lt;</font> t<font color="#990000">[</font><font color="#993399">0</font><font color="#990000">]</font> <font color="#990000">&lt;&lt;</font> <font color="#FF0000">" "</font> <font color="#990000">&lt;&lt;</font> t<font color="#990000">[</font><font color="#993399">1</font><font color="#990000">]</font> <font color="#990000">&lt;&lt;</font> <font color="#FF0000">" "</font> <font color="#990000">&lt;&lt;</font> t<font color="#990000">[</font><font color="#993399">2</font><font color="#990000">]</font> <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    40.  </font><font color="#FF0000">}</font>
</tt></pre>
<hr>

</div>

Klasa
<!--O--><span class='klasa'>A<!--C--></span>
 ma składowe
<!--O--><span class='zmienna'>x<!--C--></span>
 i&nbsp;
<!--O--><span class='zmienna'>y<!--C--></span>.
Dziedzicząca klasa
<!--O--><span class='klasa'>B<!--C--></span>
 definiuje pole o&nbsp;nazwie
<!--O--><span class='zmienna'>x<!--C--></span>

(linia&nbsp;11), więc zasłania składową
<!--O--><span class='zmienna'>x<!--C--></span>
 dziedziczoną
z
<!--O--><span class='klasa'>A<!--C--></span>
 (co, jak wspomnieliśmy, nie jest zalecane!).
W&nbsp;programie głównym tworzymy obiekt klasy
<!--O--><span class='klasa'>B<!--C--></span>. W liniach&nbsp;16-17
inicjujemy składowe tego obiektu. Zauważmy, że prócz
<!--O--><span class='zmienna'>x<!--C--></span>

i&nbsp;
<!--O--><span class='zmienna'>y<!--C--></span>
 w&nbsp;skład obiektu wchodzi też przesłonięta
składowa
<!--O--><span class='zmienna'>x<!--C--></span>
 odziedziczona z&nbsp;
<!--O--><span class='klasa'>A<!--C--></span>. Tak więc w&nbsp;zakresie
klasy
<!--O--><span class='klasa'>B<!--C--></span>
 nazwa
<!--O--><span class='zmienna'>x<!--C--></span>
 oznacza składową (o wartości 11)
zdefiniowaną w&nbsp;tej klasie, a&nbsp;nazwa kwalifikowana
<!--O--><span class='zmienna'>A::x<!--C--></span>

oznacza składową
<!--O--><span class='zmienna'>x<!--C--></span>
 (o wartości 1) odziedziczoną
z&nbsp;klasy
<!--O--><span class='klasa'>A<!--C--></span>. Tak więc
<!--O--><span class='zmienna'>b.x<!--C--></span>
 wynosi 11, ale

<!--O--><span class='zmienna'>b.A::x<!--C--></span>
 wynosi 1. Widać to z&nbsp;wydruku
<PRE>
    b: x=11 y=12 b.A::x=1 b.A::y=12

          pb-&gt;x=11
    ((A*)pb)-&gt;x=1
            b.x=11
      ((A&amp;)b).x=1
    ((A*)&amp;b)-&gt;x=1

        (*pa).x=1
    ((B&amp;)*pa).x=11
          pa-&gt;x=1
    ((B*)pa)-&gt;x=11

    sizeof(b) = 12
    1 12 11
</PRE>
Z wydruku widzimy też, że
jeśli
<!--O--><span class='zmienna'>pb<!--C--></span>
 zrzutujemy do typu
<!--O--><span class='typ'>A*<!--C--></span>, to wartością

<FONT COLOR="#000000"><TT>((A*)pb)-&gt;x</TT></FONT> jest 1, czyli wyłuskiwana jest wartość

<!--O--><span class='zmienna'>x<!--C--></span>
 z&nbsp;podobiektu klasy
<!--O--><span class='klasa'>A<!--C--></span>. Podobnie

<FONT COLOR="#000000"><TT>(A&amp;)b</TT></FONT>
jest referencją do tego podobiektu.

<P>
Ponieważ składowa
<!--O--><span class='zmienna'>y<!--C--></span>
 <FONT COLOR="#7b003e"><I>nie</I></FONT> została przesłonięta,
więc w&nbsp;zakresie klasy
<!--O--><span class='klasa'>B<!--C--></span>
 nazwy
<!--O--><span class='zmienna'>y<!--C--></span>
 i&nbsp;
<!--O--><span class='zmienna'>A::y<!--C--></span>

ozaczają tę samą zmienną.

<P>
W linii&nbsp;29 tworzymy obiekt klasy
<!--O--><span class='klasa'>B<!--C--></span>, ale wskaźnik do niego
zapisujemy w&nbsp;zmiennej
<!--O--><span class='zmienna'>pa<!--C--></span>
 typu
<!--O--><span class='typ'>A*<!--C--></span>. Na wydruku widzimy
teraz efekt rzutowania w&nbsp;dół:
<!--O--><span class='zmienna'>pa<!--C--></span>

jest wskaźnikiem typu
<!--O--><span class='typ'>A*<!--C--></span>
 wskazującym obiekt klasy
<!--O--><span class='klasa'>B<!--C--></span>.
Jej typem jest
<!--O--><span class='typ'>A*<!--C--></span>, a&nbsp;zatem
<FONT COLOR="#000000"><TT>pa-&gt;x</TT></FONT> odnosi się do
składowej
<!--O--><span class='zmienna'>x<!--C--></span>
 w&nbsp;podobiekcie klasy
<!--O--><span class='klasa'>A<!--C--></span>
 zawartym
w&nbsp;obiekcie
<!--O--><span class='zmienna'>b<!--C--></span>. Po zrzutowaniu do typu wskaźnikowego
<!--O--><span class='typ'>B*<!--C--></span>,
wskazywaną składową o&nbsp;nazwie
<!--O--><span class='zmienna'>x<!--C--></span>
 jest jednak składowa
o&nbsp;tej nazwie z&nbsp;zakresu&nbsp;
<!--O--><span class='klasa'>B<!--C--></span>
 (linia&nbsp;35).

<P>
W liniach 37-39 sprawdzamy jaki jest rozmiar obiektu typu
<!--O--><span class='klasa'>B<!--C--></span>.
Wynosi on 12 bajtów, co odpowiada trzem liczbom typu

<!--O--><span class='typ'>int<!--C--></span>
 &mdash;&nbsp;są to
<!--O--><span class='zmienna'>x<!--C--></span>
 i&nbsp;
<!--O--><span class='zmienna'>y<!--C--></span>
 z&nbsp;podobiektu klasy

<!--O--><span class='klasa'>A<!--C--></span>
 oraz&nbsp;
<!--O--><span class='zmienna'>x<!--C--></span>
 dodane w&nbsp;klasie
<!--O--><span class='klasa'>B<!--C--></span>
 (UWAGA: ten
fragment <FONT COLOR="#7b003e"><I>może</I></FONT> być zależny od architektury komputera i&nbsp;użytego
kompilatora!). Traktując adres obiektu jak adres tablicy liczb
całkowitych (linia&nbsp;38), "możemy się przekonać, że rzeczywiście
obiekt zawiera liczby 1, 12 (<!--O--><span class='zmienna'>x<!--C--></span>
 i&nbsp;
<!--O--><span class='zmienna'>y<!--C--></span>
 z&nbsp;podobiektu typu

<!--O--><span class='klasa'>A<!--C--></span>) oraz 11 (składowa
<!--O--><span class='zmienna'>x<!--C--></span>
 dodana w klasie
<!--O--><span class='klasa'>B<!--C--></span>).

<P>

<P>
<BR>

<P>
Bardzo ważną właściwością dziedziczenia jest to, że

<P>

<div class='wazne'>
Nie są dziedziczone konstruktory i&nbsp;destruktor.


</div>

<P>
Z drugiej strony, właśnie konstruktory i&nbsp;destruktory pełnią ważną
rolę, szczególnie dla klas zawierających pola wskaźnikowe,
kiedy logiczna zawartość obiektów nie wchodzi fizycznie w&nbsp;ich skład.
Zatem problemy związane z&nbsp;konstrukcją obiektów klas
pochodnych i&nbsp;ich destrukcją omówimy teraz osobno.

<P>

<DIV CLASS="navigation"><HR>
<A NAME="tex2html2550"
  HREF="node122.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="ikonypng/prev.png"></A>
<A NAME="tex2html2556"
  HREF="node122.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="ikonypng/up.png"></A>
<A NAME="tex2html2562"
  HREF="node124.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="ikonypng/next.png"></A>
<A NAME="tex2html2558"
  HREF="node1.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="ikonypng/contents.png"></A>
<A NAME="tex2html2560"
  HREF="node150.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="index"
 SRC="ikonypng/index.png"></A> <BR>
<B>Wstecz:</B> <A NAME="tex2html2551"
  HREF="node122.html">20. Dziedziczenie i polimorfizm</A>
<B>W g&#243;r&#281;:</B> <A NAME="tex2html2557"
  HREF="node122.html">20. Dziedziczenie i polimorfizm</A>
<B>Dalej:</B> <A NAME="tex2html2563"
  HREF="node124.html">20.2 Konstruktory i&nbsp;destruktory klas</A>
</DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<p style="text-align:right;"><I><font size=-2>T.R. Werner, 28 września 2018; 23:31</font></I></p>
</ADDRESS>
</BODY>
</HTML>
