<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
<TITLE>11.6 Argumenty referencyjne</TITLE>
<META NAME="description" CONTENT="11.6 Argumenty referencyjne">
<META NAME="keywords" CONTENT="PRG2CPP">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="LaTeX2HTML v2016">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="PRG2CPP.css">

<LINK REL="next" HREF="node66.html">
<LINK REL="previous" HREF="node64.html">
<LINK REL="up" HREF="node59.html">
<LINK REL="next" HREF="node66.html">
</HEAD>

<BODY >

<DIV CLASS="navigation">
<A NAME="tex2html1647"
  HREF="node64.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="ikonypng/prev.png"></A>
<A NAME="tex2html1653"
  HREF="node59.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="ikonypng/up.png"></A>
<A NAME="tex2html1659"
  HREF="node66.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="ikonypng/next.png"></A>
<A NAME="tex2html1655"
  HREF="node1.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="ikonypng/contents.png"></A>
<A NAME="tex2html1657"
  HREF="node150.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="index"
 SRC="ikonypng/index.png"></A> <BR>
<B>Wstecz:</B> <A NAME="tex2html1648"
  HREF="node64.html">11.5 Zmienna liczba argumentów</A>
<B>W g&#243;r&#281;:</B> <A NAME="tex2html1654"
  HREF="node59.html">11. Funkcje</A>
<B>Dalej:</B> <A NAME="tex2html1660"
  HREF="node66.html">11.7 Referencje jako wartości</A>
<BR> <HR> <P>
</DIV>
<!--End of Navigation Panel-->

<H1><A NAME="SECTION001260000000000000000"></A><A NAME="funk:funrefe"></A>
<BR>
<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">6</SPAN> Argumenty referencyjne
</H1>

<P>
Zarówno w&nbsp;roli argumentów, jak i&nbsp;wartości zwracanej mogą
występować referencje,<A NAME="11702"></A>
o&nbsp;których mówiliśmy
w&nbsp;rozdziale <A HREF="node21.html#typydan:odnosniki">o referencjach</A> .
Co to znaczy, jeśli parametr funkcji jest zadeklarowany jako
referencja?

<P>
Niech funkcja będzie zdefiniowana tak:
<pre><tt>       <font color="#009900">void</font> <b><font color="#000000">fun</font></b><font color="#990000">(</font><font color="#009900">int</font><font color="#990000">&amp;</font> k<font color="#990000">)</font> <font color="#FF0000">{</font>
           k <font color="#990000">=</font> k <font color="#990000">+</font> <font color="#993399">2</font><font color="#990000">;</font>
       <font color="#FF0000">}</font>
</tt></pre>
Taki zapis oznacza, że argument typu
<!--O--><span class='typ'>int<!--C--></span>
 zostanie przesłany do
funkcji przez referencję<A NAME="11712"></A><A NAME="11713"></A>
(referencję).  Jeśli wywołamy tę funkcję podając jako
argument pewną zmienną typu
<!--O--><span class='typ'>int<!--C--></span>, to w&nbsp;czasie wykonania
funkcji nazwa parametru
<!--O--><span class='zmienna'>k<!--C--></span>
 będzie <FONT COLOR="#7b003e"><I>inną nazwą</I></FONT>
dokładnie <FONT COLOR="#7b003e"><I>tej samej</I></FONT> zmiennej. A&nbsp;więc nie będzie kopiowania
wartości na stos: zmienna lokalna w&nbsp;funkcji w&nbsp;ogóle nie będzie
tworzona, nazwa
<!--O--><span class='zmienna'>k<!--C--></span>
 będzie odnosić się do <FONT COLOR="#7b003e"><I>oryginału</I></FONT> zmiennej
będącej argumentem wywołania. Jeśli powyższą funkcję wywołamy
tak:
<pre><tt>       <font color="#009900">int</font> m <font color="#990000">=</font> <font color="#993399">1</font><font color="#990000">;</font>
       <b><font color="#000000">fun</font></b><font color="#990000">(</font>m<font color="#990000">);</font>
       cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"m = "</font> <font color="#990000">&lt;&lt;</font> m <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
</tt></pre>
to wewnątrz funkcji nazwa
<!--O--><span class='zmienna'>k<!--C--></span>
 będzie inną nazwą tej
zmiennej,
która w&nbsp;programie wywołującym nazywa się
<!--O--><span class='zmienna'>m<!--C--></span>. Ta właśnie
zmienna zostanie przez funkcję powiększona o&nbsp;dwa. Zatem po wykonaniu
funkcji zmienna
<!--O--><span class='zmienna'>m<!--C--></span>
 w&nbsp;funkcji wywołującej będzie
zmieniona &mdash;&nbsp;jej wartość wynosić będzie teraz trzy!

<P>
Zauważmy, że samo wywołanie funkcji wygląda tak jak normalne
wywołanie przez wartość. Przy wywołaniu przez wartość jednak to
kopia wartości
<!--O--><span class='zmienna'>m<!--C--></span>
 byłaby przypisana do <FONT COLOR="#7b003e"><I>lokalnej</I></FONT> dla
funkcji zmiennej
<!--O--><span class='zmienna'>k<!--C--></span>. Modyfikacje tej lokalnej zmiennej nie
odbiłyby się w&nbsp;żaden sposób na wartości oryginału, czyli
zmiennej
<!--O--><span class='zmienna'>m<!--C--></span>
 z&nbsp;funkcji wywołującej.

<P>
Fakt, że patrząc na wywołanie funkcji nie jesteśmy
w&nbsp;stanie stwierdzić, czy jest to wywołanie przez wartość czy przez
referencję, jest dość nieszczęśliwy: może prowadzić do błędnej
interpretacji kodu, jeśli nie sprawdzi się deklaracji lub definicji
funkcji. Dlatego nie należy stosować takiej formy wywołania bez
potrzeby. Z drugiej strony, w&nbsp;niektórych sytuacjach jest to sposób
najwygodniejszy, a&nbsp;czasem wręcz konieczny.

<P>
Parametr zadeklarowany jako referencyjny jest inną nazwą zmiennej
przekazanej jako argument. Zatem ta zmienna musi istnieć &mdash;&nbsp;jak
podkreślaliśmy, w&nbsp;funkcji <FONT COLOR="#7b003e"><I>nie jest</I></FONT> tworzona zmienna lokalna.

<P>
Co jednak będzie, jeśli jako argumentu użyjemy literału lub wyrażenia
o&nbsp;określonej, co prawda, wartości, ale nie będącego l-wartością
istniejącej zmiennej? Albo, co będzie, jeśli przekażemy jako argument
l-wartość istniejącej zmiennej, ale innego typu niż ten zadeklarowany
na liście parametrów funkcji? Zauważmy bowiem, że nie może tu być mowy
o&nbsp;niejawnych konwersjach: identyfikator zadeklarowany jako referencja
skojarzona ze zmienną typu
<!--O--><span class='typ'>double<!--C--></span>
 nie może przecież być
&bdquo;inną nazwą&rdquo; zmiennej typu
<!--O--><span class='typ'>int<!--C--></span>. Doprowadziłoby to szybko do
kompletnego chaosu.

<P>
Zatem w&nbsp;obu przypadkach kompilator wykryje błąd. Jest jednak
odstępstwo od tej reguły. Jeśli parametr referencyjny jest
zadeklarowany z&nbsp;modyfikatorem
<!--O--><span class='klucz'>const<!--C--></span>, takie wywołanie
jest dopuszczalne. Ponieważ jednak zmienna lokalna nie jest
dla parametrów referencyjnych tworzona, zostanie utworzona zmienna
tymczasowa odpowiedniego typu i&nbsp;nazwa parametru w&nbsp;funkcji będzie inną
nazwą tej zmiennej tymczasowej. Zauważmy, że to <FONT COLOR="#7b003e"><I>nie</I></FONT> doprowadzi
do chaosu: skoro parametr był
<!--O--><span class='klucz'>const<!--C--></span>, czyli <FONT COLOR="#7b003e"><I>'read-only'</I></FONT>,
to i&nbsp;tak nie była możliwa zmiana wartości argumentu, zatem żadnych
nieprzewidzianych skutków ubocznych taka konstrukcja nie powinna
spowodować.

<P>
Parametry referencyjne to wygodny sposób przekazywania do funkcji
obiektów o&nbsp;znacznych rozmiarach. Oczywiście zmienne typów
wbudowanych są małe, ale zmienne typów (klas) definiowanych przez
autora programu mogą być i&nbsp;bywają bardzo duże. Przekazywanie przez
wartość powodowałoby konieczność kopiowania ich na stos, tworzenia
zmiennych lokalnych itd. Użycie referencji eliminuje te niedogodności.
Z&nbsp;drugiej strony, często nie jest naszą intencją, aby funkcja
zmodyfikowała zmienną przesłaną jej przez referencję jako argument.
Pamiętamy bowiem, że funkcja ma wtedy dostęp do oryginału, a&nbsp;nie do kopii
wartości. Przed taką niezamierzoną zmianą możemy się uchronić deklarując
parametr referencyjny z&nbsp;modyfikatorem
<!--O--><span class='klucz'>const<!--C--></span>; zmienna będąca
argumentem wywołania nie musi wtedy wcale być ustalona &mdash;&nbsp;
skojarzenie argumentu typu
<!--O--><span class='typ'>Typ<!--C--></span>
 z&nbsp;parametrem typu
<!--O--><span class='typ'>const Typ&amp;<!--C--></span>

jest dopuszczalne (jest to prawidłowa, trywialna konwersja niejawna:
patrz
rozdział <A HREF="node57.html#konwporz:konwersje">o konwersjach</A> ).

<P>
Inna sytuacja, gdy argumenty referencyjne przydają się, zachodzi
wtedy, gdy właśnie zależy nam na tym, aby zmienna przekazywana do
funkcji zmieniła swoją wartość. Na przykład chcielibyśmy, aby
funkcja obliczyła i&nbsp;zwróciła jakieś dwie (albo więcej) wartości:
poprzez normalny mechanizm zwracania wartości za pomocą

<!--O--><span class='klucz'>return<!--C--></span>
 możemy otrzymać jedną z&nbsp;nich, ale jak dostać drugą?
Można to łatwo rozwiązać dzięki parametrom referencyjnym.
Oczywiście, inną możliwością jest użycie wskaźników:
posyłamy do funkcji poprzez argument <SPAN  CLASS="textit">adres</SPAN> zmiennej, którą
chcemy w&nbsp;funkcji zmienić. Ten adres zostanie przesłany przez
wartość, a&nbsp;więc przesłana zostanie jego kopia, ale sam adres będzie
wskazywał na istniejącą zmienną z&nbsp;funkcji wywołującej, a&nbsp;więc
funkcja wołana będzie miała do niej dostęp. Zatem będzie mogła wartość
tej zmiennej zmodyfikować.

<P>
Różne sposoby przesyłania argumentów do funkcji
ilustruje poniższy program:
<BR><A NAME="vrp.cpp"></A>
<BR CLEAR='ALL'>
<div class='kodpro'><HR>
      <SPAN  CLASS="textbf">P<SPAN CLASS="arabic">70</SPAN>:</SPAN>
      <A NAME="tex2html76"
  HREF="source-files/vrp.cpp">
<!--O--><span class='downl'>vrp.cpp<!--C--></span></A>
<A NAME="12930"></A>
      &nbsp;&nbsp;&nbsp;&nbsp;<SMALL CLASS="SMALL">Przekazywanie argumentu
                  przez wartość, referencję i&nbsp;wskaźnik</SMALL>
      <BR CLEAR="ALL">
<HR>
<pre><tt> <font SIZE="-2" color="black">     1.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;iostream&gt;</font>
 <font SIZE="-2" color="black">     2.  </font><b><font color="#0000FF">using</font></b> <b><font color="#0000FF">namespace</font></b> std<font color="#990000">;</font>
 <font SIZE="-2" color="black">     3.  </font>
 <font SIZE="-2" color="black">     4.  </font><font color="#009900">void</font> <b><font color="#000000">fun</font></b><font color="#990000">(</font><font color="#009900">int</font><font color="#990000">,</font> <font color="#009900">int</font><font color="#990000">&amp;,</font> <font color="#009900">int</font><font color="#990000">*);</font>
 <font SIZE="-2" color="black">     5.  </font>
 <font SIZE="-2" color="black">     6.  </font><font color="#009900">int</font> <b><font color="#000000">main</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">     7.  </font>    <font color="#009900">int</font> a <font color="#990000">=</font> <font color="#993399">1</font><font color="#990000">,</font> b <font color="#990000">=</font> <font color="#993399">2</font><font color="#990000">,</font> c <font color="#990000">=</font> <font color="#993399">3</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">     8.  </font>
 <font SIZE="-2" color="black">     9.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"Przed: a = "</font> <font color="#990000">&lt;&lt;</font> a <font color="#990000">&lt;&lt;</font> <font color="#FF0000">" b = "</font> <font color="#990000">&lt;&lt;</font> b
 <font SIZE="-2" color="black">    10.  </font>                          <font color="#990000">&lt;&lt;</font> <font color="#FF0000">" c = "</font> <font color="#990000">&lt;&lt;</font> c <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    11.  </font>    <b><font color="#000000">fun</font></b><font color="#990000">(</font>a<font color="#990000">,</font> b<font color="#990000">,</font> <font color="#990000">&amp;</font>c<font color="#990000">);</font>
 <font SIZE="-2" color="black">    12.  </font>
 <font SIZE="-2" color="black">    13.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"Po   : a = "</font> <font color="#990000">&lt;&lt;</font> a <font color="#990000">&lt;&lt;</font> <font color="#FF0000">" b = "</font> <font color="#990000">&lt;&lt;</font> b
 <font SIZE="-2" color="black">    14.  </font>                          <font color="#990000">&lt;&lt;</font> <font color="#FF0000">" c = "</font> <font color="#990000">&lt;&lt;</font> c <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    15.  </font><font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    16.  </font>
 <font SIZE="-2" color="black">    17.  </font><font color="#009900">void</font> <b><font color="#000000">fun</font></b><font color="#990000">(</font><font color="#009900">int</font> x<font color="#990000">,</font> <font color="#009900">int</font><font color="#990000">&amp;</font> y<font color="#990000">,</font> <font color="#009900">int</font><font color="#990000">*</font> z<font color="#990000">)</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    18.  </font>    x <font color="#990000">=</font> <font color="#993399">2</font><font color="#990000">*</font>x<font color="#990000">;</font>
 <font SIZE="-2" color="black">    19.  </font>    y <font color="#990000">=</font> <font color="#993399">3</font><font color="#990000">*</font>y<font color="#990000">;</font>
 <font SIZE="-2" color="black">    20.  </font>   <font color="#990000">*</font>z <font color="#990000">=</font> <font color="#993399">4</font><font color="#990000">*(*</font>z<font color="#990000">);</font>
 <font SIZE="-2" color="black">    21.  </font><font color="#FF0000">}</font>
</tt></pre>
<hr>

</div>

<P>
Pierwszy argument przesłany jest przez wartość, a&nbsp;więc
zmiana wartości zmiennej <SPAN  CLASS="textit">lokalnej</SPAN>
<!--O--><span class='zmienna'>x<!--C--></span>

wewnątrz funkcji nie odbije się na wartości zmiennej
<!--O--><span class='zmienna'>a<!--C--></span>

w&nbsp;funkcji
<!--O--><span class='funkcja'>main<!--C--></span>. Drugi argument przesyłany jest przez
odniesienie (referencję), a&nbsp;więc w&nbsp;funkcji identyfikator
<!--O--><span class='zmienna'>y<!--C--></span>

oznacza dokładnie tę samą zmienną, która w&nbsp;funkcji
<!--O--><span class='funkcja'>main<!--C--></span>

nazywa się
<!--O--><span class='zmienna'>b<!--C--></span>. Ponieważ funkcja modyfikuje wartość

<!--O--><span class='zmienna'>y<!--C--></span>, więc automatycznie zmieniona jest i&nbsp;wartość
zmiennej
<!--O--><span class='zmienna'>b<!--C--></span>
 w&nbsp;funkcji
<!--O--><span class='funkcja'>main<!--C--></span>.
Trzeci argument przekazywany jest przez wskaźnik. Odpowiedni parametr
funkcji
<!--O--><span class='funkcja'>fun<!--C--></span>
 zadeklarowany jest jako typu
<!--O--><span class='typ'>int*<!--C--></span>.
Jest to wskaźnik do
<!--O--><span class='typ'>int<!--C--></span>, a&nbsp;więc funkcja spodziewa się
otrzymania (przez wartość) <SPAN  CLASS="textit">adresu</SPAN> zmiennej typu
<!--O--><span class='typ'>int<!--C--></span>.
Dlatego trzecim argumentem wywołania jest <SPAN  CLASS="textit">adres</SPAN>
zmiennej
<!--O--><span class='zmienna'>c<!--C--></span>
 (czyli wartość wyrażenia
<!--O--><span class='zmienna'>&amp;c<!--C--></span>).
Wewnątrz funkcji wyrażenie
<!--O--><span class='zmienna'>*z<!--C--></span>
 oznacza zmienną wskazywaną
przez
<!--O--><span class='zmienna'>z<!--C--></span>, ale
<!--O--><span class='zmienna'>z<!--C--></span>
 zawiera przekazany jej adres zmiennej

<!--O--><span class='zmienna'>c<!--C--></span>
 z&nbsp;programu głównego; zatem
<!--O--><span class='zmienna'>*z<!--C--></span>
 w&nbsp;funkcji jest
tym samym co
<!--O--><span class='zmienna'>c<!--C--></span>
 w&nbsp;programie głównym &mdash;&nbsp;w&nbsp;ten sposób
modyfikacja
<!--O--><span class='zmienna'>*z<!--C--></span>
 modyfikuje oryginał, czyli
zmienną
<!--O--><span class='zmienna'>c<!--C--></span>
 w&nbsp;programie głównym:
<PRE>
    Przed: a = 1 b = 2 c = 3
    Po   : a = 1 b = 6 c = 12
</PRE>

<P>
Jeśli nazwa parametru typu referencyjnego oznacza w&nbsp;funkcji tę samą
zmienną, która została użyta jako odpowiedni argument podczas jej
wywołania, to co będzie, jeśli parametrem tym jest referencja do
tablicy? Czy wewnątrz funkcji znany na przykład będzie wymiar
tej tablicy, tak jak jest znany w&nbsp;tej funkcji, gdzie tablica
była deklarowana? Odpowiedź jest twierdząca. Spójrzmy na
następujący przykład:
<BR><A NAME="tabref.cpp"></A>
<BR CLEAR='ALL'>
<div class='kodpro'><HR>
      <SPAN  CLASS="textbf">P<SPAN CLASS="arabic">71</SPAN>:</SPAN>
      <A NAME="tex2html77"
  HREF="source-files/tabref.cpp">
<!--O--><span class='downl'>tabref.cpp<!--C--></span></A>
<A NAME="12939"></A>
      &nbsp;&nbsp;&nbsp;&nbsp;<SMALL CLASS="SMALL">Referencja do tablicy</SMALL>
      <BR CLEAR="ALL">
<HR>
<pre><tt> <font SIZE="-2" color="black">     1.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;iostream&gt;</font>
 <font SIZE="-2" color="black">     2.  </font><b><font color="#0000FF">using</font></b> <b><font color="#0000FF">namespace</font></b> std<font color="#990000">;</font>
 <font SIZE="-2" color="black">     3.  </font>
 <font SIZE="-2" color="black">     4.  </font><font color="#009900">void</font> <b><font color="#000000">funtab</font></b><font color="#990000">(</font><font color="#009900">double</font><font color="#990000">[]);</font>                      <span class="ding">&#x278A;</span>
 <font SIZE="-2" color="black">     5.  </font><font color="#009900">void</font> <b><font color="#000000">funref</font></b><font color="#990000">(</font><font color="#009900">double</font> <font color="#990000">(&amp;)[</font><font color="#993399">6</font><font color="#990000">]);</font>                 <span class="ding">&#x278B;</span>
 <font SIZE="-2" color="black">     6.  </font>
 <font SIZE="-2" color="black">     7.  </font><font color="#009900">int</font> <b><font color="#000000">main</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">     8.  </font>    <font color="#009900">double</font> tab<font color="#990000">[]</font> <font color="#990000">=</font> <font color="#FF0000">{</font><font color="#993399">1</font><font color="#990000">,</font><font color="#993399">2</font><font color="#990000">,</font><font color="#993399">3</font><font color="#990000">,</font><font color="#993399">4</font><font color="#990000">,</font><font color="#993399">5</font><font color="#990000">,</font><font color="#993399">6</font><font color="#FF0000">}</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">     9.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"Wymiar double : "</font> <font color="#990000">&lt;&lt;</font> <b><font color="#0000FF">sizeof</font></b><font color="#990000">(</font><font color="#009900">double</font><font color="#990000">)</font>  <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    10.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"Wymiar double*: "</font> <font color="#990000">&lt;&lt;</font> <b><font color="#0000FF">sizeof</font></b><font color="#990000">(</font><font color="#009900">double</font><font color="#990000">*)</font> <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    11.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"Wymiar tab w main: "</font> <font color="#990000">&lt;&lt;</font> <b><font color="#0000FF">sizeof</font></b><font color="#990000">(</font>tab<font color="#990000">)</font>  <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    12.  </font>    <b><font color="#000000">funtab</font></b><font color="#990000">(</font>tab<font color="#990000">);</font>
 <font SIZE="-2" color="black">    13.  </font>    <b><font color="#000000">funref</font></b><font color="#990000">(</font>tab<font color="#990000">);</font>                            <span class="ding">&#x278C;</span>
 <font SIZE="-2" color="black">    14.  </font><font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    15.  </font>
 <font SIZE="-2" color="black">    16.  </font><font color="#009900">void</font> <b><font color="#000000">funtab</font></b><font color="#990000">(</font><font color="#009900">double</font> t<font color="#990000">[])</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    17.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"Wymiar t w funtab: "</font> <font color="#990000">&lt;&lt;</font> <b><font color="#0000FF">sizeof</font></b><font color="#990000">(</font>t<font color="#990000">)</font> <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    18.  </font><font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    19.  </font>
 <font SIZE="-2" color="black">    20.  </font><font color="#009900">void</font> <b><font color="#000000">funref</font></b><font color="#990000">(</font><font color="#009900">double</font> <font color="#990000">(&amp;</font>t<font color="#990000">)[</font><font color="#993399">6</font><font color="#990000">])</font> <font color="#FF0000">{</font>               <span class="ding">&#x278D;</span>
 <font SIZE="-2" color="black">    21.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"Wymiar t w funref: "</font> <font color="#990000">&lt;&lt;</font> <b><font color="#0000FF">sizeof</font></b><font color="#990000">(</font>t<font color="#990000">)</font> <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    22.  </font><font color="#FF0000">}</font>
</tt></pre>
<hr>

</div>

<P>
Parametrem funkcji
<!--O--><span class='funkcja'>funtab<!--C--></span>
 zadeklarowanej w&nbsp;linii&nbsp;<span class="ding">&#x278A;</span> jest
tablica, czyli tak naprawdę wskaźnik do początku tej tablicy. Wewnątrz
funkcji wymiar tablicy jest nieznany, zmienna
<!--O--><span class='zmienna'>t<!--C--></span>
 jest typu

<!--O--><span class='typ'>double*<!--C--></span>
 i&nbsp;jej rozmiar wynosi&nbsp;4 (lub&nbsp;8). Aby wymiar stał się znany,
musielibyśmy przesłać go jako osobny argument. Parametrem funkcji

<!--O--><span class='funkcja'>funref<!--C--></span>
 (zadeklarowanej w&nbsp;linii&nbsp;<span class="ding">&#x278B;</span>)
jest <FONT COLOR="#7b003e"><I>referencja</I></FONT> do tablicy.<A NAME="11786"></A>
Zauważmy tu deklarację: '
<FONT COLOR="#000000"><TT>double (&amp;)[6]</TT></FONT>' jest tu nazwą typu
<SPAN  CLASS="textit">referencja do sześcioelementowej tablicy elementów
typu
<!--O--><span class='typ'>double<!--C--></span>.</SPAN> Nawias jest tu konieczny; gdyby go nie było, to
typem byłaby <SPAN  CLASS="textit">sześcioelementowa tablica odniesień (referencji) do
zmiennych typu
<!--O--><span class='typ'>double<!--C--></span></SPAN> &mdash;&nbsp;coś takiego w&nbsp;ogóle nie istnieje!

<P>

<P>

<div class='wazne'>
Nie istnieje typ <FONT COLOR="#7b003e"><I>tablica odniesień.</I></FONT>


</div>

<P>
Podobnie w&nbsp;linii&nbsp;<span class="ding">&#x278D;</span> '
<FONT COLOR="#000000"><TT>double (&amp;t)[6]</TT></FONT>' oznacza
<SPAN  CLASS="textit">
<!--O--><span class='zmienna'>t<!--C--></span>
 jest referencją do sześcioelementowej
tablicy elementów typu
<!--O--><span class='typ'>double<!--C--></span></SPAN>, czyli inaczej:
<SPAN  CLASS="textit">identyfikator
<!--O--><span class='zmienna'>t<!--C--></span>
 jest inną nazwą
sześcioelementowej tablicy elementów typu
<!--O--><span class='typ'>double<!--C--></span>,
która istnieje w&nbsp;funkcji wołającej i&nbsp;została tam użyta jako
argument wywołania</SPAN>. Zauważmy, że wymiar <FONT COLOR="#7b003e"><I>musi</I></FONT> być podany:
tablica czteroelementowa to nie to samo, co tablica
pięcioelementowa. Dlatego w&nbsp;tym przypadku funkcja

<!--O--><span class='funkcja'>tabref<!--C--></span>
 <FONT COLOR="#7b003e"><I>zna</I></FONT> wymiar tablicy:
<PRE>
    Wymiar double : 8
    Wymiar double*: 8
    Wymiar tab w main: 48
    Wymiar t w funtab: 8
    Wymiar t w funref: 48
</PRE>
Nie oznacza to jednak, że rozwiązaliśmy problem przekazywania
rozmiaru tablicy do funkcji &bdquo;żeby było tak jak w&nbsp;Javie&rdquo;:
<A NAME="11803"></A> zauważmy bowiem, że argumentem wywołania
funkcji
<!--O--><span class='funkcja'>funref<!--C--></span>
 może być <FONT COLOR="#7b003e"><I>wyłącznie</I></FONT> tablica
sześcioelementowa! Spróbujmy zmienić wymiar tablicy
<!--O--><span class='zmienna'>tab<!--C--></span>

przez dodanie na przykład jednego elementu: funkcji
<!--O--><span class='funkcja'>funtab<!--C--></span>

to nie przeszkadza, ale wywołanie z&nbsp;linii&nbsp;<span class="ding">&#x278C;</span> w&nbsp;ogóle się nie
skompiluje!

<P>

<DIV CLASS="navigation"><HR>
<A NAME="tex2html1647"
  HREF="node64.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="ikonypng/prev.png"></A>
<A NAME="tex2html1653"
  HREF="node59.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="ikonypng/up.png"></A>
<A NAME="tex2html1659"
  HREF="node66.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="ikonypng/next.png"></A>
<A NAME="tex2html1655"
  HREF="node1.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="ikonypng/contents.png"></A>
<A NAME="tex2html1657"
  HREF="node150.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="index"
 SRC="ikonypng/index.png"></A> <BR>
<B>Wstecz:</B> <A NAME="tex2html1648"
  HREF="node64.html">11.5 Zmienna liczba argumentów</A>
<B>W g&#243;r&#281;:</B> <A NAME="tex2html1654"
  HREF="node59.html">11. Funkcje</A>
<B>Dalej:</B> <A NAME="tex2html1660"
  HREF="node66.html">11.7 Referencje jako wartości</A>
</DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<p style="text-align:right;"><I><font size=-2>T.R. Werner, 28 września 2018; 23:31</font></I></p>
</ADDRESS>
</BODY>
</HTML>
