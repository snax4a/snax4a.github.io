<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
<TITLE>11.2 Deklaracje i&nbsp;definicje funkcji</TITLE>
<META NAME="description" CONTENT="11.2 Deklaracje i&nbsp;definicje funkcji">
<META NAME="keywords" CONTENT="PRG2CPP">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="LaTeX2HTML v2016">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="PRG2CPP.css">

<LINK REL="next" HREF="node62.html">
<LINK REL="previous" HREF="node60.html">
<LINK REL="up" HREF="node59.html">
<LINK REL="next" HREF="node62.html">
</HEAD>

<BODY >

<DIV CLASS="navigation">
<A NAME="tex2html1591"
  HREF="node60.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="ikonypng/prev.png"></A>
<A NAME="tex2html1597"
  HREF="node59.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="ikonypng/up.png"></A>
<A NAME="tex2html1603"
  HREF="node62.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="ikonypng/next.png"></A>
<A NAME="tex2html1599"
  HREF="node1.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="ikonypng/contents.png"></A>
<A NAME="tex2html1601"
  HREF="node150.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="index"
 SRC="ikonypng/index.png"></A> <BR>
<B>Wstecz:</B> <A NAME="tex2html1592"
  HREF="node60.html">11.1 Wstęp</A>
<B>W g&#243;r&#281;:</B> <A NAME="tex2html1598"
  HREF="node59.html">11. Funkcje</A>
<B>Dalej:</B> <A NAME="tex2html1604"
  HREF="node62.html">11.3 Wywołanie funkcji</A>
<BR> <HR> <P>
</DIV>
<!--End of Navigation Panel-->

<H1><A NAME="SECTION001220000000000000000"></A>
     <A NAME="funk:dekl"></A>
<BR>
<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">2</SPAN> Deklaracje i&nbsp;definicje funkcji
</H1>

<P>
Definicja lub deklaracja dostarcza kompilatorowi informacji
o&nbsp;funkcji: jaki jest jej typ zwracany, jaka jest liczba parametrów,
jaki jest typ parametrów itd. W ten sposób, za każdym razem, gdy
w&nbsp;dalszej części tekstu programu pojawia się użycie tej funkcji,
kompilator może sprawdzić

<UL>
<LI>o&nbsp;którą z&nbsp;funkcji o&nbsp;tej samej nazwie chodzi (może być
          wiele funkcji o&nbsp;tej samej nazwie);
</LI>
<LI>czy wywołanie funkcji jest prawidłowe; czy na przykład
          ilość i&nbsp;typ argumentów odpowiada ilości i&nbsp;typom
          parametrów, czy typ wartości zwracanej
          przez funkcje jest w&nbsp;danym miejscu programu
          akceptowalny,&nbsp;itd. Jest to konieczne, na przykład, aby
          zdecydować, czy będa potrzebne konwersje argumentów lub
          wartości zwracanej.
</LI>
</UL>
W razie niezgodności kompilacja zostanie przerwana, co jest lepsze
niż utworzenie bezsensownego kodu wynikowego. Jest to cecha
C++; w&nbsp;tradycyjnym C wymogu wcześniejszego deklarowania funkcji
nie było, co powodowało moc kłopotów przy testowaniu i
uruchamianiu programów.

<P>
Dlaczego definicja <SPAN  CLASS="textit">lub</SPAN> deklaracja, co to w&nbsp;ogóle jest deklaracja
funkcji i&nbsp;do czego się przydaje?

<P>
Wyobraźmy sobie następującą sytuację: definiujemy kolejno
dwie funkcje,
<!--O--><span class='funkcja'>fun1<!--C--></span>
 i&nbsp;
<!--O--><span class='funkcja'>fun2<!--C--></span>. Funkcja
<!--O--><span class='funkcja'>fun1<!--C--></span>

wywołuje w&nbsp;swej treści funkcję
<!--O--><span class='funkcja'>fun2<!--C--></span>
 i&nbsp;odwrotnie,
funkcja
<!--O--><span class='funkcja'>fun2<!--C--></span>
 wywołuje w&nbsp;swej treści funkcję
<!--O--><span class='funkcja'>fun1<!--C--></span>:
<pre><tt> <font SIZE="-2" color="black">     1.  </font>    <font color="#009900">void</font> <b><font color="#000000">fun1</font></b><font color="#990000">(</font><font color="#009900">int</font> k<font color="#990000">)</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">     2.  </font>        <i><font color="#9A1900">// ...</font></i>
 <font SIZE="-2" color="black">     3.  </font>        <b><font color="#000000">fun2</font></b><font color="#990000">(</font>k<font color="#990000">)</font>
 <font SIZE="-2" color="black">     4.  </font>        <i><font color="#9A1900">// ...</font></i>
 <font SIZE="-2" color="black">     5.  </font>    <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">     6.  </font>
 <font SIZE="-2" color="black">     7.  </font>    <font color="#009900">void</font> <b><font color="#000000">fun2</font></b><font color="#990000">(</font><font color="#009900">int</font> m<font color="#990000">)</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">     8.  </font>        <i><font color="#9A1900">// ...</font></i>
 <font SIZE="-2" color="black">     9.  </font>        <b><font color="#000000">fun1</font></b><font color="#990000">(</font>m<font color="#990000">)</font>
 <font SIZE="-2" color="black">    10.  </font>        <i><font color="#9A1900">// ...</font></i>
 <font SIZE="-2" color="black">    11.  </font>    <font color="#FF0000">}</font>
</tt></pre>
W jakiej kolejności zdefiniować te funkcje? Jeśli zdefiniujemy je
tak jak wyżej, to w&nbsp;linii&nbsp;3 kompilacja zostanie przerwana,
bo nieznana jest w&nbsp;niej jeszcze funkcja
<!--O--><span class='funkcja'>fun2<!--C--></span>; odwrócenie
kolejności nie pomoże, bo wtedy instrukcja wywołania
<!--O--><span class='funkcja'>fun1<!--C--></span>

wewnątrz
<!--O--><span class='funkcja'>fun2<!--C--></span>
 spowoduje te same kłopoty.

<P>
Na szczęście jest wyjście z&nbsp;tej sytuacji. Kompilatorowi nie jest
potrzebna definicja funkcji, to znaczy nie musi wiedzieć,
co funkcja robi: musi tylko wiedzieć, ile i&nbsp;jakie ma parametry i&nbsp;jaki
jest jej typ zwracany. Do tego wystarczy
<FONT COLOR="#7b003e"><B>prototyp</B></FONT><A NAME="11411"></A><A NAME="11412"></A>
funkcji podany w&nbsp;<FONT COLOR="#7b003e"><B>deklaracji</B></FONT>.<A NAME="11414"></A>
<A NAME="11415"></A>
Deklaracja ma formę nagłówka funkcji, po którym następuje średnik
zamiast ciała (treści) funkcji. Na przykład poprawnymi deklaracjami
funkcji są
<pre><tt>       string<font color="#990000">&amp;</font> <b><font color="#000000">fun1</font></b><font color="#990000">(</font><font color="#009900">char</font><font color="#990000">*</font> c1<font color="#990000">,</font> <font color="#009900">char</font><font color="#990000">*</font> c2<font color="#990000">,</font> <font color="#009900">bool</font> b<font color="#990000">);</font>
       <font color="#009900">void</font>    <b><font color="#000000">fun2</font></b><font color="#990000">(</font><font color="#009900">int</font> k<font color="#990000">,</font> <font color="#009900">double</font> d<font color="#990000">[]);</font>
       Klasa<font color="#990000">*</font>  <b><font color="#000000">fun3</font></b><font color="#990000">(</font>Klasa<font color="#990000">*</font> k1<font color="#990000">,</font> Klasa<font color="#990000">*</font> k2<font color="#990000">);</font>
</tt></pre>
Nie mają one ciała (treści), a&nbsp;więc nie są definicjami.
Ale zawierają informacje o&nbsp;nazwie, typie zwracanym,
typie i&nbsp;liczbie parametrów (czyli właśnie <FONT COLOR="#7b003e"><I>prototyp</I></FONT>).
Jest to wszystko, czego potrzebuje kompilator, aby sprawdzić
formalną prawidłowość ich użycia. Tak więc nasz pierwszy przykład
skompiluje się gładko, jeśli przed definicją funkcji

<!--O--><span class='funkcja'>fun1<!--C--></span>
 umieścimy
<SPAN  CLASS="textit">deklarację</SPAN> funkcji
<!--O--><span class='funkcja'>fun2<!--C--></span>
 (ze średnikiem na końcu):
<pre><tt> <font SIZE="-2" color="black">     1.  </font>    <font color="#009900">void</font> <b><font color="#000000">fun2</font></b><font color="#990000">(</font><font color="#009900">int</font><font color="#990000">);</font>
 <font SIZE="-2" color="black">     2.  </font>
 <font SIZE="-2" color="black">     3.  </font>    <font color="#009900">void</font> <b><font color="#000000">fun1</font></b><font color="#990000">(</font><font color="#009900">int</font> k<font color="#990000">)</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">     4.  </font>        <i><font color="#9A1900">// ...</font></i>
 <font SIZE="-2" color="black">     5.  </font>        <b><font color="#000000">fun2</font></b><font color="#990000">(</font>k<font color="#990000">)</font>
 <font SIZE="-2" color="black">     6.  </font>        <i><font color="#9A1900">// ...</font></i>
 <font SIZE="-2" color="black">     7.  </font>    <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">     8.  </font>
 <font SIZE="-2" color="black">     9.  </font>    <font color="#009900">void</font> <b><font color="#000000">fun2</font></b><font color="#990000">(</font><font color="#009900">int</font> m<font color="#990000">)</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    10.  </font>        <i><font color="#9A1900">// ...</font></i>
 <font SIZE="-2" color="black">    11.  </font>        <b><font color="#000000">fun1</font></b><font color="#990000">(</font>m<font color="#990000">)</font>
 <font SIZE="-2" color="black">    12.  </font>        <i><font color="#9A1900">// ...</font></i>
 <font SIZE="-2" color="black">    13.  </font>    <font color="#FF0000">}</font>
</tt></pre>
Zauważmy, że w&nbsp;deklaracji (pierwsza linia) nie podaliśmy nazwy
pierwszego i&nbsp;jedynego parametru formalnego funkcji
<!--O--><span class='funkcja'>fun2<!--C--></span>

&mdash;&nbsp;tylko jego typ (<!--O--><span class='typ'>int<!--C--></span>). Jest to całkowicie dopuszczalne:
do sprawdzenia poprawności wywołania kompilator potrzebuje informacji
o&nbsp;liczbie i&nbsp;typie parametrów funkcji,
ale ich nazwy nie są do niczego potrzebne i&nbsp;są wobec tego
przez kompilator pomijane. Zatem można ich w&nbsp;ogóle nie pisać
(choć warto, bo umiejętnie dobrane nazwy są znakomitą formą
komentarza). Oczywiście w&nbsp;<FONT COLOR="#7b003e"><I>definicji</I></FONT> nazwa zwykle
jest konieczna, ale nie musi być taka sama jaka została podana
w&nbsp;deklaracji.

<P>
Na przykład, podane poprzednio trzy deklaracje
moglibyśmy równie dobrze zapisać tak:
<pre><tt>       string<font color="#990000">&amp;</font> <b><font color="#000000">fun1</font></b><font color="#990000">(</font><font color="#009900">char</font><font color="#990000">*,</font> <font color="#009900">char</font><font color="#990000">*,</font> <font color="#009900">bool</font><font color="#990000">);</font>
       <font color="#009900">void</font>    <b><font color="#000000">fun2</font></b><font color="#990000">(</font><font color="#009900">int</font><font color="#990000">,</font> <font color="#009900">double</font><font color="#990000">[]);</font>
       Klasa<font color="#990000">*</font>  <b><font color="#000000">fun3</font></b><font color="#990000">(</font>Klasa<font color="#990000">*,</font> Klasa<font color="#990000">*);</font>
</tt></pre>
Funkcja zadeklarowana musi oczywiście być gdzieś również
zdefiniowana (tylko raz). W przeciwnym razie powstanie błąd na
etapie linkowania (łączenia, konsolidacji) programu.
Zauważmy, że błędu <FONT COLOR="#7b003e"><I>nie będzie</I></FONT>, jeśli zadeklarowana funkcja nie
została w&nbsp;programie użyta &mdash;&nbsp;tak więc wolno deklarować funckje, które
dopiero zamierzamy napisać, byle tylko nie próbować ich użycia.
Definicja nie musi wystąpić w&nbsp;tym samym module (pliku). Wystarczy, że
umieścimy ją w&nbsp;jakimś module składającym się na cały program.
W innych modułach, w&nbsp;których funkcja ta jest używana, trzeba tylko
zamieścić jej deklarację.

<P>
Ponieważ na razie nasze programy i&nbsp;tak mieszczą się w&nbsp;jednym pliku,
szczegóły odłożymy do
     rozdziału o <A HREF="node141.html#modul:modul">modułach programu</A> .

<P>

<P>

<div class='wazne'>
Ta sama funkcja może być deklarowana wielokrotnie,
    nawet w&nbsp;tym samym pliku.
    Definicja natomiast powinna wystąpić tylko raz
    (ODR &ndash;&nbsp;ang.&nbsp;<FONT COLOR="#7b003e"><I>One Definition Rule</I></FONT>);
    <A NAME="12694"></A><A NAME="12695"></A>
    wyjątkiem
    są funkcje rozwijane, o&nbsp;których powiemy dalej.


</div>

<P>
Oczywiście wszystkie deklaracje, jeśli jest ich kilka, muszą
być ze sobą zgodne, czyli definiować ten sam prototyp.
Definicja również musi być zgodna
z deklaracjami &mdash;&nbsp;to znaczy nagłówek funkcji musi być zgodny
z prototypem. Jak mówiliśmy, ta zgodność nie musi dotyczyć
nazw parametrów formalnych funkcji, które w&nbsp;ogóle nie mają
znaczenia w&nbsp;deklaracjach i&nbsp;do prototypu nie należą.

<P>
<FONT COLOR="#7b003e"><B>Nagłówek</B></FONT><A NAME="11440"></A> określa
prototyp, czyli zewnętrzne własności funkcji. W&nbsp;najprostszej
postaci wygląda on tak:
<PRE>
        Typ Nazwa ListaParam
</PRE>
gdzie
<!--O--><span class='zmienna'>Typ<!--C--></span>
 określa typ wartości zwracanej (przed nią mogą
wystąpić modyfikatory, o&nbsp;których powiemy w&nbsp;dalszej części
rozdziału),
<!--O--><span class='zmienna'>Nazwa<!--C--></span>
 oznacza nazwę funkcji, a

<!--O--><span class='zmienna'>ListaParam<!--C--></span>
 listę parametrów<A NAME="11446"></A>
<A NAME="11447"></A> formalnych.
<DL>
<DT><STRONG>Typ wartości zwracanej.</STRONG></DT>
<DD>
<BR>
Musi to być typ wbudowany (jak
<!--O--><span class='typ'>int<!--C--></span>,
<!--O--><span class='typ'>char<!--C--></span>, ...),
          typ zdefiniowany przez użytkownika, typ pochodny
          (<!--O--><span class='klucz'>int*<!--C--></span>,
<!--O--><span class='klucz'>Osoba&amp;<!--C--></span>
 itd.), albo wreszcie typ

<!--O--><span class='klucz'>void<!--C--></span>.<A NAME="11454"></A>
          Jeśli typem zwracanym nie jest
<!--O--><span class='klucz'>void<!--C--></span>,
          to funcję nazywamy <FONT COLOR="#7b003e"><B>funkcją rezultatową</B></FONT>.
          <A NAME="11457"></A> Jeśli jest to
<!--O--><span class='klucz'>void<!--C--></span>, to
          funkcja w&nbsp;ogóle nie zwraca żadnej wartości;
          taką funkcję nazywamy <FONT COLOR="#7b003e"><B>funkcją bezrezultatową</B></FONT>.
          <A NAME="11460"></A>
          Typ wartości zwracanej zwany jest też po prostu
          <FONT COLOR="#7b003e"><B>typem funkcji</B></FONT>.<A NAME="11462"></A>
<BR>
Typem funkcji nie może być typ tablicowy i&nbsp;nie może nim
          być typ funkcyjny; może to natomiast być typ wskaźnikowy
          &mdash;&nbsp;w&nbsp;szczególności wskaźnik może wskazywać na tablicę
          lub funkcję &mdash;&nbsp;lub typ referencyjny.

</DD>
<DT><STRONG>Nazwa.</STRONG></DT>
<DD>
<BR>
Nazwa może być dowolna, byle nie kolidowała z&nbsp;którymś
          ze słów kluczowych, składała się tylko z&nbsp;liter, cyfr i
          znaków podkreślenia. Nie może jednak zaczynać się od
          cyfry.

</DD>
<DT><STRONG>Lista parametrów formalnych.</STRONG></DT>
<DD>
<BR>
Lista ta jest ujętą w&nbsp;okrągłe nawiasy
          listą oddzielonych przecinkami deklaracji pojedynczych
          parametrów<A NAME="11463"></A> funkcji
          w&nbsp;postaci
<FONT COLOR="#000000"><TT>(typ1 nazwa1, typ2 nazwa2)</TT></FONT>.
          Nie wolno stosować deklaracji zbiorczych:

<FONT COLOR="#000000"><TT>(typ nazwa1, nazwa2)</TT></FONT> &mdash;&nbsp;nie byłoby wtedy wiadomo,
          czy
<!--O--><span class='zmienna'>nazwa2<!--C--></span>
 jest drugim parametrem typu
<!--O--><span class='typ'>typ<!--C--></span>,
          czy typem następnego, anonimowego (co jest dopuszczalne), parametru.
          Nazwy wszystkich parametrów muszą być różne.
<BR>
Nazwy parametru można w&nbsp;ogóle nie podawać w
          deklaracjach; w&nbsp;definicjach również można nazwę pominąć,
          jeśli z&nbsp;argumentu wywołania skojarzonego z&nbsp;tym parametrem
          funkcja w&nbsp;ogóle nie korzysta, jak to często bywa
          w&nbsp;czasie tworzenia funkcji w&nbsp;jej wstępnych wersjach.
<BR>
Lista parametrów może być pusta; obejmujących ją
          nawiasów pominąć jednak nie można. Jeśli lista
          parametrów jest pusta, to można zaznaczyć to
          przez wpisanie wewnątrz nawiasów słowa kluczowego

<!--O--><span class='klucz'>void<!--C--></span>. Nie jest to jednak konieczne.
<BR>
Pamiętajmy też, że poprzedzenie nazwy typu słowem
          kluczowym
<!--O--><span class='klucz'>const<!--C--></span>
 odpowiada zmianie typu:
          typ
<!--O--><span class='typ'>int*<!--C--></span>
 i&nbsp;typ
<!--O--><span class='typ'>const int*<!--C--></span>
 to dwa
          <FONT COLOR="#7b003e"><I>różne</I></FONT> typy. Jeśli typem parametru jest na przykład

<!--O--><span class='typ'>const int*<!--C--></span>, to kompilator nie zgodzi się na zmianę
          wartości zmiennej wskazywanej poprzez nazwę wskaźnika
          przekazanego jako argument (co funkcja normalnie może
          zrobić; przekazana jej została, co prawda, kopia adresu, ale
          sam adres odpowiada oryginalnej zmiennej z&nbsp;funkcji
          wywołującej).
</DD>
</DL>

<P>
Część nagłówka funkcji składająca się z&nbsp;nazwy funkcji i&nbsp;listy
typów jej parametrów (bez nazw tych parametrów) nazywa się czasem
jej <FONT COLOR="#7b003e"><B>sygnaturą</B></FONT>.<A NAME="11478"></A>
<A NAME="11479"></A>
Typu zwracanego zwykle w&nbsp;sygnaturze nie uwzględnia się.
Tak więc na przykład sygnaturą funkcji o&nbsp;prototypie
<pre><tt>       <font color="#009900">double</font> <b><font color="#000000">fun</font></b><font color="#990000">(</font><font color="#009900">double</font> x<font color="#990000">,</font> <font color="#009900">char</font><font color="#990000">*</font> nap<font color="#990000">);</font>
</tt></pre>
jest
<pre><tt>       <b><font color="#000000">fun</font></b><font color="#990000">(</font><font color="#009900">double</font><font color="#990000">,</font> <font color="#009900">char</font><font color="#990000">*)</font>
</tt></pre>

<P>
<FONT COLOR="#7b003e"><B>Definicja</B></FONT><A NAME="11485"></A>
<A NAME="11486"></A>
funkcji składa się z&nbsp;takiego samego nagłówka, tyle
że teraz nie kończymy go średnikiem, tylko umieszczamy
zaraz za nim, ujętą w&nbsp;nawiasy klamrowe, treść (ciało) funkcji,
czyli sekwencję instrukcji do wykonania. Jeśli w&nbsp;ciele funkcji
chcemy korzystać z&nbsp;argumentu przekazanego poprzez parametr funkcji,
to oczywiście ten parametr musi mieć nazwę (którą w&nbsp;deklaracji
mogliśmy pominąć). W programie może występować tylko
jedna definicja funkcji, choć wiele deklaracji.
Wyjątkiem są funkcje rozwijane,<A NAME="11487"></A>
które mogą być definiowane wielokrotnie
(patrz&nbsp;podrozdział o <A HREF="node69.html#funk:inlin">funkcjach rozwijanych</A> ).

<P>
Ciało funkcji może być traktowane jak wnętrze instrukcji
grupującej (złożonej). Do zakresu tej instrukcji
grupującej należą również deklaracje zmiennych
lokalnych opisane przez specyfikacje parametrów funkcji.
Zmienne definiowane w&nbsp;ciele funkcji będą w&nbsp;czasie jej wykonywania
lokalne &mdash;&nbsp;po wykonaniu funkcji są one usuwane. Zmiennymi
<FONT COLOR="#7b003e"><I>lokalnymi</I></FONT> są również zmienne wyspecyfikowane jako parametry
formalne funkcji: będą one zainicjowane wartościami argumentów
wywołania. Po zakończeniu wykonywania funkcji zmienne lokalne
(z&nbsp;wyjątkiem tych zadeklarowanych jako
<!--O--><span class='klucz'>static<!--C--></span>) będą
usunięte.

<P>
Zmienne lokalne funkcji (w tym te deklarowane przez specyfikacje
parametrów w&nbsp;nagłówku funkcji) w&nbsp;żaden sposób nie kolidują ze
zmiennymi o&nbsp;tej samej nazwie w&nbsp;innych funkcjach. Mogą natomiast
przesłaniać nazwy zmiennych globalnych, zadeklarowanych poza
funkcjami i&nbsp;klasami. Jeśli
tak jest, to niekwalifikowana nazwa występująca w&nbsp;ciele funkcji
odnosi się zawsze do zmiennej lokalnej, natomiast dostęp do zmiennej
globalnej o&nbsp;tej nazwie mamy poprzez operator zasięgu &mdash;&nbsp;czterokropek
(patrz rozdział <A HREF="node35.html#zmienne:widzmien">o zasięgu i&nbsp;widzialności</A> zmiennych).

<P>
Nie wolno definicji funkcji zagnieżdżać, to znaczy nie
można w&nbsp;ciele jednej funkcji definiować innej funkcji
(co jest dozwolone w&nbsp;innych językach, jak
Pascal<A NAME="11502"></A>
czy Fortran 90/95).<A NAME="11503"></A>
W&nbsp;nowym standardzie C++11<A NAME="11504"></A><A NAME="11505"></A>
można jednak wewnątrz funkcji definiować tak zwane funkcje lambda,
o&nbsp;których za chwilę.

<P>
Definicja (i&nbsp;deklaracja) funkcji może w&nbsp;nowym standardzie
C++11<A NAME="11506"></A><A NAME="11507"></A> mieć inną, alternatywną, postać,
a&nbsp;mianowicie
<pre><tt>       <b><font color="#0000FF">auto</font></b> <b><font color="#000000">f_nazwa</font></b><font color="#990000">(</font>parametry<font color="#990000">)</font> <font color="#990000">-&gt;</font> typ_zwracany <font color="#FF0000">{</font> ciało <font color="#FF0000">}</font>
</tt></pre>
Zamiast specyfikować typ zwracany <FONT COLOR="#7b003e"><I>przed</I></FONT> nazwą funkcji,
stawiamy tam słowo kluczowe
<!--O--><span class='klucz'>auto<!--C--></span>, natomiast typ funkcji
określamy zaraz <FONT COLOR="#7b003e"><I>za</I></FONT> listą parametrów, poprzedzając go
&bdquo;strzałką&rdquo; ('
<FONT COLOR="#000000"><TT>-&gt;</TT></FONT>').
<A NAME="11515"></A>
Nie musimy zresztą tego typu określać jawnie, możemy użyć tu wyrażenia

<!--O--><span class='klucz'>decltype<!--C--></span>

(zob.&nbsp;rozdział&nbsp;o <A HREF="node15.html#typydan:wstep">typach danych</A> ).
Zauważmy, że jeśli tak zrobimy, to możemy w&nbsp;
<!--O--><span class='klucz'>decltype<!--C--></span>

użyć nazw parametrów funkcji, bo w&nbsp;tym miejscu jesteśmy już
w&nbsp;zakresie funkcji. Pokażmy to na przykładzie
<BR><A NAME="fundefnew.cpp"></A>
<BR CLEAR='ALL'>
<div class='kodpro'><HR>
      <SPAN  CLASS="textbf">P<SPAN CLASS="arabic">65</SPAN>:</SPAN>
      <A NAME="tex2html70"
  HREF="source-files/fundefnew.cpp">
<!--O--><span class='downl'>fundefnew.cpp<!--C--></span></A>
<A NAME="12767"></A>
      &nbsp;&nbsp;&nbsp;&nbsp;<SMALL CLASS="SMALL">Alternatywna postać deklaracji funkcji</SMALL>
      <BR CLEAR="ALL">
<HR>
<pre><tt> <font SIZE="-2" color="black">     1.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;iostream&gt;</font>
 <font SIZE="-2" color="black">     2.  </font><b><font color="#0000FF">using</font></b> <b><font color="#0000FF">namespace</font></b> std<font color="#990000">;</font>
 <font SIZE="-2" color="black">     3.  </font>
 <font SIZE="-2" color="black">     4.  </font><b><font color="#0000FF">auto</font></b> <b><font color="#000000">D</font></b><font color="#990000">(</font><font color="#009900">int</font> a<font color="#990000">,</font> <font color="#009900">double</font> b<font color="#990000">)</font> <font color="#990000">-&gt;</font> <b><font color="#000000">decltype</font></b><font color="#990000">(</font>a<font color="#990000">*</font>b<font color="#990000">);</font>   <span class="ding">&#x278A;</span>
 <font SIZE="-2" color="black">     5.  </font>
 <font SIZE="-2" color="black">     6.  </font><font color="#009900">double</font> <b><font color="#000000">A</font></b><font color="#990000">(</font><font color="#009900">int</font> a<font color="#990000">,</font> <font color="#009900">double</font> b<font color="#990000">)</font> <font color="#FF0000">{</font>                 <span class="ding">&#x278B;</span>
 <font SIZE="-2" color="black">     7.  </font>    <b><font color="#0000FF">return</font></b> a<font color="#990000">*</font>b<font color="#990000">;</font>
 <font SIZE="-2" color="black">     8.  </font><font color="#FF0000">}</font>
 <font SIZE="-2" color="black">     9.  </font>
 <font SIZE="-2" color="black">    10.  </font><b><font color="#0000FF">auto</font></b> <b><font color="#000000">B</font></b><font color="#990000">(</font><font color="#009900">int</font> a<font color="#990000">,</font> <font color="#009900">double</font> b<font color="#990000">)</font> <font color="#990000">-&gt;</font> <font color="#009900">double</font> <font color="#FF0000">{</font>         <span class="ding">&#x278C;</span>
 <font SIZE="-2" color="black">    11.  </font>    <b><font color="#0000FF">return</font></b> a<font color="#990000">*</font>b<font color="#990000">;</font>
 <font SIZE="-2" color="black">    12.  </font><font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    13.  </font>
 <font SIZE="-2" color="black">    14.  </font><b><font color="#0000FF">auto</font></b> <b><font color="#000000">C</font></b><font color="#990000">(</font><font color="#009900">int</font> a<font color="#990000">,</font> <font color="#009900">double</font> b<font color="#990000">)</font> <font color="#990000">-&gt;</font> <b><font color="#000000">decltype</font></b><font color="#990000">(</font>a<font color="#990000">*</font>b<font color="#990000">)</font> <font color="#FF0000">{</font>  <span class="ding">&#x278D;</span>
 <font SIZE="-2" color="black">    15.  </font>    <b><font color="#0000FF">return</font></b> a<font color="#990000">*</font>b<font color="#990000">;</font>
 <font SIZE="-2" color="black">    16.  </font><font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    17.  </font>
 <font SIZE="-2" color="black">    18.  </font><font color="#009900">double</font> <b><font color="#000000">D</font></b><font color="#990000">(</font><font color="#009900">int</font> a<font color="#990000">,</font> <font color="#009900">double</font> b<font color="#990000">)</font> <font color="#FF0000">{</font>                 <span class="ding">&#x278E;</span>
 <font SIZE="-2" color="black">    19.  </font>    <b><font color="#0000FF">return</font></b> a<font color="#990000">*</font>b<font color="#990000">;</font>
 <font SIZE="-2" color="black">    20.  </font><font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    21.  </font>
 <font SIZE="-2" color="black">    22.  </font><font color="#009900">int</font> <b><font color="#000000">main</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    23.  </font>    cout <font color="#990000">&lt;&lt;</font> <b><font color="#000000">A</font></b><font color="#990000">(</font><font color="#993399">4</font><font color="#990000">,</font><font color="#993399">2.5</font><font color="#990000">)</font> <font color="#990000">&lt;&lt;</font> <font color="#FF0000">" "</font> <font color="#990000">&lt;&lt;</font> <b><font color="#000000">B</font></b><font color="#990000">(</font><font color="#993399">4</font><font color="#990000">,</font><font color="#993399">2.5</font><font color="#990000">)</font> <font color="#990000">&lt;&lt;</font> <font color="#FF0000">" "</font>
 <font SIZE="-2" color="black">    24.  </font>         <font color="#990000">&lt;&lt;</font> <b><font color="#000000">C</font></b><font color="#990000">(</font><font color="#993399">4</font><font color="#990000">,</font><font color="#993399">2.5</font><font color="#990000">)</font> <font color="#990000">&lt;&lt;</font> <font color="#FF0000">" "</font> <font color="#990000">&lt;&lt;</font> <b><font color="#000000">D</font></b><font color="#990000">(</font><font color="#993399">4</font><font color="#990000">,</font><font color="#993399">2.5</font><font color="#990000">)</font> <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    25.  </font><font color="#FF0000">}</font>
</tt></pre>
<hr>

</div>

<P>
Definiujemy tu szereg funkcji (<!--O--><span class='funkcja'>A<!--C--></span>,
<!--O--><span class='funkcja'>B<!--C--></span>,
<!--O--><span class='funkcja'>C<!--C--></span>,

<!--O--><span class='funkcja'>D<!--C--></span>), które są właściwie identyczne &mdash;&nbsp;wszystkie po prostu
zwracają iloczyn swoich argumentów. Definicja funkcji
<!--O--><span class='funkcja'>A<!--C--></span>

(<span class="ding">&#x278B;</span>) jest &bdquo;normalna&rdquo;. W&nbsp;linii&nbsp;<span class="ding">&#x278C;</span> użyliśmy natomiast nowej
składni (<!--O--><span class='klucz'>auto<!--C--></span>
 przed nazwą, typ za listą parametrów i&nbsp;poprzedzony
strzałką). W&nbsp;definicji funkcji
<!--O--><span class='funkcja'>C<!--C--></span>
 (<span class="ding">&#x278D;</span>) zamiast podawać jawnie
typ &bdquo;poprosiliśmy&rdquo; kompilator, aby sam określił, jaki powinien być
typ iloczynu argumentów (oczywiście będzie to
<!--O--><span class='typ'>double<!--C--></span>).
Widać też, że nowej składni możemy też użyć do deklarowania funkcji
(<span class="ding">&#x278A;</span>) &mdash;&nbsp;sama definicja (<span class="ding">&#x278E;</span>) może być zapisana zarówno w&nbsp;nowej
jak i&nbsp;starej składni (wtedy oczywiście typ zwracany musi się zgadzać
z&nbsp;tym wydedukowanym przez kompilator z&nbsp;deklaracji).

<P>
Forma użyta w&nbsp;tym przykładzie w&nbsp;definicji funkcji
<!--O--><span class='funkcja'>C<!--C--></span>
 (<span class="ding">&#x278D;</span>)
okaże się niesłychanie użyteczna przy definiowaniu szablonów funkcji.

<P>
Powiedzmy na koniec, że deklaracje i&nbsp;definicje funkcji nie są instrukcjami
wykonywalnymi (jak na przykład w&nbsp;Pythonie).
<A NAME="11536"></A><A NAME="11537"></A>
Zatem kolejność, w&nbsp;jakiej je piszemy, nie ma znaczenia,
dopóki spełniony jest warunek, że co najmniej jedna deklaracja poprzedza
leksykalnie instrukcje, w&nbsp;których funkcja jest wykorzystywana.

<P>

<DIV CLASS="navigation"><HR>
<A NAME="tex2html1591"
  HREF="node60.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="ikonypng/prev.png"></A>
<A NAME="tex2html1597"
  HREF="node59.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="ikonypng/up.png"></A>
<A NAME="tex2html1603"
  HREF="node62.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="ikonypng/next.png"></A>
<A NAME="tex2html1599"
  HREF="node1.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="ikonypng/contents.png"></A>
<A NAME="tex2html1601"
  HREF="node150.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="index"
 SRC="ikonypng/index.png"></A> <BR>
<B>Wstecz:</B> <A NAME="tex2html1592"
  HREF="node60.html">11.1 Wstęp</A>
<B>W g&#243;r&#281;:</B> <A NAME="tex2html1598"
  HREF="node59.html">11. Funkcje</A>
<B>Dalej:</B> <A NAME="tex2html1604"
  HREF="node62.html">11.3 Wywołanie funkcji</A>
</DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<p style="text-align:right;"><I><font size=-2>T.R. Werner, 28 września 2018; 23:31</font></I></p>
</ADDRESS>
</BODY>
</HTML>
