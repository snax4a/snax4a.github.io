<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
<TITLE>24.3 Przykłady</TITLE>
<META NAME="description" CONTENT="24.3 Przykłady">
<META NAME="keywords" CONTENT="PRG2CPP">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="LaTeX2HTML v2016">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="PRG2CPP.css">

<LINK REL="previous" HREF="node145.html">
<LINK REL="up" HREF="node143.html">
<LINK REL="next" HREF="node147.html">
</HEAD>

<BODY >

<DIV CLASS="navigation">
<A NAME="tex2html2889"
  HREF="node145.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="ikonypng/prev.png"></A>
<A NAME="tex2html2893"
  HREF="node143.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="ikonypng/up.png"></A>
<A NAME="tex2html2899"
  HREF="node147.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="ikonypng/next.png"></A>
<A NAME="tex2html2895"
  HREF="node1.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="ikonypng/contents.png"></A>
<A NAME="tex2html2897"
  HREF="node150.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="index"
 SRC="ikonypng/index.png"></A> <BR>
<B>Wstecz:</B> <A NAME="tex2html2890"
  HREF="node145.html">24.2 Algorytmy i&nbsp;obiekty funkcyjne</A>
<B>W g&#243;r&#281;:</B> <A NAME="tex2html2894"
  HREF="node143.html">24. Biblioteka standardowa</A>
<B>Dalej:</B> <A NAME="tex2html2900"
  HREF="node147.html">25. Dynamiczna identyfikacja typu</A>
<BR> <HR> <P>
</DIV>
<!--End of Navigation Panel-->

<H1><A NAME="SECTION002530000000000000000"></A>
        <A NAME="stl:przyk"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">3</SPAN> Przykłady
</H1>

<P>
Na zakończenie tego krótkiego wstępu do biblioteki standardowej
przeanalizujmy jeszcze dwa przykłady ilustrujące jej zastosowania.

<P>

<P>
<BR>

<P>
Ważną klasą, a&nbsp;właściwie szablonem klas, jest
<!--O--><span class='klasa'>pair<!--C--></span>

<A NAME="29041"></A> z&nbsp;nagłówka
<!--O--><span class='plik'>utility<!--C--></span>. Szablon ten opisuje
proste, ale często bardzo przydatne struktury składające
się z&nbsp;pary składowych pewnych typów, które mogą być różne;
mogą to być zarówno typy wbudowane jak i&nbsp;definiowane w&nbsp;programie.
Tak więc, jeśli potrzebne nam są często pary (<!--O--><span class='klasa'>string<!--C--></span>,

<!--O--><span class='klasa'>int<!--C--></span>), na przykład do opisu imienia i&nbsp;wieku osób, to
właściwym typem byłaby konkretyzacja
<!--O--><span class='klasa'>pair<SPAN CLASS="MATH">&lt;</SPAN>string,int<SPAN CLASS="MATH">&gt;</SPAN><!--C--></span>.
Struktura ta zawiera dwie składowe o&nbsp;nazwach
<!--O--><span class='zmienna'>first<!--C--></span>

&mdash;&nbsp;w&nbsp;tym przypadku typu
<!--O--><span class='klasa'>string<!--C--></span>
 &mdash;&nbsp;oraz
<!--O--><span class='zmienna'>second<!--C--></span>,
w&nbsp;naszym przypadku typu
<!--O--><span class='klasa'>int<!--C--></span>. Klasa jest tak zaimplementowana,
o&nbsp;co już sami nie musimy się martwić, że prawidłowo działają
operatory porównywania ('
<FONT COLOR="#000000"><TT>==</TT></FONT>' i&nbsp;'
<FONT COLOR="#000000"><TT>!=</TT></FONT>'), przypisania
itd. &mdash;&nbsp;jeśli oczywiście jest tak dla typów składowych.

<P>
Taką właśnie klasę tworzymy w&nbsp;poniższym programie. Dane o&nbsp;osobach
czytane są z&nbsp;pliku tekstowego
<A NAME="tex2html210"
  HREF="source-files/pary.dat">
<!--O--><span class='downl'>pary.dat<!--C--></span></A>
<A NAME="29554"></A> o następującej zawartości:
<PRE>
    Ania  17 Zosia  7 Ala 19
    Ula   36 Asia  18
    Ola    4
</PRE>
Przy wczytywaniu (linia&nbsp;46) dane są bezpośrednio kopiowane do
wektora &mdash;&nbsp;obiektu klasy konkretyzującej wzorzec
<!--O--><span class='klasa'>vector<!--C--></span>,
której elementami są pary typu
<!--O--><span class='klasa'>pair<SPAN CLASS="MATH">&lt;</SPAN>string,int<SPAN CLASS="MATH">&gt;</SPAN><!--C--></span>. Na
wektorze tym dokonujemy następnie kilku operacji ilustrujących
algorytmy z&nbsp;biblioteki standardowej i&nbsp;zastosowanie obiektów
funkcyjnych.
<A NAME="pary.cpp"></A>
<BR CLEAR='ALL'>
<div class='kodpro'><HR>
      <SPAN  CLASS="textbf">P<SPAN CLASS="arabic">198</SPAN>:</SPAN>
      <A NAME="tex2html211"
  HREF="source-files/pary.cpp">
<!--O--><span class='downl'>pary.cpp<!--C--></span></A>
<A NAME="29561"></A>
      &nbsp;&nbsp;&nbsp;&nbsp;<SMALL CLASS="SMALL">Pary</SMALL>
      <BR CLEAR="ALL">
<HR>
<pre><tt> <font SIZE="-2" color="black">     1.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;fstream&gt;</font>
 <font SIZE="-2" color="black">     2.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;string&gt;</font>
 <font SIZE="-2" color="black">     3.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;utility&gt;</font>   <i><font color="#9A1900">// pair</font></i>
 <font SIZE="-2" color="black">     4.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;vector&gt;</font>
 <font SIZE="-2" color="black">     5.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;algorithm&gt;</font> <i><font color="#9A1900">// copy, sort, itd.</font></i>
 <font SIZE="-2" color="black">     6.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;iostream&gt;</font>
 <font SIZE="-2" color="black">     7.  </font><b><font color="#0000FF">using</font></b> <b><font color="#0000FF">namespace</font></b> std<font color="#990000">;</font>
 <font SIZE="-2" color="black">     8.  </font>
 <font SIZE="-2" color="black">     9.  </font><b><font color="#0000FF">typedef</font></b> <font color="#008080">pair&lt;string,int&gt;</font> PARA<font color="#990000">;</font>
 <font SIZE="-2" color="black">    10.  </font><b><font color="#0000FF">typedef</font></b> <font color="#008080">vector&lt;PARA&gt;</font>     VECT<font color="#990000">;</font>
 <font SIZE="-2" color="black">    11.  </font><b><font color="#0000FF">typedef</font></b> VECT<font color="#990000">::</font><font color="#008080">iterator</font>   VECTIT<font color="#990000">;</font>
 <font SIZE="-2" color="black">    12.  </font>
 <font SIZE="-2" color="black">    13.  </font><b><font color="#0000FF">template</font></b> <font color="#990000">&lt;</font><b><font color="#0000FF">typename</font></b> <font color="#008080">P</font><font color="#990000">&gt;</font>
 <font SIZE="-2" color="black">    14.  </font><b><font color="#0000FF">class</font></b> <font color="#008080">niepelnoletni</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    15.  </font>    <font color="#009900">int</font> wiek<font color="#990000">;</font>
 <font SIZE="-2" color="black">    16.  </font><b><font color="#0000FF">public</font></b><font color="#990000">:</font>
 <font SIZE="-2" color="black">    17.  </font>    <b><font color="#000000">niepelnoletni</font></b><font color="#990000">(</font><font color="#009900">int</font> wiek<font color="#990000">)</font> <font color="#990000">:</font> <b><font color="#000000">wiek</font></b><font color="#990000">(</font>wiek<font color="#990000">)</font> <font color="#FF0000">{</font> <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    18.  </font>
 <font SIZE="-2" color="black">    19.  </font>    <font color="#009900">bool</font> <b><font color="#0000FF">operator</font></b><font color="#990000">()(</font><b><font color="#0000FF">const</font></b> P<font color="#990000">&amp;</font> p<font color="#990000">)</font> <b><font color="#0000FF">const</font></b> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    20.  </font>        <b><font color="#0000FF">return</font></b> p<font color="#990000">.</font>second <font color="#990000">&lt;</font> wiek<font color="#990000">;</font>
 <font SIZE="-2" color="black">    21.  </font>    <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    22.  </font><font color="#FF0000">}</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    23.  </font>
 <font SIZE="-2" color="black">    24.  </font><b><font color="#0000FF">template</font></b> <font color="#990000">&lt;</font><b><font color="#0000FF">typename</font></b> <font color="#008080">P1</font><font color="#990000">,</font> <b><font color="#0000FF">typename</font></b> <font color="#008080">P2</font><font color="#990000">&gt;</font>
 <font SIZE="-2" color="black">    25.  </font>ostream<font color="#990000">&amp;</font> <b><font color="#0000FF">operator</font></b><font color="#990000">&lt;&lt;(</font>ostream<font color="#990000">&amp;</font> str<font color="#990000">,</font> <b><font color="#0000FF">const</font></b> pair<font color="#990000">&lt;</font>P1<font color="#990000">,</font>P2<font color="#990000">&gt;&amp;</font> p<font color="#990000">)</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    26.  </font>    <b><font color="#0000FF">return</font></b> str <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"["</font> <font color="#990000">&lt;&lt;</font> p<font color="#990000">.</font>first <font color="#990000">&lt;&lt;</font> <font color="#FF0000">","</font> <font color="#990000">&lt;&lt;</font> p<font color="#990000">.</font>second <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"]"</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    27.  </font><font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    28.  </font>
 <font SIZE="-2" color="black">    29.  </font><b><font color="#0000FF">template</font></b> <font color="#990000">&lt;</font><b><font color="#0000FF">typename</font></b> <font color="#008080">P1</font><font color="#990000">,</font> <b><font color="#0000FF">typename</font></b> <font color="#008080">P2</font><font color="#990000">&gt;</font>
 <font SIZE="-2" color="black">    30.  </font>istream<font color="#990000">&amp;</font> <b><font color="#0000FF">operator</font></b><font color="#990000">&gt;&gt;(</font>istream<font color="#990000">&amp;</font> str<font color="#990000">,</font> pair<font color="#990000">&lt;</font>P1<font color="#990000">,</font>P2<font color="#990000">&gt;&amp;</font> p<font color="#990000">)</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    31.  </font>    <b><font color="#0000FF">return</font></b> str <font color="#990000">&gt;&gt;</font> p<font color="#990000">.</font>first <font color="#990000">&gt;&gt;</font> p<font color="#990000">.</font>second<font color="#990000">;</font>
 <font SIZE="-2" color="black">    32.  </font><font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    33.  </font>
 <font SIZE="-2" color="black">    34.  </font><b><font color="#0000FF">template</font></b> <font color="#990000">&lt;</font><b><font color="#0000FF">typename</font></b> <font color="#008080">P</font><font color="#990000">&gt;</font>
 <font SIZE="-2" color="black">    35.  </font><font color="#009900">bool</font> <b><font color="#000000">komp</font></b><font color="#990000">(</font><b><font color="#0000FF">const</font></b> P<font color="#990000">&amp;</font> p1<font color="#990000">,</font> <b><font color="#0000FF">const</font></b> P<font color="#990000">&amp;</font> p2<font color="#990000">)</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    36.  </font>    <b><font color="#0000FF">return</font></b> p1<font color="#990000">.</font>second <font color="#990000">&lt;</font> p2<font color="#990000">.</font>second<font color="#990000">;</font>
 <font SIZE="-2" color="black">    37.  </font><font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    38.  </font>
 <font SIZE="-2" color="black">    39.  </font><font color="#009900">int</font> <b><font color="#000000">main</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    40.  </font>    <font color="#008080">ifstream</font> <b><font color="#000000">plik</font></b><font color="#990000">(</font><font color="#FF0000">"pary.dat"</font><font color="#990000">);</font>
 <font SIZE="-2" color="black">    41.  </font>
 <font SIZE="-2" color="black">    42.  </font>    <font color="#008080">PARA</font>   p<font color="#990000">;</font>
 <font SIZE="-2" color="black">    43.  </font>    <font color="#008080">VECT</font> vec<font color="#990000">;</font>
 <font SIZE="-2" color="black">    44.  </font>    <font color="#008080">VECTIT</font> it<font color="#990000">,</font> fin<font color="#990000">;</font>
 <font SIZE="-2" color="black">    45.  </font>
 <font SIZE="-2" color="black">    46.  </font>    <b><font color="#0000FF">while</font></b> <font color="#990000">(</font>plik <font color="#990000">&gt;&gt;</font> p<font color="#990000">)</font> vec<font color="#990000">.</font><b><font color="#000000">push_back</font></b><font color="#990000">(</font>p<font color="#990000">);</font>
 <font SIZE="-2" color="black">    47.  </font>
 <font SIZE="-2" color="black">    48.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"Po wczytaniu:</font><font color="#CC33CC">\n</font><font color="#FF0000">"</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    49.  </font>    fin<font color="#990000">=</font>vec<font color="#990000">.</font><b><font color="#000000">end</font></b><font color="#990000">();</font>
 <font SIZE="-2" color="black">    50.  </font>    <b><font color="#0000FF">for</font></b> <font color="#990000">(</font>it <font color="#990000">=</font> vec<font color="#990000">.</font><b><font color="#000000">begin</font></b><font color="#990000">();</font> it <font color="#990000">!=</font> fin<font color="#990000">;</font> <font color="#990000">++</font>it<font color="#990000">)</font>
 <font SIZE="-2" color="black">    51.  </font>        cout <font color="#990000">&lt;&lt;</font> <font color="#990000">*</font>it <font color="#990000">&lt;&lt;</font> <font color="#FF0000">" "</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    52.  </font>
 <font SIZE="-2" color="black">    53.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"</font><font color="#CC33CC">\n</font><font color="#FF0000">Najstarsza "</font>
 <font SIZE="-2" color="black">    54.  </font>         <font color="#990000">&lt;&lt;</font> <font color="#990000">*</font><b><font color="#000000">max_element</font></b><font color="#990000">(</font>vec<font color="#990000">.</font><b><font color="#000000">begin</font></b><font color="#990000">(),</font>vec<font color="#990000">.</font><b><font color="#000000">end</font></b><font color="#990000">(),</font>komp<font color="#990000">&lt;</font>PARA<font color="#990000">&gt;)</font>
 <font SIZE="-2" color="black">    55.  </font>         <font color="#990000">&lt;&lt;</font> <font color="#FF0000">", najmlodsza "</font>
 <font SIZE="-2" color="black">    56.  </font>         <font color="#990000">&lt;&lt;</font> <font color="#990000">*</font><b><font color="#000000">min_element</font></b><font color="#990000">(</font>vec<font color="#990000">.</font><b><font color="#000000">begin</font></b><font color="#990000">(),</font>vec<font color="#990000">.</font><b><font color="#000000">end</font></b><font color="#990000">(),</font>komp<font color="#990000">&lt;</font>PARA<font color="#990000">&gt;);</font>
 <font SIZE="-2" color="black">    57.  </font>
 <font SIZE="-2" color="black">    58.  </font>    it <font color="#990000">=</font> <b><font color="#000000">remove_if</font></b><font color="#990000">(</font>vec<font color="#990000">.</font><b><font color="#000000">begin</font></b><font color="#990000">(),</font>fin<font color="#990000">,</font>
 <font SIZE="-2" color="black">    59.  </font>                   niepelnoletni<font color="#990000">&lt;</font>PARA<font color="#990000">&gt;(</font><font color="#993399">18</font><font color="#990000">));</font>
 <font SIZE="-2" color="black">    60.  </font>    vec<font color="#990000">.</font><b><font color="#000000">erase</font></b><font color="#990000">(</font>it<font color="#990000">,</font>vec<font color="#990000">.</font><b><font color="#000000">end</font></b><font color="#990000">());</font>
 <font SIZE="-2" color="black">    61.  </font>
 <font SIZE="-2" color="black">    62.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"</font><font color="#CC33CC">\n</font><font color="#FF0000">Po usunieciu niepelnoletnich:</font><font color="#CC33CC">\n</font><font color="#FF0000">"</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    63.  </font>    fin<font color="#990000">=</font>vec<font color="#990000">.</font><b><font color="#000000">end</font></b><font color="#990000">();</font>
 <font SIZE="-2" color="black">    64.  </font>    <b><font color="#0000FF">for</font></b> <font color="#990000">(</font>it <font color="#990000">=</font> vec<font color="#990000">.</font><b><font color="#000000">begin</font></b><font color="#990000">();</font> it <font color="#990000">!=</font> fin<font color="#990000">;</font> <font color="#990000">++</font>it<font color="#990000">)</font>
 <font SIZE="-2" color="black">    65.  </font>        cout <font color="#990000">&lt;&lt;</font> <font color="#990000">*</font>it <font color="#990000">&lt;&lt;</font> <font color="#FF0000">" "</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    66.  </font>
 <font SIZE="-2" color="black">    67.  </font>    <b><font color="#000000">sort</font></b><font color="#990000">(</font>vec<font color="#990000">.</font><b><font color="#000000">begin</font></b><font color="#990000">(),</font>fin<font color="#990000">,</font>komp<font color="#990000">&lt;</font>PARA<font color="#990000">&gt;);</font>
 <font SIZE="-2" color="black">    68.  </font>
 <font SIZE="-2" color="black">    69.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"</font><font color="#CC33CC">\n</font><font color="#FF0000">Po uporzadkowaniu:</font><font color="#CC33CC">\n</font><font color="#FF0000">"</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    70.  </font>    fin<font color="#990000">=</font>vec<font color="#990000">.</font><b><font color="#000000">end</font></b><font color="#990000">();</font>
 <font SIZE="-2" color="black">    71.  </font>    <b><font color="#0000FF">for</font></b> <font color="#990000">(</font>it <font color="#990000">=</font> vec<font color="#990000">.</font><b><font color="#000000">begin</font></b><font color="#990000">();</font> it <font color="#990000">!=</font> fin<font color="#990000">;</font> <font color="#990000">++</font>it<font color="#990000">)</font>
 <font SIZE="-2" color="black">    72.  </font>        cout <font color="#990000">&lt;&lt;</font> <font color="#990000">*</font>it <font color="#990000">&lt;&lt;</font> <font color="#FF0000">" "</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    73.  </font>
 <font SIZE="-2" color="black">    74.  </font>    cout <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    75.  </font><font color="#FF0000">}</font>
</tt></pre>
<hr>

</div>

W liniach&nbsp;9-11 definiujemy aliasy nazw typów, których będziemy
używać w&nbsp;dalszym ciągu. Nazwa
<!--O--><span class='klasa'>PARA<!--C--></span>
 jest synonimem
nazwy typu powstającego z&nbsp;konkretyzacji szablonu
<!--O--><span class='klasa'>pair<!--C--></span>,
w&nbsp;którym typem składowej
<!--O--><span class='zmienna'>first<!--C--></span>
 jest
<!--O--><span class='klasa'>string<!--C--></span>,
a&nbsp;typem składowej
<!--O--><span class='zmienna'>second<!--C--></span>
 jest
<!--O--><span class='typ'>int<!--C--></span>. Zatem
&bdquo;prawdziwą&rdquo; nazwą tego typu jest
<!--O--><span class='klasa'>pair<SPAN CLASS="MATH">&lt;</SPAN>string,int<SPAN CLASS="MATH">&gt;</SPAN><!--C--></span>.
Z&nbsp;kolei
<!--O--><span class='klasa'>VECT<!--C--></span>
 (linia&nbsp;10) jest synonimem nazwy klasy powstającej
z&nbsp;konkretyzacji wzorca
<!--O--><span class='klasa'>vector<!--C--></span>, w&nbsp;której typem elementów
wektora jest typ
<!--O--><span class='klasa'>pair<SPAN CLASS="MATH">&lt;</SPAN>string,int<SPAN CLASS="MATH">&gt;</SPAN><!--C--></span>
 czyli
<!--O--><span class='klasa'>PARA<!--C--></span>.
Bez użycia
<!--O--><span class='klucz'>typedef<!--C--></span>
 musielibyśmy jako nazwy tego typu
wektora używać nieporęcznego

<!--O--><span class='klasa'>vector<SPAN CLASS="MATH">&lt;</SPAN>pair<SPAN CLASS="MATH">&lt;</SPAN>string,int<SPAN CLASS="MATH">&gt;</SPAN> <SPAN CLASS="MATH">&gt;</SPAN><!--C--></span>. Zwróćmy uwagę, że
odstęp pomiędzy znakami '
<FONT COLOR="#000000"><TT>&gt;</TT></FONT>' byłby tu konieczny: bez niego
parser zinterpretowałby dwuznak '<TT>&gt;&gt;</TT>' jako operator wyjmowania
ze strumienia.

<P>
W linii&nbsp;43 tworzymy obiekt
<!--O--><span class='zmienna'>vec<!--C--></span>
 typu
<!--O--><span class='klasa'>VECT<!--C--></span>.
Obiekt ten jest, na razie pustym, wektorem elementów typu
<!--O--><span class='klasa'>PARA<!--C--></span>.
W&nbsp;linii&nbsp;40 otwieramy strumień wejściowy
<!--O--><span class='zmienna'>plik<!--C--></span>

związany z&nbsp;plikiem dyskowym
<!--O--><span class='plik'>pary.dat<!--C--></span>
 (patrz
  rozdział o <A HREF="node108.html#io:pliki">operacjach plikowych</A> ).
W jaki sposób zachodzi czytanie z&nbsp;pliku obiektów typu
<!--O--><span class='klasa'>PARA<!--C--></span>?
Jest to typ przez nas zdefiniowany, a&nbsp;więc operator '<TT>&gt;&gt;</TT>'
nie wie jak takie obiekty wyjąć ze strumienia. Dlatego
musieliśmy dla tego typu przeciążyć operator '<TT>&gt;&gt;</TT>'.
Zrobiliśmy to w&nbsp;liniach&nbsp;29-32. Zdefiniowany tam szablon zadziała
dla par (obiektów klas konkretyzujących wzorzec
<!--O--><span class='klasa'>pair<!--C--></span>)
dowolnych typów, pod warunkiem, że dla typów składowych

<!--O--><span class='zmienna'>first<!--C--></span>
 i&nbsp;
<!--O--><span class='zmienna'>second<!--C--></span>
 działanie '<TT>&gt;&gt;</TT>' jest
dobrze okeślone. W naszym przypadku typami składowych są

<!--O--><span class='klasa'>string<!--C--></span>
 i&nbsp;
<!--O--><span class='typ'>int<!--C--></span>, więc nie będzie żadnych kłopotów.

<P>
W liniach&nbsp;49-51 drukujemy zawartość kolekcji
<!--O--><span class='zmienna'>vec<!--C--></span>.
Drukowanymi elementami kolekcji są obiekty typu
<!--O--><span class='klasa'>PARA<!--C--></span>
 przez
nas zdefiniowanego, więc musieliśmy dla niego przeciążyć operator
'<TT>&lt;&lt;</TT>'. Zrobiliśmy to w&nbsp;liniach&nbsp;24-27, analogicznie do jak dla
operatora '<TT>&gt;&gt;</TT>'.

<P>
Linia&nbsp;54
<pre><tt>       <font color="#990000">*</font><b><font color="#000000">max_element</font></b><font color="#990000">(</font>vec<font color="#990000">.</font><b><font color="#000000">begin</font></b><font color="#990000">(),</font>vec<font color="#990000">.</font><b><font color="#000000">end</font></b><font color="#990000">(),</font>komp<font color="#990000">&lt;</font>PARA<font color="#990000">&gt;)</font>
</tt></pre>
demonstruje użycie funkcji (algorytmu)
<!--O--><span class='funkcja'>max_element<!--C--></span>

<A NAME="29106"></A><A NAME="29107"></A> znajdującej
największy element kolekcji. Kolekcja jest jak zwykle określona za
pomocą iteratorów. Gdybyśmy nie podali trzeciego argumentu,
to do porównań elementów zostałby użyty operator '
<FONT COLOR="#000000"><TT>&lt;</TT></FONT>'.
Elementami kolekcji są obiekty typu
<!--O--><span class='klasa'>PARA<!--C--></span>, więc aby to
zadziałało, w&nbsp;klasie
<!--O--><span class='klasa'>PARA<!--C--></span>
 operator '
<FONT COLOR="#000000"><TT>&lt;</TT></FONT>' musiałby
być przeciążony. To mogliśmy zrobić, ale w&nbsp;tym przypadku
zastosowane zostało inne rozwiązanie. Jako trzeci argument podaliśmy
funkcję porównującą obiekty (predykat w&nbsp;postaci szablonu &mdash;&nbsp;
linie&nbsp;34-37). Zauważmy, że jako parametru wzorca użyliśmy tu tylko
jednego typu (a&nbsp;nie pary typów). Wzorzec zadziała więc dla każdego
typu, w&nbsp;którym istnieją i&nbsp;dają się porywnywać za pomocą
'
<FONT COLOR="#000000"><TT>&lt;</TT></FONT>' składowe o nazwie
<!--O--><span class='zmienna'>second<!--C--></span>. Oczywiście typ

<!--O--><span class='klasa'>PARA<!--C--></span>
 spełnia te warunki. Jak widać z&nbsp;definicji, komparator
będzie poównywał obiekty typu
<!--O--><span class='klasa'>PARA<!--C--></span>
 według wieku, będącego
w&nbsp;nich składową
<!--O--><span class='zmienna'>second<!--C--></span>. Funkcja
<!--O--><span class='funkcja'>max_element<!--C--></span>

zwraca iterator wskazujący największy obiekt kolekcji.

<P>
Na podobnej zasadzie działa funkcja
<!--O--><span class='funkcja'>min_element<!--C--></span>

<A NAME="29122"></A><A NAME="29123"></A> użyta w&nbsp;linii&nbsp;56,
która, jak łatwo się domyślić, znajduje najmniejszy element
kolekcji. Prawidłowość działania obu funkcji widzimy z&nbsp;wydruku
<PRE>
    Po wczytaniu:
    [Ania,17] [Zosia,7] [Ala,19] [Ula,36] [Asia,18] [Ola,4]
    Najstarsza [Ula,36], najmlodsza [Ola,4]
    Po usunieciu niepelnoletnich:
    [Ala,19] [Ula,36] [Asia,18]
    Po uporzadkowaniu:
    [Asia,18] [Ala,19] [Ula,36]
</PRE>
Często się zdarza, że z&nbsp;kolekcji chcemy usunąć elementy
spełniające pewien warunek. Można to wygodnie zrobić za pomocą
algorytmu
<!--O--><span class='funkcja'>remove_if<!--C--></span><A NAME="29127"></A>
<A NAME="29128"></A> użytego w&nbsp;linii&nbsp;58. Jak zwykle ciąg
elementów kolekcji zadany jest przez iteratory będące pierwszymi
dwoma argumentami wywołania. Jako trzeci argument podajemy funkcję
(wskaźnik do funkcji) albo obiekt funkcyjny, który wywołany
z&nbsp;elementem kolekcji jako argumentem zwraca wartość logiczną

<!--O--><span class='klucz'>true<!--C--></span>, jeśli element ten ma zostać usunięty. W&nbsp;naszym
przypadku jest to obiekt klasy konkretyzującej szablon

<!--O--><span class='klasa'>niepelnoletni<!--C--></span>
 dla typu
<!--O--><span class='klasa'>PARA<!--C--></span>. Tworząc w&nbsp;linii&nbsp;59
obiekt tej klasy posyłamy do konstruktora liczbę, która w&nbsp;obiekcie
zapamiętana zostanie jako składowa
<!--O--><span class='zmienna'>wiek<!--C--></span>
 (patrz definicja
szablonu w&nbsp;liniach&nbsp;13-22). Musimy też przeciążyć w&nbsp;klasie operator
wywołania (linie&nbsp;19-21) tak, aby zwracał
<!--O--><span class='klucz'>true<!--C--></span>
 jeśli warunek
jest spełniony, czyli gdy wiek osoby jest mniejszy od tego
zapamiętanego w składowej
<!--O--><span class='zmienna'>wiek<!--C--></span>
 obiektu.

<P>
Funkcja
<!--O--><span class='funkcja'>remove_if<!--C--></span>, wbrew swej nazwie, <FONT COLOR="#7b003e"><I>nie</I></FONT>
usuwa niechcianych elementów. Przestawia je tylko tak, aby
znalazły się na końcu kolekcji. Tak więc po wywołaniu funkcji
liczba elementów kolekcji nie zmienia się. Zmienia się tylko ich
kolejność: elementy, dla których warunek nie był prawdziwy znajdują
się na początku, a&nbsp;te dla których warunek był spełniony na
końcu kolekcji. Funkcja zwraca iterator do pierwszego elementu
z tych &bdquo;niechcianych&rdquo;, dlatego typem zmiennej
<!--O--><span class='zmienna'>it<!--C--></span>
 z&nbsp;linii&nbsp;58
jest
<!--O--><span class='klasa'>VECTIT<!--C--></span>
 czyli
<!--O--><span class='klasa'>VECT::iterator<!--C--></span>. Gdyby takich
elementów w&nbsp;ogóle nie było, funkcja zwróciłaby iterator

<!--O--><span class='zmienna'>vec.end()<!--C--></span>. Fizycznego usunięcia elementów, a więc
skrócenia kolekcji, dokonujemy za pomocą wywołania funkcji
składowej o&nbsp;nazwie
<!--O--><span class='funkcja'>erase<!--C--></span><A NAME="29142"></A><A NAME="29143"></A>
na rzecz kolekcji (linia&nbsp;60). Pobiera ona jako argumenty iteratory
określające podciąg kolekcji przeznaczony do usunięcia &mdash;&nbsp;
w&nbsp;naszym przykładzie jest to podciąg od elementu wskazywanego przez

<!--O--><span class='zmienna'>it<!--C--></span>
 do końca.

<P>
W linii&nbsp;67 sortujemy pozostałe w&nbsp;wektorze elementy za pomocą
wywołania znanego nam już algorytmu
<!--O--><span class='funkcja'>sort<!--C--></span>.<A NAME="29146"></A>
<A NAME="29147"></A> Do porównywania elementów używamy takiego
samego komparatora jak ten, który został zastosowany w&nbsp;funkcjach

<!--O--><span class='funkcja'>max_element<!--C--></span>
 i&nbsp;
<!--O--><span class='funkcja'>min_element<!--C--></span>

<P>

<P><P>
<BR>

<P>
Jako drugi przykład rozpatrzmy program ilustrujący użycie
map<A NAME="29150"></A> (słowników).<A NAME="29151"></A> Wzorzec klas
reprezentujących słownki nazywa się
<!--O--><span class='klasa'>map<!--C--></span>
 (z&nbsp;nagłówka

<!--O--><span class='plik'>map<!--C--></span>). Aby skonkretyzować ten szablon należy podać dwa typy,

<!--O--><span class='typ'>Typ1<!--C--></span>
 i&nbsp;
<!--O--><span class='typ'>Typ2<!--C--></span>,
<pre><tt>   <b><font color="#000080">    #include</font></b> <font color="#FF0000">&lt;map&gt;</font>
       <i><font color="#9A1900">// ...</font></i>
       <font color="#008080">map&lt;Typ1,Typ2&gt;</font> mapa<font color="#990000">;</font>
</tt></pre>
które określają typy tzw.&nbsp;kluczy i&nbsp;wartości. Poszczególne elementy
mapy będą parami typu
<!--O--><span class='klasa'>pair<SPAN CLASS="MATH">&lt;</SPAN>const Typ1,Typ2<SPAN CLASS="MATH">&gt;</SPAN><!--C--></span>.
Zwróćmy uwagę, że typ kluczy jest modyfikowany tak, aby odpowiadać
typowi <FONT COLOR="#7b003e"><I>ustalonemu</I></FONT> (<!--O--><span class='klucz'>const<!--C--></span>), a&nbsp;więc klucze są
niemodyfikowalne, wartości związane z&nbsp;kluczem mogą natomiast być
modyfikowalne. W mapie nie mogą wystąpić dwa elementy z&nbsp;takim samym
kluczem. Najbliższym &bdquo;kuzynem&rdquo; mapy w&nbsp;Javie jest klasa

<!--O--><span class='klasa'>TreeMap<!--C--></span>. Ważną różnicą jest jednak to, że w&nbsp;mapach w&nbsp;C++
zarówno kluczami jak i&nbsp;wartościami mogą być obiekty typów
wbudowanych, jak
<!--O--><span class='typ'>int<!--C--></span>
 czy
<!--O--><span class='typ'>double<!--C--></span>. Pamiętać tylko trzeba,
że dla typu kluczy musi być zdefiniowane porównywanie za pomocą
operatora '
<FONT COLOR="#000000"><TT>&lt;</TT></FONT>' (bo słowniki są w&nbsp;C++ implementowane jako
drzewa czerwono-czarne, a&nbsp;nie &bdquo;prawdziwe&rdquo; mapy haszowane). Tak
oczywiście jest dla typów liczbowych czy dla typu
<!--O--><span class='klasa'>string<!--C--></span>;
jeśli klucze są typu przez nas zdefiniowanego, to musimy poprzez
mechanizm przeciążania działanie operatora '
<FONT COLOR="#000000"><TT>&lt;</TT></FONT>' zdefiniować
(odpowiedni komparator można też przesłać jako trzeci typ dla
szablonu
<!--O--><span class='klasa'>map<!--C--></span>
 podczas jego konkretyzacji).

<P>
Każdy element mapy, będąc obiektem typu
<!--O--><span class='klasa'>pair<!--C--></span>, ma składowe

<!--O--><span class='zmienna'>first<!--C--></span>
 i&nbsp;
<!--O--><span class='zmienna'>second<!--C--></span>
 odpowiadające odpowiednio kluczowi
i&nbsp;związanej z&nbsp;tym kluczem wartości. Operator indeksowania
<A NAME="29173"></A> ('
<FONT COLOR="#000000"><TT>[]</TT></FONT>') jest w&nbsp;mapach
przeciążony w&nbsp;ten sposób, że wyrażenie '
<FONT COLOR="#000000"><TT>mapa[key]</TT></FONT>'
jest referencją do wartości związanej z&nbsp;kluczem
<!--O--><span class='zmienna'>key<!--C--></span>.
Jeśli w&nbsp;mapie taki klucz nie występuje, to błędu nie będzie: nowy
element mapy zostanie automatycznie utworzony, a&nbsp;jako wartość
wstawiona zostanie wartość domyślna odpowiedniego typu (wartość
zerowa dla typów liczbowych). Na przykład we fragmencie kodu
<pre><tt> <font SIZE="-2" color="black">     1.  </font>    <font color="#008080">map&lt;string,int&gt;</font> slownik<font color="#990000">;</font>
 <font SIZE="-2" color="black">     2.  </font>    slownik<font color="#990000">[</font><font color="#FF0000">"Jan"</font><font color="#990000">]</font> <font color="#990000">=</font> <font color="#993399">20</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">     3.  </font>    slownik<font color="#990000">[</font><font color="#FF0000">"Ira"</font><font color="#990000">]</font> <font color="#990000">=</font> <font color="#990000">++</font>slownik<font color="#990000">[</font><font color="#FF0000">"Ula"</font><font color="#990000">]</font> <font color="#990000">+</font> <font color="#993399">18</font><font color="#990000">;</font>
</tt></pre>
zostanie w&nbsp;linii&nbsp;2 dodany do początkowo pustej mapy
<!--O--><span class='zmienna'>slownik<!--C--></span>

element o&nbsp;kluczu
<!--O--><span class='zmienna'>"Jan"<!--C--></span>
 i&nbsp;wartości&nbsp;20. W linii&nbsp;3 najpierw
tworzony jest element [
<!--O--><span class='zmienna'>"Ula"<!--C--></span>,0], a&nbsp;następnie jego wartość
(czyli zero) jest inkrementowana. Zatem po opracowaniu wyrażenia
'
<FONT COLOR="#000000"><TT>++slownik["Ula"]</TT></FONT>' element z&nbsp;kluczem
<!--O--><span class='zmienna'>"Ula"<!--C--></span>
 ma
wartość&nbsp;1. Wartością całej prawej strony przypisania jest zaś&nbsp;19.

<P>
Opracowanie lewej strony przypisania z&nbsp;linii&nbsp;3 spowoduje utworzenie
elementu [
<!--O--><span class='zmienna'>"Ira"<!--C--></span>, 0] i&nbsp;następnie przypisanie do wartości
skojarzonej z&nbsp;kluczem
<!--O--><span class='zmienna'>"Ira"<!--C--></span>
 wartości prawej strony
przypisania, czyli liczby&nbsp;19. Po wykonaniu tego fragmentu elementami
slownika są zatem pary [
<!--O--><span class='zmienna'>"Jan"<!--C--></span>,20], [
<!--O--><span class='zmienna'>"Ula"<!--C--></span>,1]
i&nbsp;[
<!--O--><span class='zmienna'>"Ira"<!--C--></span>,19].

<P>

<P>
<BR>

<P>
Rozpatrzmy jako przykład następujący program:
<A NAME="mapy.cpp"></A>
<BR CLEAR='ALL'>
<div class='kodpro'><HR>
      <SPAN  CLASS="textbf">P<SPAN CLASS="arabic">199</SPAN>:</SPAN>
      <A NAME="tex2html212"
  HREF="source-files/mapy.cpp">
<!--O--><span class='downl'>mapy.cpp<!--C--></span></A>
<A NAME="29626"></A>
      &nbsp;&nbsp;&nbsp;&nbsp;<SMALL CLASS="SMALL">Mapy (słowniki)</SMALL>
      <BR CLEAR="ALL">
<HR>
<pre><tt> <font SIZE="-2" color="black">     1.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;iostream&gt;</font>
 <font SIZE="-2" color="black">     2.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;iomanip&gt;</font>   <i><font color="#9A1900">// left, setw</font></i>
 <font SIZE="-2" color="black">     3.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;string&gt;</font>
 <font SIZE="-2" color="black">     4.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;map&gt;</font>
 <font SIZE="-2" color="black">     5.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;utility&gt;</font>   <i><font color="#9A1900">// pair</font></i>
 <font SIZE="-2" color="black">     6.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;algorithm&gt;</font>
 <font SIZE="-2" color="black">     7.  </font><b><font color="#0000FF">using</font></b> <b><font color="#0000FF">namespace</font></b> std<font color="#990000">;</font>
 <font SIZE="-2" color="black">     8.  </font>
 <font SIZE="-2" color="black">     9.  </font><b><font color="#0000FF">typedef</font></b> <font color="#008080">pair&lt;string,int&gt;</font> Emp<font color="#990000">;</font>
 <font SIZE="-2" color="black">    10.  </font><b><font color="#0000FF">typedef</font></b> <font color="#008080">map&lt;string,Emp&gt;</font>  MAP<font color="#990000">;</font>
 <font SIZE="-2" color="black">    11.  </font>
 <font SIZE="-2" color="black">    12.  </font><b><font color="#0000FF">class</font></b> <font color="#008080">Zakr</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    13.  </font>    <font color="#009900">int</font> min<font color="#990000">,</font>max<font color="#990000">;</font>
 <font SIZE="-2" color="black">    14.  </font><b><font color="#0000FF">public</font></b><font color="#990000">:</font>
 <font SIZE="-2" color="black">    15.  </font>    <b><font color="#000000">Zakr</font></b><font color="#990000">(</font><font color="#009900">int</font> min<font color="#990000">,</font><font color="#009900">int</font> max<font color="#990000">)</font> <font color="#990000">:</font> <b><font color="#000000">min</font></b><font color="#990000">(</font>min<font color="#990000">),</font> <b><font color="#000000">max</font></b><font color="#990000">(</font>max<font color="#990000">)</font> <font color="#FF0000">{}</font>
 <font SIZE="-2" color="black">    16.  </font>
 <font SIZE="-2" color="black">    17.  </font>    <font color="#009900">bool</font> <b><font color="#0000FF">operator</font></b><font color="#990000">()(</font><b><font color="#0000FF">const</font></b> pair<font color="#990000">&lt;</font><b><font color="#0000FF">const</font></b> string<font color="#990000">,</font>Emp<font color="#990000">&gt;&amp;</font> p<font color="#990000">)</font> <b><font color="#0000FF">const</font></b> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    18.  </font>        <font color="#009900">int</font> zarobki <font color="#990000">=</font> p<font color="#990000">.</font>second<font color="#990000">.</font>second<font color="#990000">;</font>
 <font SIZE="-2" color="black">    19.  </font>        <b><font color="#0000FF">return</font></b>  <font color="#990000">(</font>min <font color="#990000">&lt;</font> zarobki<font color="#990000">)</font> <font color="#990000">&amp;&amp;</font> <font color="#990000">(</font>zarobki <font color="#990000">&lt;</font> max<font color="#990000">);</font>
 <font SIZE="-2" color="black">    20.  </font>    <font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    21.  </font><font color="#FF0000">}</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    22.  </font>
 <font SIZE="-2" color="black">    23.  </font><font color="#009900">void</font> <b><font color="#000000">druk</font></b><font color="#990000">(</font><b><font color="#0000FF">const</font></b> MAP<font color="#990000">&amp;</font> m<font color="#990000">)</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    24.  </font>    MAP<font color="#990000">::</font><font color="#008080">const_iterator</font> it<font color="#990000">,</font> fin<font color="#990000">=</font>m<font color="#990000">.</font><b><font color="#000000">end</font></b><font color="#990000">();</font>
 <font SIZE="-2" color="black">    25.  </font>
 <font SIZE="-2" color="black">    26.  </font>    <b><font color="#0000FF">for</font></b> <font color="#990000">(</font>it <font color="#990000">=</font> m<font color="#990000">.</font><b><font color="#000000">begin</font></b><font color="#990000">();</font> it <font color="#990000">!=</font> fin<font color="#990000">;</font> it<font color="#990000">++)</font>
 <font SIZE="-2" color="black">    27.  </font>        cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"Klucz: "</font>   <font color="#990000">&lt;&lt;</font> left <font color="#990000">&lt;&lt;</font> <b><font color="#000000">setw</font></b><font color="#990000">(</font><font color="#993399">7</font><font color="#990000">)</font> <font color="#990000">&lt;&lt;</font> it<font color="#990000">-&gt;</font>first
 <font SIZE="-2" color="black">    28.  </font>             <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"Imie: "</font>    <font color="#990000">&lt;&lt;</font> <b><font color="#000000">setw</font></b><font color="#990000">(</font><font color="#993399">10</font><font color="#990000">)</font> <font color="#990000">&lt;&lt;</font> it<font color="#990000">-&gt;</font>second<font color="#990000">.</font>first
 <font SIZE="-2" color="black">    29.  </font>             <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"Zarobki: "</font> <font color="#990000">&lt;&lt;</font> it<font color="#990000">-&gt;</font>second<font color="#990000">.</font>second <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    30.  </font><font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    31.  </font>
 <font SIZE="-2" color="black">    32.  </font><font color="#009900">int</font> <b><font color="#000000">main</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    33.  </font>    <font color="#008080">MAP</font> emp<font color="#990000">;</font>
 <font SIZE="-2" color="black">    34.  </font>
 <font SIZE="-2" color="black">    35.  </font>    emp<font color="#990000">[</font><font color="#FF0000">"jan"</font><font color="#990000">]</font>    <font color="#990000">=</font> <b><font color="#000000">Emp</font></b><font color="#990000">(</font><font color="#FF0000">"Jan K."</font><font color="#990000">,</font>    <font color="#993399">1900</font><font color="#990000">);</font>
 <font SIZE="-2" color="black">    36.  </font>    emp<font color="#990000">[</font><font color="#FF0000">"piotr"</font><font color="#990000">]</font>  <font color="#990000">=</font> <b><font color="#000000">Emp</font></b><font color="#990000">(</font><font color="#FF0000">"Piotr M."</font><font color="#990000">,</font>  <font color="#993399">2100</font><font color="#990000">);</font>
 <font SIZE="-2" color="black">    37.  </font>    emp<font color="#990000">[</font><font color="#FF0000">"ola"</font><font color="#990000">]</font>    <font color="#990000">=</font> <b><font color="#000000">Emp</font></b><font color="#990000">(</font><font color="#FF0000">"Ola S."</font><font color="#990000">,</font>    <font color="#993399">3100</font><font color="#990000">);</font>
 <font SIZE="-2" color="black">    38.  </font>    emp<font color="#990000">[</font><font color="#FF0000">"prezes"</font><font color="#990000">]</font> <font color="#990000">=</font> <b><font color="#000000">Emp</font></b><font color="#990000">(</font><font color="#FF0000">"Prezes"</font><font color="#990000">,</font>    <font color="#993399">9900</font><font color="#990000">);</font>
 <font SIZE="-2" color="black">    39.  </font>    emp<font color="#990000">[</font><font color="#FF0000">"adam"</font><font color="#990000">]</font>   <font color="#990000">=</font> <b><font color="#000000">Emp</font></b><font color="#990000">(</font><font color="#FF0000">"Adam A."</font><font color="#990000">,</font>   <font color="#993399">1600</font><font color="#990000">);</font>
 <font SIZE="-2" color="black">    40.  </font>    emp<font color="#990000">[</font><font color="#FF0000">"emilia"</font><font color="#990000">]</font> <font color="#990000">=</font> <b><font color="#000000">Emp</font></b><font color="#990000">(</font><font color="#FF0000">"Emilia P."</font><font color="#990000">,</font> <font color="#993399">2600</font><font color="#990000">);</font>
 <font SIZE="-2" color="black">    41.  </font>
 <font SIZE="-2" color="black">    42.  </font>    <b><font color="#000000">druk</font></b><font color="#990000">(</font>emp<font color="#990000">);</font>
 <font SIZE="-2" color="black">    43.  </font>
 <font SIZE="-2" color="black">    44.  </font>    <font color="#009900">int</font> mn <font color="#990000">=</font> <font color="#993399">0</font><font color="#990000">,</font> mx <font color="#990000">=</font> <font color="#993399">2000</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    45.  </font>    <font color="#009900">int</font> ile <font color="#990000">=</font> <b><font color="#000000">count_if</font></b><font color="#990000">(</font>emp<font color="#990000">.</font><b><font color="#000000">begin</font></b><font color="#990000">(),</font>emp<font color="#990000">.</font><b><font color="#000000">end</font></b><font color="#990000">(),</font><b><font color="#000000">Zakr</font></b><font color="#990000">(</font>mn<font color="#990000">,</font>mx<font color="#990000">));</font>
 <font SIZE="-2" color="black">    46.  </font>
 <font SIZE="-2" color="black">    47.  </font>    cout <font color="#990000">&lt;&lt;</font> ile <font color="#990000">&lt;&lt;</font> <font color="#FF0000">" osob ma zarobki w zakresie od "</font>
 <font SIZE="-2" color="black">    48.  </font>         <font color="#990000">&lt;&lt;</font> mn <font color="#990000">&lt;&lt;</font> <font color="#FF0000">" do "</font> <font color="#990000">&lt;&lt;</font> mx <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    49.  </font><font color="#FF0000">}</font>
</tt></pre>
<hr>

</div>

W liniach&nbsp;9 i&nbsp;10 definiujemy alias
<!--O--><span class='klasa'>Emp<!--C--></span>
 dla typu

<!--O--><span class='klasa'>pair<SPAN CLASS="MATH">&lt;</SPAN>string,int<SPAN CLASS="MATH">&gt;</SPAN><!--C--></span>
 oraz alias
<!--O--><span class='klasa'>MAP<!--C--></span>
 dla typu
słownikowego
<!--O--><span class='klasa'>map<SPAN CLASS="MATH">&lt;</SPAN>string,Emp<SPAN CLASS="MATH">&gt;</SPAN><!--C--></span>. Będzie to słownik
złożony z&nbsp;elementów (par) w których klucz jest typu

<!--O--><span class='typ'>const string<!--C--></span>, a&nbsp;wartość jest parą złożoną z&nbsp;napisu
i&nbsp;liczby. W linii&nbsp;33 tworzymy pusty obiekt (słownik) typu
<!--O--><span class='klasa'>MAP<!--C--></span>,
a&nbsp;w liniach&nbsp;35-40 dodajemy do tego slownika kilka elementów.
Na przykład w&nbsp;linii&nbsp;35 tworzony jest nowy element słownika o&nbsp;kluczu

<!--O--><span class='zmienna'>"jan"<!--C--></span>
 i&nbsp;wartości będącej obiektem typu
<!--O--><span class='typ'>Emp<!--C--></span>
 (a&nbsp;więc
parą typu
<!--O--><span class='klasa'>pair<SPAN CLASS="MATH">&lt;</SPAN>string,int<SPAN CLASS="MATH">&gt;</SPAN><!--C--></span>) ze składową
<!--O--><span class='zmienna'>first<!--C--></span>


<!--O--><span class='zmienna'>"Jan K."<!--C--></span>
 i&nbsp;składową
<!--O--><span class='zmienna'>second<!--C--></span>
 równą 1900.

<P>
Tak utworzony słownik przesyłamy do funkcji
<!--O--><span class='funkcja'>druk<!--C--></span>, która
drukuje kolejne elementy słownika. Użyta tam zmienna
<!--O--><span class='zmienna'>it<!--C--></span>

jest iteratorem wskazującym na pojedynczy element słownika, czyli
obiekt typu
<!--O--><span class='klasa'>pair<SPAN CLASS="MATH">&lt;</SPAN>const string, pair<SPAN CLASS="MATH">&lt;</SPAN>string,int<SPAN CLASS="MATH">&gt;</SPAN> <SPAN CLASS="MATH">&gt;</SPAN><!--C--></span>.
Zatem '
<FONT COLOR="#000000"><TT>it-&gt;first</TT></FONT>' to klucz (np.&nbsp;
<!--O--><span class='zmienna'>"jan"<!--C--></span>),
a&nbsp;'
<FONT COLOR="#000000"><TT>it-&gt;second</TT></FONT>' to para złożona z&nbsp;napisu i&nbsp;liczby. Jeśli
więc chcemy wypisać zarobki osoby odpowiadającej elementowi
słownika, musimy użyć składni '
<FONT COLOR="#000000"><TT>it-&gt;second.second</TT></FONT>'.
Pierwszy wybór składowej odbywa się przez operator &bdquo;strzałki&rdquo;,
bo iterator ma semantykę wskaźnika, ale drugi wybór już nie:
wyrażenie '
<FONT COLOR="#000000"><TT>it-&gt;second</TT></FONT>' jest referencją do obiektu typu

<!--O--><span class='klasa'>Emp<!--C--></span>, a&nbsp;nie wskaźnikiem, więc używamy tu kropki.
<PRE>
    Klucz: adam   Imie: Adam A.   Zarobki: 1600
    Klucz: emilia Imie: Emilia P. Zarobki: 2600
    Klucz: jan    Imie: Jan K.    Zarobki: 1900
    Klucz: ola    Imie: Ola S.    Zarobki: 3100
    Klucz: piotr  Imie: Piotr M.  Zarobki: 2100
    Klucz: prezes Imie: Prezes    Zarobki: 9900
    2 osob ma zarobki w zakresie od 0 do 2000
</PRE>
W linii&nbsp;45 tworzymy wywoływalny obiekt typu
<!--O--><span class='klasa'>Zakr<!--C--></span>
 przekazując
do konstruktora dwie liczby określające pewien zakres. Jest to obiekt
funkcyjny który może być wywołany z&nbsp;elementem słownika jako
argumentem, a&nbsp;zatem obiekt ten może pełnić rolę predykatu
w&nbsp;wywołaniu funcji
<!--O--><span class='funkcja'>count_if<!--C--></span>
 z linii&nbsp;45:
<pre><tt>       <b><font color="#000000">count_if</font></b><font color="#990000">(</font>emp<font color="#990000">.</font><b><font color="#000000">begin</font></b><font color="#990000">(),</font>emp<font color="#990000">.</font><b><font color="#000000">end</font></b><font color="#990000">(),</font><b><font color="#000000">Zakr</font></b><font color="#990000">(</font>mn<font color="#990000">,</font>mx<font color="#990000">));</font>
</tt></pre>
Algorytm
<!--O--><span class='funkcja'>count_if<!--C--></span><A NAME="29227"></A><A NAME="29228"></A>
zlicza liczbę tych elementów kolekcji określonej dwoma
iteratorami, dla których predykat będący trzecim argumentem
wywołania zwraca
<!--O--><span class='klucz'>true<!--C--></span>. W naszym przypadku, dla każdego
elementu kolekcji (słownika)
<!--O--><span class='zmienna'>emp<!--C--></span>
 wywołana będzie metoda

<!--O--><span class='funkcja'>operator()<!--C--></span>, która zwróci
<!--O--><span class='klucz'>true<!--C--></span>, jeśli
dla danego elementu słownika składowa określająca zarobki mieści
się w&nbsp;zakresie definiowanym przez składowe
<!--O--><span class='zmienna'>min<!--C--></span>

i&nbsp;
<!--O--><span class='zmienna'>max<!--C--></span>
 obiektu funkcyjnego
<!--O--><span class='zmienna'>Zakr(mn,mx)<!--C--></span>.

<P>
Zauważmy, że typ
<!--O--><span class='klasa'>MAP<!--C--></span>
 zdefiniowany został jako

<!--O--><span class='klasa'>map<SPAN CLASS="MATH">&lt;</SPAN>string,Emp<SPAN CLASS="MATH">&gt;</SPAN><!--C--></span>, a&nbsp;to oznacza, jak już podkreślaliśmy,
że typem elementów tej kolekcji <FONT COLOR="#7b003e"><I>nie</I></FONT> będzie wcale typ

<!--O--><span class='klasa'>pair<SPAN CLASS="MATH">&lt;</SPAN>string,Emp<SPAN CLASS="MATH">&gt;</SPAN><!--C--></span>, tylko typ

<!--O--><span class='klasa'>pair<SPAN CLASS="MATH">&lt;</SPAN>const string,Emp<SPAN CLASS="MATH">&gt;</SPAN><!--C--></span>. Dlatego właśnie taki jest typ
parametru metody
<!--O--><span class='funkcja'>operator()<!--C--></span>.

<P>

<P><P>
<BR>

<P>
Biblioteka standardowa dostarcza oczywiście dużo więcej
narzędzi niż te, o&nbsp;których tu wspomnieliśmy.
Pełny ich opis można znaleźć w&nbsp;książkach
cytowanych w&nbsp;spisie <A HREF="node4.html#wprow:literatura">literatury</A> .

<DIV CLASS="navigation"><HR>
<A NAME="tex2html2889"
  HREF="node145.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="ikonypng/prev.png"></A>
<A NAME="tex2html2893"
  HREF="node143.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="ikonypng/up.png"></A>
<A NAME="tex2html2899"
  HREF="node147.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="ikonypng/next.png"></A>
<A NAME="tex2html2895"
  HREF="node1.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="ikonypng/contents.png"></A>
<A NAME="tex2html2897"
  HREF="node150.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="index"
 SRC="ikonypng/index.png"></A> <BR>
<B>Wstecz:</B> <A NAME="tex2html2890"
  HREF="node145.html">24.2 Algorytmy i&nbsp;obiekty funkcyjne</A>
<B>W g&#243;r&#281;:</B> <A NAME="tex2html2894"
  HREF="node143.html">24. Biblioteka standardowa</A>
<B>Dalej:</B> <A NAME="tex2html2900"
  HREF="node147.html">25. Dynamiczna identyfikacja typu</A>
</DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<p style="text-align:right;"><I><font size=-2>T.R. Werner, 28 września 2018; 23:31</font></I></p>
</ADDRESS>
</BODY>
</HTML>
