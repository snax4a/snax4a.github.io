<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
<TITLE>10.1 Konwersje standardowe</TITLE>
<META NAME="description" CONTENT="10.1 Konwersje standardowe">
<META NAME="keywords" CONTENT="PRG2CPP">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="LaTeX2HTML v2016">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="PRG2CPP.css">

<LINK REL="next" HREF="node58.html">
<LINK REL="previous" HREF="node56.html">
<LINK REL="up" HREF="node56.html">
<LINK REL="next" HREF="node58.html">
</HEAD>

<BODY >

<DIV CLASS="navigation">
<A NAME="tex2html1523"
  HREF="node56.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="ikonypng/prev.png"></A>
<A NAME="tex2html1529"
  HREF="node56.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="ikonypng/up.png"></A>
<A NAME="tex2html1535"
  HREF="node58.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="ikonypng/next.png"></A>
<A NAME="tex2html1531"
  HREF="node1.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="ikonypng/contents.png"></A>
<A NAME="tex2html1533"
  HREF="node150.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="index"
 SRC="ikonypng/index.png"></A> <BR>
<B>Wstecz:</B> <A NAME="tex2html1524"
  HREF="node56.html">10. Konwersje niejawne, porządek</A>
<B>W g&#243;r&#281;:</B> <A NAME="tex2html1530"
  HREF="node56.html">10. Konwersje niejawne, porządek</A>
<B>Dalej:</B> <A NAME="tex2html1536"
  HREF="node58.html">10.2 Porządek wartościowania</A>
<BR> <HR> <P>
</DIV>
<!--End of Navigation Panel-->

<H1><A NAME="SECTION001110000000000000000"></A><A NAME="konwporz:konwersje"></A>
<BR>
<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">1</SPAN> Konwersje standardowe
</H1>

<P>
Rozważmy niewinnie wyglądający fragment programu:
<pre><tt>       <font color="#009900">double</font> x <font color="#990000">=</font> <font color="#993399">1.5</font><font color="#990000">,</font> y<font color="#990000">;</font>
       <font color="#009900">int</font>    k <font color="#990000">=</font>  <font color="#993399">10</font><font color="#990000">;</font>
           <i><font color="#9A1900">// ...</font></i>
       y <font color="#990000">=</font> x <font color="#990000">+</font> k<font color="#990000">;</font>
</tt></pre>
Jaka funkcja wykonująca dodawanie będzie wywołana,
aby wykonać polecenie '
<FONT COLOR="#000000"><TT>x+k</TT></FONT>' z&nbsp;ostatniej linii?
Zmienna
<!--O--><span class='zmienna'>k<!--C--></span>
 jest typu
<!--O--><span class='typ'>int<!--C--></span>, zmienna
<!--O--><span class='zmienna'>x<!--C--></span>
 zaś
typu
<!--O--><span class='typ'>double<!--C--></span>. Mają one zatem zupełnie inną strukturę
w pamięci komputera. Aby je prawidłowo dodać, należy oczywiście
tę strukturę uwzględnić i&nbsp;zdecydować, jaki z&nbsp;kolei ma być
typ wyniku. Czy istnieje zatem jakaś funkcja realizująca
takie dodawanie? A gdyby
<!--O--><span class='zmienna'>k<!--C--></span>
 była typu
<!--O--><span class='typ'>unsigned short<!--C--></span>?
Dodawanie liczby zapisanej w&nbsp;postaci
<!--O--><span class='typ'>double<!--C--></span>
 do liczby
zapisanej w&nbsp;postaci
<!--O--><span class='typ'>unsigned short<!--C--></span>
 jest oczywiście zupełnie
czym innym niż dodawanie
<!--O--><span class='typ'>double<!--C--></span>'a do
<!--O--><span class='typ'>int<!--C--></span>'a.
Musiałaby zatem istnieć ogromna liczba funkcji realizujących to samo
zadanie, ale inaczej, w&nbsp;zależności od typów argumentów. To samo
dotyczy wywołań funkcji. Dostępna po dołączeniu pliku
nagłówkowego
<!--O--><span class='plik'>cmath<!--C--></span>
 (albo
<!--O--><span class='plik'>math.h<!--C--></span>) funkcja

<!--O--><span class='funkcja'>sin<!--C--></span>
 ma jeden parametr typu
<!--O--><span class='typ'>double<!--C--></span>
 (lub
<!--O--><span class='typ'>long<!--C--></span>).
Czy oznacza to, że wywołanie
<FONT COLOR="#000000"><TT>sin(1)</TT></FONT> jest błędem, czy
może istnieje inna wersja tej funkcji z&nbsp;parametrem
<!--O--><span class='typ'>int<!--C--></span>?
Tymi właśnie problemami teraz się zajmiemy.

<P>
Załóżmy, że w&nbsp;programie występuje wyrażenie z&nbsp;operatorem
dwuargumentowym (dodawanie, mnożenie, ...). Przed wykonaniem operacji
dokonywane są na wartościach argumentów <FONT COLOR="#7b003e"><B>konwersje
standardowe</B></FONT>,<A NAME="10914"></A>
których celem jest:

<UL>
<LI>doprowadzenie do tego, aby typy argumentów były takie same;
</LI>
<LI>zapewnienie, aby ten wspólny typ był &bdquo;obsługiwany&rdquo;
          przez istniejącą funkcję realizującą działanie
          danego operatora;
</LI>
<LI>zachowanie, <SPAN  CLASS="textit">w miarę możności</SPAN>, precyzji wyniku.
</LI>
</UL>
Cel pierwszy wynika z&nbsp;faktu, że funkcje realizujące działanie
operatorów są zdefiniowane tylko dla argumentów takiego samego typu,
przy czym <FONT COLOR="#7b003e"><I>nie</I></FONT> są zdefiniowane dla wszystkich możliwych typów.
Ważne jest też, jakiego typu jest wtedy wynik.

<P>

<P>

<div class='wazne'>
Typem wyniku arytmetycznej operacji dwuargumentowej
    jest wspólny typ argumentów <FONT COLOR="#7b003e"><I>po</I></FONT> dokonaniu konwersji.


</div>

<P>
Wyjaśnijmy przebieg poszukiwania tego wspólnego dla wartości
obu argumentów typu. Zauważmy, że konwersje są, jeśli to
tylko możliwe, promocjami,<A NAME="10920"></A>
to znaczy typ &bdquo;węższy&rdquo; jest awansowany do typu &bdquo;szerszego&rdquo; tak,
żeby nie utracić dokładności. W tym sensie np.&nbsp;typ
<!--O--><span class='typ'>int<!--C--></span>
 jest
&bdquo;węższy&rdquo; od
<!--O--><span class='typ'>double<!--C--></span>, bo każda wartość całkowita może
być zapisania w&nbsp;formie
<!--O--><span class='typ'>double<!--C--></span>
 bez utraty dokładności,
ale nie odwrotnie. Z&nbsp;drugiej strony, nie dla wszystkich pokrewnych
typów można zdefiniować taką relację zawierania: zbiory
wartości typu
<!--O--><span class='typ'>int<!--C--></span>
 i&nbsp;typu
<!--O--><span class='typ'>unsigned int<!--C--></span>
 są tak samo
liczne (<SPAN CLASS="MATH">2<SUP>32</SUP></SPAN> elementów), ale żaden nie zawiera się w&nbsp;drugim.
Wrócimy do tego problemu w&nbsp;dalszym ciągu.

<P>
Zatem:

<OL>
<LI>Jeśli jeden z&nbsp;argumentów jest
<!--O--><span class='typ'>long double<!--C--></span>, to drugi
          jest też przekształcany do typu
<!--O--><span class='typ'>long double<!--C--></span>

          (oczywiście jeśli już nie był tego typu).
</LI>
<LI>W przeciwnym przypadku: jeśli jeden jest typu
<!--O--><span class='typ'>double<!--C--></span>,
          to drugi też jest przekształcany do typu
<!--O--><span class='typ'>double<!--C--></span>.
</LI>
<LI>W przeciwnym przypadku: jeśli jeden jest typu
<!--O--><span class='typ'>float<!--C--></span>,
          to drugi też jest przekształcany do typu
<!--O--><span class='typ'>float<!--C--></span>.
</LI>
<LI>W przeciwnym przypadku oba argumenty są typów
          całościowych i&nbsp;są poddawane promocji całościowej zgodnie
          z&nbsp;następującą procedurą:

<UL>
<LI>Wartości typu
<!--O--><span class='typ'>signed char<!--C--></span>,
<!--O--><span class='typ'>unsigned                    char<!--C--></span>,
<!--O--><span class='typ'>signed short<!--C--></span>
 i&nbsp;
<!--O--><span class='typ'>unsigned short<!--C--></span>

                    są przekształcane do typu
<!--O--><span class='typ'>int<!--C--></span>, jeśli
                    wartość typu
<!--O--><span class='typ'>int<!--C--></span>
 może reprezentować
                    wszystkie wartości tych typów (co <FONT COLOR="#7b003e"><I>zachodzi</I></FONT>
                    dla &bdquo;zwykłych&rdquo;, 32-bitowych maszyn). W
                    przeciwnym przypadku są przekształcane do typu

<!--O--><span class='typ'>unsigned int<!--C--></span>, co oczywiście <FONT COLOR="#7b003e"><I>może</I></FONT>
                    zmienić ich wartość!
</LI>
<LI>Wartości typu wyliczeniowego są przekształcane
                    do najwęższego z&nbsp;typów
<!--O--><span class='typ'>int<!--C--></span>,

<!--O--><span class='typ'>unsigned int<!--C--></span>,
<!--O--><span class='typ'>long<!--C--></span>,
<!--O--><span class='typ'>unsigned long<!--C--></span>,
                    który jest dostatecznie obszerny, aby
                    reprezentować wszystkie wartości wyliczenia.
</LI>
<LI>Pola bitowe
                    (rozdział o <A HREF="node95.html#klasy:polbit">polach bitowych</A> )
                    są przekształcane do typu
<!--O--><span class='typ'>int<!--C--></span>
 lub jeśli
                    ten typ nie może reprezentować wszystkich
                    wartości pola &mdash;&nbsp;do typu
<!--O--><span class='typ'>unsigned int<!--C--></span>.
</LI>
<LI>Wartości typu
<!--O--><span class='typ'>bool<!--C--></span>
 są przekształcane do
                    wartości 0 (<!--O--><span class='klucz'>false<!--C--></span>) i&nbsp;1(<!--O--><span class='klucz'>true<!--C--></span>)
                    typu
<!--O--><span class='typ'>int<!--C--></span>.

</LI>
</UL>
</LI>
<LI>Następnie: Jeśli jeden z&nbsp;argumentów jest typu

<!--O--><span class='typ'>unsigned long<!--C--></span>, to drugi też jest przekształcany
          do typu
<!--O--><span class='typ'>unsigned long<!--C--></span>.
</LI>
<LI>W przeciwnym razie: jeśli jeden z&nbsp;argumentów jest
          typu
<!--O--><span class='typ'>long<!--C--></span>
 a&nbsp;drugi typu
<!--O--><span class='typ'>unsigned int<!--C--></span>
 i
          jeśli wartości typu
<!--O--><span class='typ'>unsigned int<!--C--></span>
 można
          w&nbsp;danej implementacji reprezentować w&nbsp;typie

<!--O--><span class='typ'>long<!--C--></span>
 (co zwykle <FONT COLOR="#7b003e"><I>nie</I></FONT> zachodzi na
          &bdquo;zwykłych&rdquo; maszynach 32-bitowych), to wartość
          typu
<!--O--><span class='typ'>unsigned int<!--C--></span>
 jest przkształcana
          do typu
<!--O--><span class='typ'>long<!--C--></span>; w&nbsp;przeciwnym razie oba argumenty
          są przekształcane do typu
<!--O--><span class='typ'>unsigned long<!--C--></span>
 (co
          może spowodować nieszczęście...).
</LI>
<LI>W przeciwnym razie, jeśli jeden z&nbsp;argumentów jest
          typu
<!--O--><span class='typ'>long<!--C--></span>, to drugi jest też przekształcany
          do typu
<!--O--><span class='typ'>long<!--C--></span>.
</LI>
<LI>W przeciwnym razie, jeśli jeden z&nbsp;argumentów jest
          typu
<!--O--><span class='typ'>unsigned int<!--C--></span>, to drugi jest też
          przekształcany do typu
<!--O--><span class='typ'>unsigned int<!--C--></span>.
</LI>
<LI>W przeciwnym razie oba argumenty są typu
<!--O--><span class='typ'>int<!--C--></span>

          i&nbsp;żadna konwersja nie jest potrzebna.
</LI>
</OL>

<P>
Na przykład, zgodnie z&nbsp;tymi zasadami, wyrażenie w&nbsp;trzeciej linii
fragmentu
<pre><tt>       <font color="#009900">int</font> i <font color="#990000">=</font> <font color="#993399">1</font><font color="#990000">,</font> j <font color="#990000">=</font> <font color="#993399">2</font><font color="#990000">,</font> k <font color="#990000">=</font> <font color="#993399">3</font><font color="#990000">,</font> m<font color="#990000">;</font>
       <i><font color="#9A1900">// ...</font></i>
       m <font color="#990000">=</font> <font color="#990000">(</font>j <font color="#990000">&gt;</font> i<font color="#990000">)</font> <font color="#990000">+</font> <font color="#990000">(</font>k <font color="#990000">&gt;</font> j<font color="#990000">);</font>
</tt></pre>
jest prawidłowe: wartości typu
<!--O--><span class='typ'>bool<!--C--></span>, jakimi są wartości
wyrażeń
<FONT COLOR="#000000"><TT>(j &gt; i)</TT></FONT> i&nbsp;
<FONT COLOR="#000000"><TT>(k &gt; j)</TT></FONT>, zostaną
niejawnie przekształcone do wartości całkowitych
(jedynek, bo obie relacje są w&nbsp;naszym przykładzie prawdziwe).
Zatem operator dodawania &bdquo;zobaczy&rdquo; po obu stronach dwie jedynki i
zmienna
<!--O--><span class='zmienna'>m<!--C--></span>
 uzyska wartość 2.

<P>
Często popełniany jest błąd przy dzieleniu:
pamiętajmy, że dzielenie liczb całkowitych zawsze,
zgodnie z&nbsp;powyższymi zasadami, daje wynik całkowity, a&nbsp;więc
części ułamkowej <FONT COLOR="#7b003e"><I>nie ma</I></FONT>. Początkującym często wydaje się,
że jeśli przypisują wynik do zmiennej typu
<!--O--><span class='typ'>double<!--C--></span>,
to w&nbsp;jakiś tajemniczy sposób część ułamkowa zostanie
&bdquo;odzyskana&rdquo;: tak nie będzie, jej tam po prostu nie ma, nie została
policzona!
Tak więc, jeśli aktualną wartością
zmiennej
<!--O--><span class='zmienna'>k<!--C--></span>
 typu
<!--O--><span class='typ'>int<!--C--></span>
 jest 7, to wartością
wyrażenia '
<FONT COLOR="#000000"><TT>k/2</TT></FONT>' jest <FONT COLOR="#7b003e"><I>dokładnie</I></FONT> 3. Jeśli chodziło
nam raczej o&nbsp;<!-- MATH
 $3\frac{1}{2}$
 -->
<SPAN CLASS="MATH">3<IMG
 WIDTH="19" HEIGHT="47" ALIGN="MIDDLE" BORDER="0"
 SRC="img12.png"
 ALT="$ {\frac{{1}}{{2}}}$"></SPAN>, to wystarczy dopisać kropkę
przy dwójce: wartością '
<FONT COLOR="#000000"><TT>k/2.</TT></FONT>' jest 3.5, bo '2.'
(z kropką) jest interpretowane jako literał wartości
typu
<!--O--><span class='typ'>double<!--C--></span>, a&nbsp;zatem i&nbsp;wartość
<!--O--><span class='zmienna'>k<!--C--></span>
 zostanie
przekształcona do typu
<!--O--><span class='typ'>double<!--C--></span>, a&nbsp;co za tym idzie i&nbsp;wynik
będzie również tego właśnie typu.

<P>
Do standardowych niejawnych konwersji, które mogą być
wykonane bez naszej wiedzy (i, niestety, zgody...), należy też:

<UL>
<LI>Przekształcenie dowolnego wskaźnika typu obiektowego do
          typu
<!--O--><span class='typ'>void*<!--C--></span>. Nie dotyczy to wskaźników do funkcji
          czy metod &mdash;&nbsp;
                  rozdział <A HREF="node71.html#funk:wskazfun">o wskaźnikach funkcyjnych</A> .
</LI>
<LI>Przekształcenie wyrażenia stałego o&nbsp;wartości 0 (zero)
          do wskaźnika
<!--O--><span class='zmienna'>NULL<!--C--></span>
 dowolnego typu oznaczającego
          wskaźnik pusty &mdash;&nbsp;nie wskazujący na żaden obiekt.
          Zero jest <FONT COLOR="#7b003e"><I>jedyną</I></FONT> wartością
          całkowitą, którą można przekształcić niejawnie na
          wartość wskaźnikową.
          Niejawne przekształcenie w&nbsp;drugą
          stronę &mdash;&nbsp;od wskaźnika pustego do liczby zero &mdash;&nbsp;
          nie zachodzi.
</LI>
<LI>Przekształcenie wartości o&nbsp;typie
<!--O--><span class='typ'>T*<!--C--></span>
 do wartości o
          typie
<!--O--><span class='typ'>const T*<!--C--></span>
 i&nbsp;od
<!--O--><span class='typ'>T&amp;<!--C--></span>
 do
<!--O--><span class='typ'>const T&amp;<!--C--></span>,
          gdzie
<!--O--><span class='typ'>T<!--C--></span>
 jest pewnym typem.
          Niejawne przekształcenie w&nbsp;drugą stronę nie zachodzi.
</LI>
<LI>Przekształcenie wartości typu liczbowego (całościowego
          lub zmiennopozycyjnego) lub wskaźnikowego do
          wartości typu
<!--O--><span class='typ'>bool<!--C--></span>
 (zero <!-- MATH
 $\rightarrow$
 -->
<SPAN CLASS="MATH">&#8594;</SPAN>
<!--O--><span class='klucz'>false<!--C--></span>,
          nie-zero <!-- MATH
 $\rightarrow$
 -->
<SPAN CLASS="MATH">&#8594;</SPAN>
<!--O--><span class='klucz'>true<!--C--></span>).
</LI>
<LI>Przekształcenie wartości typu całościowego do innego
          typu całościowego: jeśli typ docelowy jest

<!--O--><span class='typ'>unsigned<!--C--></span>, to wartość docelową tworzy się przez
          przekopiowanie, bez żadnej interpretacji, tylu bitów,
          ile ma typ docelowy.
</LI>
<LI>Przekształcenie wartości typu
<!--O--><span class='typ'>float<!--C--></span>
 do
<!--O--><span class='typ'>double<!--C--></span>

          <FONT COLOR="#7b003e"><I>i odwrotnie!</I></FONT>
</LI>
<LI>Przekształcenie wartości typów całościowych w
          zmiennoprzecinkowe i&nbsp;odwrotnie (te ostatnie z&nbsp;obcięciem
          części ułamkowej).
</LI>
<LI>Przekształcenie wskaźnika lub referencji do obiektu
          klasy pochodnej do wskaźnika lub referencji do obiektu
          klasy podstawowej.
</LI>
</UL>

<P>
Brzmi to skomplikowanie, bo też, niestety, jest to skomplikowane.
W dodatku jest też niebezpieczne: w&nbsp;C/C++ dozwolone są niejawne
konwersje, na skutek których traci się informację (zwykle kompilatory
wyświetlają wtedy jakieś ostrzeżenia).

<P>
Pamiętać przy tym należy, że niejawne konwersje wcale <FONT COLOR="#7b003e"><I>nie</I></FONT>
gwarantują, że otrzymana po przekształceniu wartość jest
z naszego punktu widzenia sensowna, to znaczy zgodna w&nbsp;oczekiwanym
przez nas sensie z&nbsp;wartością przed przekształceniem.
Na przykład rozpatrzmy program:
<BR><A NAME="surp.cpp"></A>
<BR CLEAR='ALL'>
<div class='kodpro'><HR>
      <SPAN  CLASS="textbf">P<SPAN CLASS="arabic">62</SPAN>:</SPAN>
      <A NAME="tex2html67"
  HREF="source-files/surp.cpp">
<!--O--><span class='downl'>surp.cpp<!--C--></span></A>
<A NAME="11192"></A>
      &nbsp;&nbsp;&nbsp;&nbsp;<SMALL CLASS="SMALL">Niejawne konwersje</SMALL>
      <BR CLEAR="ALL">
<HR>
<pre><tt> <font SIZE="-2" color="black">     1.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;iostream&gt;</font>
 <font SIZE="-2" color="black">     2.  </font><b><font color="#0000FF">using</font></b> <b><font color="#0000FF">namespace</font></b> std<font color="#990000">;</font>
 <font SIZE="-2" color="black">     3.  </font>
 <font SIZE="-2" color="black">     4.  </font><font color="#009900">int</font> <b><font color="#000000">main</font></b><font color="#990000">()</font>
 <font SIZE="-2" color="black">     5.  </font><font color="#FF0000">{</font>
 <font SIZE="-2" color="black">     6.  </font>    <font color="#009900">int</font>      k   <font color="#990000">=</font> <font color="#990000">-</font><font color="#993399">2</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">     7.  </font>    <font color="#009900">unsigned</font> uns <font color="#990000">=</font>  <font color="#993399">1</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">     8.  </font>
 <font SIZE="-2" color="black">     9.  </font>    <font color="#009900">int</font>      x <font color="#990000">=</font> k <font color="#990000">+</font> uns<font color="#990000">;</font>
 <font SIZE="-2" color="black">    10.  </font>    <font color="#009900">unsigned</font> y <font color="#990000">=</font> k <font color="#990000">+</font> uns<font color="#990000">;</font>
 <font SIZE="-2" color="black">    11.  </font>
 <font SIZE="-2" color="black">    12.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"x   = "</font> <font color="#990000">&lt;&lt;</font> x      <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    13.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"y   = "</font> <font color="#990000">&lt;&lt;</font> y      <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    14.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"y+1 = "</font> <font color="#990000">&lt;&lt;</font> y <font color="#990000">+</font> <font color="#993399">1</font>  <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    15.  </font>
 <font SIZE="-2" color="black">    16.  </font>
 <font SIZE="-2" color="black">    17.  </font>    <font color="#009900">signed</font>   <font color="#009900">char</font> c <font color="#990000">=</font> <font color="#993399">255</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    18.  </font>    <font color="#009900">unsigned</font> <font color="#009900">char</font> d <font color="#990000">=</font> <font color="#993399">255</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    19.  </font>
 <font SIZE="-2" color="black">    20.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"c+1 = "</font> <font color="#990000">&lt;&lt;</font> c <font color="#990000">+</font> <font color="#993399">1</font>  <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    21.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"d+1 = "</font> <font color="#990000">&lt;&lt;</font> d <font color="#990000">+</font> <font color="#993399">1</font>  <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    22.  </font>    d <font color="#990000">=</font> d <font color="#990000">+</font> <font color="#993399">1</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    23.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"d   = "</font> <font color="#990000">&lt;&lt;</font> <font color="#990000">(</font><font color="#009900">int</font><font color="#990000">)</font>d <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    24.  </font><font color="#FF0000">}</font>
</tt></pre>
<hr>

</div>

<P>
Program ten drukuje:
<PRE>
    x   = -1
    y   = 4294967295
    y+1 = 0
    c+1 = 0
    d+1 = 256
    d   = 0
</PRE>
Wartość zmiennej
<!--O--><span class='zmienna'>x<!--C--></span>
 to zgodnie z&nbsp;oczekiwaniem -1.
Ale drukowanie wartości zmiennej
<!--O--><span class='zmienna'>y<!--C--></span>
 daje
<TT>4294967295</TT> (nie jest to
taka sobie przypadkowa liczba; jej wartość to <SPAN CLASS="MATH">2<SUP>32</SUP> - 1</SPAN>).
Po dodaniu
do tej liczby jedynki otrzymujemy dokładnie zero (linia&nbsp;14
programu drukuje '<TT>y + 1 = 0</TT>'). Wydawałoby się, że
zmienne
<!--O--><span class='zmienna'>c<!--C--></span>
 i&nbsp;
<!--O--><span class='zmienna'>d<!--C--></span>
 mają te same wartości, więc i&nbsp;po
dodaniu jedynki otrzymamy to samo. Ale linia&nbsp;20 drukuje
'<TT>c + 1 = 0</TT>', natomiast linia&nbsp;21 drukuje '<TT>d + 1 = 256</TT>'.
Jednak gdy wartość '
<FONT COLOR="#000000"><TT>d + 1</TT></FONT>' przypiszemy znów
do zmiennej
<!--O--><span class='zmienna'>d<!--C--></span>
 i&nbsp;wydrukujemy jej wartość
jako
<!--O--><span class='typ'>int<!--C--></span>
 (linia&nbsp;23), dostaniemy 0.
Jak widać, szczególnie łatwo jest pogubić się przy
konwersjach od typów ze znakiem do typów bez znaku
i&nbsp;odwrotnie &mdash;&nbsp;związane jest to z&nbsp;faktem, o&nbsp;którym wspominaliśmy,
że
zbiory wartości takich typów nie pozostają do siebie w&nbsp;relacji
zawierania: nie można powiedzieć, który jest &bdquo;węższy&rdquo;, a&nbsp;który
&bdquo;szerszy&rdquo;.

<P>
Najczęściej jednak nie musimy aż tak dokładnie analizować tego typu wyrażeń,
jeśli trzymamy się podstawowych typów i&nbsp;staramy się pisać kod w&nbsp;sposób
czytelny i&nbsp;prosty. Trzeba tylko pamiętać, że typy całkowite węższe
od
<!--O--><span class='typ'>int<!--C--></span>
 zawsze promowane są co najmniej do typu
<!--O--><span class='typ'>int<!--C--></span>.
Dotyczy to w&nbsp;szczególności wartości znakowych (typu
<!--O--><span class='typ'>char<!--C--></span>).
Użyte jako argument operatorów lub argument w&nbsp;wywołaniu funkcji
są przekształcane do wartości całkowitej typu
<!--O--><span class='typ'>int<!--C--></span>
 równej
kodowi ASCII<A NAME="11045"></A> danego znaku. Na przykład po przypisaniu
<pre><tt>       <font color="#009900">int</font> k <font color="#990000">=</font> <font color="#993399">3</font> <font color="#990000">+</font> <font color="#FF0000">'a'</font><font color="#990000">;</font>
</tt></pre>
wartość
<!--O--><span class='zmienna'>k<!--C--></span>
 wynosi 100, bo kod ASCII małej litery 'a'
jest 97.

<P>
Można z&nbsp;tej własności skorzystać do napisania
prostej funkcji odczytującej ciąg znaków aż do napotkania
nie-cyfry i&nbsp;interpretującej ten napis jako
dodatnią liczbę całowitą:
<BR><A NAME="konw.cpp"></A>
<BR CLEAR='ALL'>
<div class='kodpro'><HR>
      <SPAN  CLASS="textbf">P<SPAN CLASS="arabic">63</SPAN>:</SPAN>
      <A NAME="tex2html68"
  HREF="source-files/konw.cpp">
<!--O--><span class='downl'>konw.cpp<!--C--></span></A>
<A NAME="11212"></A>
      &nbsp;&nbsp;&nbsp;&nbsp;<SMALL CLASS="SMALL">Konwersje znak <!-- MATH
 $\rightarrow$
 -->
<SPAN CLASS="MATH">&#8594;</SPAN> liczba</SMALL>
      <BR CLEAR="ALL">
<HR>
<pre><tt> <font SIZE="-2" color="black">     1.  </font><b><font color="#000080">#include</font></b> <font color="#FF0000">&lt;iostream&gt;</font>
 <font SIZE="-2" color="black">     2.  </font><b><font color="#0000FF">using</font></b> <b><font color="#0000FF">namespace</font></b> std<font color="#990000">;</font>
 <font SIZE="-2" color="black">     3.  </font>
 <font SIZE="-2" color="black">     4.  </font><font color="#009900">int</font> <b><font color="#000000">konwert</font></b><font color="#990000">(</font><font color="#009900">char</font><font color="#990000">*</font> nap<font color="#990000">)</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">     5.  </font>    <font color="#009900">int</font> w <font color="#990000">=</font> <font color="#993399">0</font><font color="#990000">,</font> i <font color="#990000">=</font> <font color="#993399">0</font><font color="#990000">,</font> c<font color="#990000">;</font>
 <font SIZE="-2" color="black">     6.  </font>    <b><font color="#0000FF">while</font></b> <font color="#990000">(</font>c <font color="#990000">=</font> nap<font color="#990000">[</font>i<font color="#990000">++],</font> c <font color="#990000">&gt;=</font> <font color="#FF0000">'0'</font> <font color="#990000">&amp;&amp;</font> c <font color="#990000">&lt;=</font> <font color="#FF0000">'9'</font><font color="#990000">)</font>
 <font SIZE="-2" color="black">     7.  </font>        w <font color="#990000">=</font> <font color="#993399">10</font><font color="#990000">*</font>w <font color="#990000">+</font> c <font color="#990000">-</font> <font color="#FF0000">'0'</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">     8.  </font>    <b><font color="#0000FF">return</font></b> w<font color="#990000">;</font>
 <font SIZE="-2" color="black">     9.  </font><font color="#FF0000">}</font>
 <font SIZE="-2" color="black">    10.  </font>
 <font SIZE="-2" color="black">    11.  </font><font color="#009900">int</font> <b><font color="#000000">main</font></b><font color="#990000">()</font> <font color="#FF0000">{</font>
 <font SIZE="-2" color="black">    12.  </font>    <font color="#009900">char</font> tab1<font color="#990000">[]</font> <font color="#990000">=</font> <font color="#FF0000">"123a"</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    13.  </font>    <font color="#009900">char</font> tab2<font color="#990000">[]</font> <font color="#990000">=</font> <font color="#FF0000">"456 1"</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    14.  </font>    <font color="#009900">char</font> tab3<font color="#990000">[]</font> <font color="#990000">=</font> <font color="#FF0000">" 56"</font><font color="#990000">;</font>
 <font SIZE="-2" color="black">    15.  </font>
 <font SIZE="-2" color="black">    16.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"tab1 -&gt; "</font> <font color="#990000">&lt;&lt;</font> <b><font color="#000000">konwert</font></b><font color="#990000">(</font>tab1<font color="#990000">)</font> <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    17.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"tab2 -&gt; "</font> <font color="#990000">&lt;&lt;</font> <b><font color="#000000">konwert</font></b><font color="#990000">(</font>tab2<font color="#990000">)</font> <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    18.  </font>    cout <font color="#990000">&lt;&lt;</font> <font color="#FF0000">"tab3 -&gt; "</font> <font color="#990000">&lt;&lt;</font> <b><font color="#000000">konwert</font></b><font color="#990000">(</font>tab3<font color="#990000">)</font> <font color="#990000">&lt;&lt;</font> endl<font color="#990000">;</font>
 <font SIZE="-2" color="black">    19.  </font><font color="#FF0000">}</font>
</tt></pre>
<hr>

</div>

<P>
Wynikiem jest
<PRE>
    tab1 -&gt; 123
    tab2 -&gt; 456
    tab3 -&gt; 0
</PRE>
Funkcja
<!--O--><span class='funkcja'>konwert<!--C--></span>
 pobiera jako argument tablicę
znaków w&nbsp;postaci wskaźnika do pierwszego jej elementu.
Następnie, w&nbsp;pętli
<!--O--><span class='klucz'>while<!--C--></span>
 przetwarzane są kolejne znaki
tego napisu. Wewnątrz nawiasów okrągłych, gdzie jest miejsce
na wyrażenie logiczne sterujące pętlą, mamy tu wyrażenie
przecinkowe. Wyrażenie będące lewym argumentem wczytuje kolejny
znak napisu do zmiennej
<!--O--><span class='zmienna'>c<!--C--></span>, po czym zwiększa aktualną
wartość indeksu. Wartością całego wyrażenia przecinkowego
jest wartość prawego argumentu, a&nbsp;tu mamy sprawdzenie, czy wczytany
znak jest cyfrą. Co jest bowiem np.&nbsp;wartością wyrażenia

<FONT COLOR="#000000"><TT>c &gt;= '0'</TT></FONT>? Przed dokonaniem porównania obie strony
tej nierówności są przkształcane do typu
<!--O--><span class='typ'>int<!--C--></span>. Zatem wartością
zmiennej znakowej
<!--O--><span class='zmienna'>c<!--C--></span>
 będzie kod ASCII wczytanego znaku.
Podobnie wartością
<!--O--><span class='zmienna'>'0'<!--C--></span>
 (z apostrofami!) będzie
po konwersji do typu
<!--O--><span class='typ'>int<!--C--></span>
 kod ASCII <FONT COLOR="#7b003e"><I>znaku</I></FONT> '0' &mdash;&nbsp;jest to
liczba 48, ale wcale nie musimy o&nbsp;tym wiedzieć. Podkreślmy jeszcze raz,
bo jest to źródłem wielu błędów: wartością liczbową zmiennej znakowej

<!--O--><span class='zmienna'>'0'<!--C--></span>
 jest kod ASCII znaku zero (czyli 48), a&nbsp;<FONT COLOR="#7b003e"><I>nie</I></FONT> liczba
zero. Literałem znaku o&nbsp;kodzie ASCII równym zero jest '<!-- MATH
 $\backslash$
 -->
<SPAN CLASS="MATH">&#92;</SPAN>0', łącznie
z&nbsp;apostrofami i&nbsp;odwrotnym ukośnikiem.

<P>
Kody ASCII kolejnych cyfr, 0, ..., 9, są kolejnymi liczbami
całkowitymi (zeru odpowiada 48, jedynce &mdash;&nbsp;49 itd., ale na szczęście nie
musimy tych kodów pamiętać). Tak więc warunek

<FONT COLOR="#000000"><TT>c &gt;= '0' &amp;&amp; c &lt;= '9'</TT></FONT> sprawdza, czy kod ASCII
znaku
<!--O--><span class='zmienna'>c<!--C--></span>
 jest jednocześnie większy lub równy od kodu znaku '0'
i&nbsp;mniejszy lub równy od kodu znaku '9', czyli czy jest to znak
odpowiadający cyfrze. Jeśli nie, pętla zostanie przerwana.

<P>
Powtórnie wykorzystujemy ten mechanizm
w&nbsp;następnej linii: wyrażenie
<FONT COLOR="#000000"><TT>c-'0'</TT></FONT> ma wartość
<FONT COLOR="#7b003e"><I>liczbową</I></FONT> równą liczbie reprezentowanej przez znak
<!--O--><span class='zmienna'>c<!--C--></span>.
Jeśli np.&nbsp;
<!--O--><span class='zmienna'>c<!--C--></span>
 jest znakiem '4', to

<FONT COLOR="#000000"><TT>'4'-'0'</TT></FONT> jest tym samym co <SPAN CLASS="MATH">52 - 48</SPAN>, czyli&nbsp;4 (tym
razem <FONT COLOR="#7b003e"><I>liczbowo</I></FONT> cztery). Zatem, jeśli kolejny wczytany znak jest
cyfrą, to dotychczasowa wartość zmiennej
<!--O--><span class='zmienna'>w<!--C--></span>
  jest mnożona przez
dziesięć, co odpowiada przesunięciu cyfr o&nbsp;jedną pozycję w&nbsp;lewo, i&nbsp;dodawana
jest na pozycji jedności wartość liczbowa odpowiadająca wczytanej cyfrze.
Pętla kończy się, gdy kolejnym znakiem nie jest cyfra. Dlatego

<!--O--><span class='zmienna'>tab2<!--C--></span>
 zostanie zinterpretowana jako 456; wczytywanie zostanie
zakończone, gdy napotkany zostanie odstęp pomiędzy cyfrą 6 a&nbsp;1.
Dla
<!--O--><span class='zmienna'>tab3<!--C--></span>
 otrzymamy&nbsp;0, bo pętla nie wykona ani jednego obrotu:
jako pierwszy znak zostanie bowiem wczytany odstęp, a&nbsp;więc nie-cyfra.

<P>

<DIV CLASS="navigation"><HR>
<A NAME="tex2html1523"
  HREF="node56.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="ikonypng/prev.png"></A>
<A NAME="tex2html1529"
  HREF="node56.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="ikonypng/up.png"></A>
<A NAME="tex2html1535"
  HREF="node58.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="ikonypng/next.png"></A>
<A NAME="tex2html1531"
  HREF="node1.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="ikonypng/contents.png"></A>
<A NAME="tex2html1533"
  HREF="node150.html">
<IMG WIDTH="48" HEIGHT="48" ALIGN="BOTTOM" BORDER="0" ALT="index"
 SRC="ikonypng/index.png"></A> <BR>
<B>Wstecz:</B> <A NAME="tex2html1524"
  HREF="node56.html">10. Konwersje niejawne, porządek</A>
<B>W g&#243;r&#281;:</B> <A NAME="tex2html1530"
  HREF="node56.html">10. Konwersje niejawne, porządek</A>
<B>Dalej:</B> <A NAME="tex2html1536"
  HREF="node58.html">10.2 Porządek wartościowania</A>
</DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<p style="text-align:right;"><I><font size=-2>T.R. Werner, 28 września 2018; 23:31</font></I></p>
</ADDRESS>
</BODY>
</HTML>
